<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <title>Image Rotation Studio</title>
  
  <!-- html2canvas –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –∑–∞—Ö–≤–∞—Ç–∞ DOM —ç–ª–µ–º–µ–Ω—Ç–æ–≤ -->
  <script>
    // –ó–∞–≥—Ä—É–∂–∞–µ–º html2canvas –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
    (function() {
      const script = document.createElement('script');
      script.src = 'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
      script.onload = function() {
        console.log('‚úÖ html2canvas loaded successfully');
      };
      script.onerror = function() {
        console.log('‚ùå html2canvas failed to load');
      };
      document.head.appendChild(script);
    })();
  </script>

  <style>
    body {
      font-family: "Inter", sans-serif;
      margin: 0;
      padding: 16px;
      background: #f0f2f5;
      color: #333;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .card {
      background: #fff;
      border-radius: 14px;
      padding: 14px 12px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .08);
    }

    #licenseInfo {
      background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
      border: 2px solid #dc2626;
      border-radius: 14px;
      padding: 14px 16px;
      color: #ffffff;
      box-shadow: 0 4px 12px rgba(0, 0, 0, .2);
    }

    #licenseInfo.normal {
      background: linear-gradient(135deg, #475569 0%, #334155 100%);
      border: 1px solid #64748b;
    }

    #licenseInfo.normal #licenseStatusText {
      color: #ffffff;
    }

    #licenseInfo.warning {
      background: linear-gradient(135deg, #475569 0%, #334155 100%);
      border: 1px solid #64748b;
    }

    #licenseInfo.warning #licenseStatusText {
      color: #ffffff;
    }

    #licenseInfo.danger {
      background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
      border: 2px solid #dc2626;
      border-radius: 16px;
    }

    #licenseInfo.danger #licenseStatusText {
      color: #ffffff;
    }

    /* Hover effect for upgrade button */
    #upgradeBtn:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%) !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4) !important;
    }

    /* Light and dark theme styles are the same for this design */
    html[data-theme='light'] #licenseInfo,
    html[data-theme='dark'] #licenseInfo {
      background: linear-gradient(135deg, #475569 0%, #334155 100%);
      border-color: #64748b;
      color: #e2e8f0;
    }

    html[data-theme='light'] #licenseInfo.danger,
    html[data-theme='dark'] #licenseInfo.danger {
      background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
      border-color: #dc2626;
    }

    html[data-theme='light'] #licenseInfo.danger #licenseStatusText,
    html[data-theme='dark'] #licenseInfo.danger #licenseStatusText {
      color: #ffffff;
    }

    html[data-theme='light'] #licenseDetailsText,
    html[data-theme='dark'] #licenseDetailsText {
      color: #a0aec0 !important;
    }

    .group-title {
      font-size: 12px;
      font-weight: 700;
      color: #25314c;
      margin-bottom: 8px;
    }

    /* Fullscreen mode styles */
    body.fs {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      background: #1a1a1a;
      overflow: hidden;
      z-index: 9999;
    }

    body.fs > .card,
    body.fs > .footer,
    body.fs > .toolbar {
      display: none !important;
    }

    body.fs #imagePreview {
      position: fixed !important;
      top: 0 !important;
      left: 200px !important;
      right: 200px !important;
      bottom: 0 !important;
      background: #2a2a2a !important;
      border-radius: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      z-index: 9998 !important;
    }

    .fs-side {
      position: fixed;
      top: 0;
      bottom: 0;
      width: 200px;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      color: #fff;
      padding: 20px;
      overflow-y: auto;
      z-index: 10000;
    }

    .fs-left {
      left: 0;
    }

    .fs-right {
      right: 0;
    }

    .fs-panel {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }

    .fs-panel-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #fff;
    }

    .fs-rotation-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .fs-rotation-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .fs-rotation-label {
      font-size: 10px;
      color: #ccc;
    }

    .fs-rotation-input {
      width: 100%;
      padding: 4px;
      border: 1px solid #555;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      font-size: 12px;
    }

    .fs-rotation-slider {
      width: 100%;
      height: 4px;
      background: #555;
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }

    .fs-rotation-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #4b8bf5;
      cursor: pointer;
    }

    .fs-preset-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
    }

    .fs-preset-btn {
      padding: 6px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #fff;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .fs-preset-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .fs-exit-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      color: #fff;
      font-size: 18px;
      cursor: pointer;
      z-index: 10001;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .fs-exit-btn:hover {
      background: rgba(255, 0, 0, 0.8);
      transform: scale(1.1);
    }

    .hidden {
      display: none !important;
    }

    .primary-button {
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%);
      border: none;
      border-radius: 12px;
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 2px 8px rgba(75, 139, 245, 0.3);
    }

    .primary-button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(75, 139, 245, 0.4);
    }

    .primary-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #222;
      text-align: center;
    }

    .title-rainbow {
      background: linear-gradient(90deg, #ff6b6b, #f7b267, #ffd93d, #6bcb77, #4d96ff, #8358ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 14px;
    }

    .theme-toggle {
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      border-radius: 999px;
      border: 1px solid #d5dceb;
      background: #fff;
      color: #4a5875;
      cursor: pointer;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(75, 139, 245, 0.3);
      transition: all .2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .button-secondary {
      flex: 1;
      padding: 8px 14px;
      border: 1px solid #d6ddeb;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      color: #4a5875;
      font-weight: 600;
      border-radius: 10px;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    .button-secondary:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
    }

    .button-recovery {
      display: block;
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border: none;
      border-radius: 12px;
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
      margin-top: 8px;
    }

    .button-recovery:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .button-recovery:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* Dark theme */
    html[data-theme='dark'] body {
      background: #2c2c2c;
      color: #e8e8e8;
    }

    html[data-theme='dark'] .card {
      background: #343434;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .35);
    }

    html[data-theme='dark'] .group-title {
      color: #d0d0d0;
    }

    html[data-theme='dark'] input[type="range"] {
      background: linear-gradient(135deg, #4a4f56 0%, #3a3f46 100%);
    }

    html[data-theme='dark'] .theme-toggle {
      background: #343434;
      border-color: #4a4a4a;
      color: #e0e0e0;
    }

    html[data-theme='dark'] #imagePreview {
      background: #2c2c2c;
      border-color: #4a4a4a;
    }

    html[data-theme='dark'] .button-secondary {
      background: linear-gradient(135deg, #3a3f46 0%, #2d3238 100%);
      border-color: #4a4f56;
      color: #e0e0e0;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .footer {
      margin-top: auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-top: 6px;
    }

    .footer-link {
      color: #4b8bf5;
      font-weight: 600;
      text-decoration: none;
    }

    html[data-theme='dark'] .footer-link {
      color: #9ec5ff;
    }

    /* Language switcher */
    .language-switcher {
      position: relative;
      display: inline-block;
      z-index: 20;
    }

    .language-selected {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px 6px 10px;
      border-radius: 999px;
      border: 1px solid #d5dceb;
      background: #fff;
      color: #4a5875;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }

    .language-name {
      white-space: nowrap;
    }

    .language-code {
      font-weight: 700;
      letter-spacing: .3px;
    }

    .language-selected::after {
      content: "";
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 5px solid currentColor;
      opacity: .7;
      margin-left: 4px;
    }

    .language-dropdown {
      position: absolute;
      right: 0;
      bottom: calc(100% + 8px);
      min-width: 160px;
      background: #fff;
      border-radius: 12px;
      border: 1px solid #dce3f1;
      box-shadow: 0 -8px 24px rgba(15, 30, 60, .12);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 10;
    }

    .language-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: #4a5875;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .language-option:hover {
      background: #f3f4f6;
    }

    .language-flag {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .language-flag img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    html[data-theme='dark'] .language-selected {
      background: #343434;
      border-color: #4a4a4a;
      color: #e0e0e0;
    }

    html[data-theme='dark'] .language-dropdown {
      background: #343434;
      border-color: #4a4a4a;
      box-shadow: 0 -12px 30px rgba(0, 0, 0, .45);
    }

    html[data-theme='dark'] .language-option {
      color: #e0e0e0;
    }

    html[data-theme='dark'] .language-option:hover {
      background: #4b5563;
    }

    /* Dark theme for status badge */
    html[data-theme='dark'] .status-badge.pro {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      border-color: #059669;
    }

    html[data-theme='dark'] .status-badge.free {
      background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
      border-color: #d97706;
    }

    /* Modal styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .hidden {
      display: none !important;
    }

    .modal-content {
      background: #fff;
      border-radius: 16px;
      max-width: 440px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px 12px;
      border-bottom: 1px solid #e5e7eb;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #111827;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: #6b7280;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .modal-close:hover {
      background: #f3f4f6;
      color: #374151;
    }

    .modal-body {
      padding: 16px 20px;
    }

    .modal-body p {
      margin: 0 0 20px;
      color: #4b5563;
      line-height: 1.5;
    }

    .modal-features {
      margin: 20px 0;
    }

    .feature {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      font-size: 14px;
      color: #374151;
    }

    .modal-price {
      text-align: center;
      margin: 24px 0;
      padding: 16px;
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border-radius: 12px;
      border: 1px solid #0ea5e9;
    }

    .price {
      font-size: 24px;
      font-weight: 700;
      color: #0c4a6e;
      margin-bottom: 4px;
    }

    .price-note {
      font-size: 12px;
      color: #0369a1;
    }

    .modal-footer {
      padding: 12px 20px 20px;
      display: flex;
      gap: 12px;
      flex-direction: column;
    }

    /* Status badge (copied from –ø—Ä–∏–º–µ—Ä1.html) */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid;
      position: relative;
      overflow: hidden;
    }

    .status-badge::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .status-badge:hover::before {
      left: 100%;
    }

    .status-badge.pro {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border-color: #10b981;
      color: #fff;
      box-shadow: 0 2px 6px rgba(16, 185, 129, 0.3);
    }

    .status-badge.pro:hover {
      background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }

    .status-badge.free {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      border-color: #f59e0b;
      color: #fff;
      box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3);
    }

    .status-badge.free:hover {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }

    .status-badge.warning {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      border-color: #f59e0b;
      color: #fff;
      box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3);
    }

    .status-badge.warning:hover {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }

    .status-icon {
      width: 12px;
      height: 12px;
    }

    /* Status badge styles */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      border: none;
    }

    .status-badge.free {
      background: linear-gradient(135deg, #64748b 0%, #475569 100%);
      color: #ffffff;
    }

    .status-badge.pro {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: #ffffff;
    }

    .status-badge.warning {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: #ffffff;
    }

    .status-badge:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    /* Modal styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      background: #fff;
      border-radius: 16px;
      width: 90%;
      max-width: 400px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px 20px 0 20px;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #374151;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #6b7280;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
    }

    .modal-close:hover {
      background: #f3f4f6;
      color: #374151;
    }

    .modal-body {
      padding: 20px;
    }

    .modal-footer {
      padding: 0 20px 20px 20px;
    }

    .button-recovery {
      display: block;
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border: none;
      border-radius: 12px;
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }

    .button-recovery:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
      background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
    }

    .button-secondary {
      border: 1px solid #d6ddeb;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      color: #4a5875;
      font-weight: 600;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    .button-secondary:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-color: #94a3b8;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
    }

    /* Compact buttons for rotation presets */
    .button-compact {
      border: 1px solid #d6ddeb;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      color: #4a5875;
      font-weight: 600;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      font-size: 11px;
      flex: 1;
      text-align: center;
    }

    .button-compact:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-color: #94a3b8;
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .button-compact:active {
      transform: translateY(0px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    /* Styled number inputs */
    .rotation-input {
      width: 65px;
      padding: 3px 3px;
      border: 1px solid #d6ddeb;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      text-align: center;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      color: #4a5875;
      transition: all .2s ease;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      box-sizing: border-box;
    }

    .rotation-input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1), 0 1px 3px rgba(0, 0, 0, 0.1);
      background: #fff;
    }

    .rotation-input:hover {
      border-color: #94a3b8;
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    }

    /* Match Target Overlay Styles */
    .preview-container {
      position: relative;
      width: 100%;
      height: 200px;
      background: #f8f9fa;
      border: 1px solid #e1e6ef;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      overflow: hidden;
    }

    .target-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .target-overlay img {
      width: auto;
      height: auto;
      max-width: 90%;
      max-height: 90%;
      opacity: 0.5;
      border: 2px dashed #3b82f6;
      border-radius: 4px;
      object-fit: contain;
    }

    .preview-content {
      position: relative;
      z-index: 5;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    html[data-theme='dark'] .preview-container {
      background: #2c2c2c;
      border-color: #4a4a4a;
    }

    html[data-theme='dark'] .target-overlay img {
      border-color: #60a5fa;
    }

    /* Fullscreen Mode Styles */
    body.fs { 
      padding: 8px; 
      overflow: hidden;
    }
    
    body.fs .card { 
      display: none; 
    }
    
    body.fs .preview-card { 
      display: block !important; 
      background: transparent; 
      box-shadow: none; 
      padding: 0; 
      margin: 0; 
      height: 100vh;
    }
    
    body.fs #imagePreview { 
      background: #0f1113; 
      border: 1px solid #2b3036; 
      width: calc(100vw - 320px); 
      height: calc(100vh - 40px); 
      margin: 0 auto; 
      border-radius: 12px;
      position: relative;
      overflow: auto;
      cursor: grab;
    }
    
    body.fs #imagePreview:active {
      cursor: grabbing;
    }
    
    body.fs #previewContent {
      transform-origin: center center;
      transition: transform 0.1s ease;
      min-width: 100%;
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .fs-side { 
      position: fixed; 
      top: 100px; 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
      z-index: 12; 
    }
    
    .fs-exit-btn {
      position: fixed;
      top: 20px;
      right: 120px;
      padding: 8px 12px;
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      z-index: 15;
      box-shadow: 0 3px 8px rgba(239, 68, 68, 0.3);
    }
    
    .fs-exit-btn:hover {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
      transform: translateY(-1px);
    }
    
    .fs-left { 
      left: 16px; 
      width: 160px; 
    }
    
    .fs-right { 
      right: 16px; 
      width: 240px; 
      max-height: calc(100vh - 80px);
      overflow-y: auto;
    }
    
    .fs-panel { 
      background: #fff; 
      border: 1px solid #d6ddeb; 
      border-radius: 12px; 
      padding: 12px; 
      box-shadow: 0 4px 14px rgba(0,0,0,.12); 
      margin-bottom: 8px;
    }
    
    .fs-panel-title { 
      font-size: 12px; 
      font-weight: 700; 
      color: #4a5875; 
      margin-bottom: 8px;
    }
    
    .fs-rotation-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .fs-rotation-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .fs-rotation-label {
      flex: 1;
      font-size: 11px;
      color: #0369a1;
      font-weight: 600;
    }
    
    .fs-rotation-input {
      width: 50px;
      padding: 4px 6px;
      border: 1px solid #d6ddeb;
      border-radius: 6px;
      font-size: 11px;
      text-align: center;
    }
    
    .fs-rotation-slider {
      flex: 2;
    }
    
    .fs-preset-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
      margin-top: 8px;
    }
    
    .fs-preset-btn {
      padding: 4px 4px;
      font-size: 8px;
      background: linear-gradient(135deg, #eef3f8 0%, #e1e8ed 100%);
      border: 1px solid #d6ddeb;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .fs-preset-btn:hover {
      background: linear-gradient(135deg, #e1e8ed 0%, #d4dde4 100%);
      transform: translateY(-1px);
    }
    

    
    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <div class="toolbar">
    <h2 class="title-rainbow">Image Rotation Studio</h2>
    <div style="display:flex; align-items:center; gap:8px;">
      <!-- PRO/FREE Status Badge -->
      <button type="button" class="status-badge free" id="statusBadge" title="Click to view subscription details">
        <svg class="status-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2L15.09 8.26L22 9L17 14L18.18 21L12 17.77L5.82 21L7 14L2 9L8.91 8.26L12 2Z"
            fill="currentColor" />
        </svg>
        <span id="statusText">FREE</span>
      </button>
      <button class="theme-toggle" onclick="toggleTheme()">üåô</button>
    </div>
  </div>







  <div class="card preview-card" style="position: sticky; top: 16px; z-index: 10;">
    <div class="group-title">
      Preview
      <label style="float:right; font-size:10px; font-weight:normal;">
        <input type="checkbox" id="useCanvasPreview"> Canvas mode
      </label>
    </div>
    <div id="imagePreview" class="preview-container">
      <div id="targetOverlay" class="target-overlay" style="display:none;"></div>
      <div id="previewContent" class="preview-content">
        No image selected
      </div>
    </div>
  </div>

  <div class="card">
    <div class="group-title">Rotation</div>
    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
      <label style="flex: 1;">Z Rotation: <span id="rotationValue">0¬∞</span></label>
      <input type="number" id="rotationInput" min="-180" max="180" value="0" step="1" class="rotation-input"
        placeholder="0">
    </div>
    <input type="range" id="rotationSlider" min="-180" max="180" value="0" step="1" style="width:100%; margin:8px 0;">

    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
      <label style="flex: 1;">X Rotation: <span id="rotationXValue">0¬∞</span></label>
      <input type="number" id="rotationXInput" min="-90" max="90" value="0" step="1" class="rotation-input"
        placeholder="0">
    </div>
    <input type="range" id="rotationXSlider" min="-90" max="90" value="0" step="1" style="width:100%; margin:8px 0;">

    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
      <label style="flex: 1;">Y Rotation: <span id="rotationYValue">0¬∞</span></label>
      <input type="number" id="rotationYInput" min="-90" max="90" value="0" step="1" class="rotation-input"
        placeholder="0">
    </div>
    <input type="range" id="rotationYSlider" min="-90" max="90" value="0" step="1"
      style="width:100%; margin:8px 0 8px 0;">

    <!-- Quick rotation buttons -->
    <div style="display:flex; gap:4px; margin-top:12px;">
      <button onclick="setRotation(90)" class="button-compact">‚Ü∫ -90¬∞</button>
      <button onclick="setRotation(-90)" class="button-compact">‚Üª +90¬∞</button>
      <button onclick="setRotation(180)" class="button-compact">‚Üï 180¬∞</button>
      <button onclick="resetAllRotations()" class="button-compact">‚ü≤ Reset</button>
    </div>

    <!-- Copy rotation buttons -->
    <div style="display:flex; gap:4px; margin-top:8px;">
      <button onclick="copyRotation()" class="button-compact" id="copyRotationBtn">üìã Copy Rotation</button>
      <button onclick="applyRotationFromClipboard()" class="button-compact" id="applyRotationBtn" disabled>üìå Apply
        Copied</button>
    </div>
  </div>







  <div class="card">
    <div class="group-title">Apply</div>

    <label style="display:flex; align-items:center; gap:8px; margin-bottom:20px; font-size:11px;">
      <input type="checkbox" id="keepOriginalSize" checked>
      Keep original size
    </label>

    <!-- License info block -->
    <div id="licenseInfo" style="display:block; margin-bottom:16px;">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:16px;">
        <div style="flex:1;">
          <div id="licenseStatusText" style="font-size:13px; font-weight:600; margin-bottom:2px; color:#ffffff;"></div>
          <div id="licenseDetailsText" style="font-size:11px; color:#94a3b8; line-height:1.2;"></div>
        </div>
        <button id="upgradeBtn"
          style="display:block; padding:6px 12px; font-size:12px; font-weight:600; background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); color: #fff; border: none; border-radius: 12px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);">
          <span id="upgradeBtnText">–ü–æ–ª—É—á–∏—Ç—å Pro</span>
        </button>
      </div>
    </div>

    <button id="applyBtn" class="primary-button" onclick="applyToOriginal()" disabled>Apply to Original</button>
    <button id="copyBtn" class="button-recovery" onclick="createCopy()" disabled>Create Rotated Copy</button>

    <!-- Debug buttons for testing license states -->
    <div style="margin-top: 12px; display: none;" id="debugButtons">
      <div style="display: flex; gap: 4px; margin-bottom: 8px;">
        <button onclick="testLicenseState(5)" class="button-secondary" style="font-size: 10px; padding: 4px 8px;">5
          left</button>
        <button onclick="testLicenseState(2)" class="button-secondary" style="font-size: 10px; padding: 4px 8px;">2
          left</button>
        <button onclick="testLicenseState(0)" class="button-secondary" style="font-size: 10px; padding: 4px 8px;">0
          left</button>
        <button onclick="forceRedBanner()" class="button-secondary"
          style="font-size: 10px; padding: 4px 8px; background: red; color: white;">FORCE RED</button>
        <button onclick="testLicenseState(-1)" class="button-secondary"
          style="font-size: 10px; padding: 4px 8px;">Pro</button>
      </div>
    </div>
  </div>

  <!-- Subscription Info Modal -->
  <div id="subscriptionModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="subModalTitle">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ</h3>
        <button id="subModalClose" class="modal-close">√ó</button>
      </div>
      <div class="modal-body">
        <!-- Subscription Status -->
        <div id="subStatusSection" style="margin-bottom: 20px;">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
            <div class="status-badge pro" id="subStatusBadge">
              <svg class="status-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2L15.09 8.26L22 9L17 14L18.18 21L12 17.77L5.82 21L7 14L2 9L8.91 8.26L12 2Z"
                  fill="currentColor" />
              </svg>
              <span id="subStatusText">PRO</span>
            </div>
            <div style="flex: 1;">
              <div id="subStatusDescription" style="font-weight: 600; color: #374151;">–ê–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞</div>
              <div id="subStatusDetails" style="font-size: 12px; color: #6b7280;">–ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º
              </div>
            </div>
          </div>
        </div>

        <!-- Subscription Details -->
        <div id="subDetailsSection"
          style="background: #f9fafb; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
            <div>
              <div id="subTypeLabel" style="color: #6b7280; margin-bottom: 4px;">–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏</div>
              <div id="subType" style="font-weight: 600; color: #374151;">-</div>
            </div>
            <div>
              <div id="subPurchaseDateLabel" style="color: #6b7280; margin-bottom: 4px;">–î–∞—Ç–∞ –ø–æ–∫—É–ø–∫–∏</div>
              <div id="subPurchaseDate" style="font-weight: 600; color: #374151;">-</div>
            </div>
            <div>
              <div id="subExpiryDateLabel" style="color: #6b7280; margin-bottom: 4px;">–ò—Å—Ç–µ–∫–∞–µ—Ç</div>
              <div id="subExpiryDate" style="font-weight: 600; color: #374151;">-</div>
            </div>
            <div>
              <div id="subDaysLeftLabel" style="color: #6b7280; margin-bottom: 4px;">–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π</div>
              <div id="subDaysLeft" style="font-weight: 600; color: #374151;">-</div>
            </div>
          </div>
        </div>

        <!-- Action buttons based on subscription status -->
        <div id="subActionsSection">
          <!-- For FREE users -->
          <div id="subFreeActions">
            <button id="subUpgradeBtn" class="primary-button" style="margin-bottom: 8px;">
              <span id="subUpgradeBtnText">–ü–æ–ª—É—á–∏—Ç—å PRO</span>
            </button>
            <button id="subRecoverBtn" class="button-recovery" style="margin-bottom: 8px;">
              <span id="subRecoverBtnText">–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É</span>
            </button>
            <div style="margin: 16px 0;">
              <label style="font-size: 12px; color: #6b7280; margin-bottom: 8px; display: block;">–ò–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∫–ª—é—á
                –∞–∫—Ç–∏–≤–∞—Ü–∏–∏:</label>
              <input type="text" id="activationKeyInput" placeholder="MS-..." style="width: 100%; margin-bottom: 8px;">
              <button id="activateKeyBtn" class="button-secondary" style="width: 100%;">–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á</button>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="subModalCancel" class="button-secondary">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
  </div>

  <div class="footer">
    <a href="https://t.me/senseyko666" target="_blank" rel="noopener" class="footer-link" id="footerLink">by Sensey</a>
    <div class="language-switcher" id="languageSwitcher">
      <button type="button" class="language-selected" id="languageSelected"></button>
      <div class="language-dropdown hidden" id="languageDropdown"></div>
    </div>
  </div>
  <script>
    let currentImage = null;
    let rotationAngle = 0;
    let rotationX = 0;
    let rotationY = 0;

    // Rotation clipboard for copy/paste functionality
    let copiedRotation = null;

    // Manual Screen Mode variables
    let manualScreenEnabled = false;
    let selectedMockup = null;
    let selectedScreenArea = null;

    // License management - –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫—Ä–∞—Å–Ω—É—é –ø–ª–∞—à–∫—É (–ª–∏–º–∏—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç)
    let licenseInfo = { usageCount: 10, isPro: false, remainingUses: 0 };

    // State for language and theme
    let state = { language: 'ru' };

    // Translations (copied from –ø—Ä–∏–º–µ—Ä1.html)
    const translations = {
      en: {
        // Interface
        title: 'Image Rotation Studio',
        preview: 'Preview',
        canvas_mode: 'Canvas mode',
        no_image_selected: 'No image selected',
        rotation: 'Rotation',
        z_rotation: 'Z Rotation',
        x_rotation: 'X Rotation',
        y_rotation: 'Y Rotation',
        reset_all: 'Reset All',
        copy_rotation: 'Copy Rotation',
        apply_copied: 'Apply Copied',
        match_target_mode: 'Match Target Mode',
        show_target_overlay: 'Show target overlay for precise matching',
        select_target_object: 'Select Target Object',
        overlay_opacity: 'Overlay Opacity',
        clear_overlay: 'Clear Overlay',
        smart_insert_mode: 'Smart Insert Mode',
        auto_insert_image: 'Auto-insert image into phone screen area',
        select_phone_mockup: 'Select Phone Mockup',
        smart_insert: 'Smart Insert',
        screen_detection: 'Screen Detection',
        clear_phone: 'Clear Phone',
        screen_replace_mode: 'Screen Replace Mode',
        replace_screen_content: 'Replace screen content in phone images',
        select_phone_image: 'Select Phone Image',
        replace_screen: 'Replace Screen',
        screen_shape: 'Screen Shape',
        apply: 'Apply',
        keep_original_size: 'Keep original size',
        apply_to_original: 'Apply to Original',
        create_rotated_copy: 'Create Rotated Copy',
        // License
        license_free_uses: 'Free attempts',
        license_remaining: 'remaining',
        license_unlimited: 'Unlimited',
        license_get_pro: 'Get Pro',
        license_limit_reached: 'Usage limit reached',
        license_limit_message: 'You have used all 10 free attempts. Get Pro version for unlimited access.',
        license_buy_telegram: 'Buy via Telegram',
        license_pro_active: 'Pro Active',
        license_expires_soon: 'Expires soon!',
        license_days_remaining: 'days remaining',
        license_renew: 'Renew',
        license_feature_unlimited: 'Unlimited processing',
        activation_label: 'Already have an activation key?',
        activation_placeholder: 'Enter activation key (CT-...)',
        activation_button: 'Activate',
        get_code_button: 'Get Code (Have Subscription)',
        status_pro_tooltip: 'Pro subscription active. Click for details.',
        subscription_info_title: 'Subscription Information',
        subscription_active: 'Active Subscription',
        subscription_unlimited: 'Unlimited access to all features',
        subscription_free: 'Free Version',
        subscription_limited: 'Limited to 10 uses',
        subscription_manage: 'Manage Subscription',
        subscription_upgrade: 'Get PRO',
        price_monthly: '$2.00 / month',
        price_yearly_note: 'or $19.99 / year (17% savings)',
        subscription_usage_text: 'Used: {used} of 10 free attempts',
        modal_close: 'Close'
      },
      ru: {
        // Interface
        title: 'Image Rotation Studio',
        preview: '–ü—Ä–µ–≤—å—é',
        canvas_mode: '–†–µ–∂–∏–º Canvas',
        no_image_selected: '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ',
        rotation: '–ü–æ–≤–æ—Ä–æ—Ç',
        z_rotation: 'Z –ü–æ–≤–æ—Ä–æ—Ç',
        x_rotation: 'X –ü–æ–≤–æ—Ä–æ—Ç',
        y_rotation: 'Y –ü–æ–≤–æ—Ä–æ—Ç',
        reset_all: '–°–±—Ä–æ—Å–∏—Ç—å –≤—Å—ë',
        copy_rotation: '–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø–æ–≤–æ—Ä–æ—Ç',
        apply_copied: '–ü—Ä–∏–º–µ–Ω–∏—Ç—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π',
        match_target_mode: '–†–µ–∂–∏–º —Å–æ–≤–º–µ—â–µ–Ω–∏—è',
        show_target_overlay: '–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–ª–∏ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Å–æ–≤–º–µ—â–µ–Ω–∏—è',
        select_target_object: '–í—ã–±—Ä–∞—Ç—å —Ü–µ–ª–µ–≤–æ–π –æ–±—ä–µ–∫—Ç',
        overlay_opacity: '–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–∞–ª–æ–∂–µ–Ω–∏—è',
        clear_overlay: '–û—á–∏—Å—Ç–∏—Ç—å –Ω–∞–ª–æ–∂–µ–Ω–∏–µ',
        smart_insert_mode: '–£–º–Ω–∞—è –≤—Å—Ç–∞–≤–∫–∞',
        auto_insert_image: '–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≤—Å—Ç–∞–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ —ç–∫—Ä–∞–Ω —Ç–µ–ª–µ—Ñ–æ–Ω–∞',
        select_phone_mockup: '–í—ã–±—Ä–∞—Ç—å –º–æ–∫–∞–ø —Ç–µ–ª–µ—Ñ–æ–Ω–∞',
        smart_insert: '–£–º–Ω–∞—è –≤—Å—Ç–∞–≤–∫–∞',
        screen_detection: '–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞',
        clear_phone: '–û—á–∏—Å—Ç–∏—Ç—å —Ç–µ–ª–µ—Ñ–æ–Ω',
        screen_replace_mode: '–ó–∞–º–µ–Ω–∞ —ç–∫—Ä–∞–Ω–∞',
        replace_screen_content: '–ó–∞–º–µ–Ω–∏—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —ç–∫—Ä–∞–Ω–∞ –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è—Ö —Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤',
        select_phone_image: '–í—ã–±—Ä–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–ª–µ—Ñ–æ–Ω–∞',
        replace_screen: '–ó–∞–º–µ–Ω–∏—Ç—å —ç–∫—Ä–∞–Ω',
        screen_shape: '–§–æ—Ä–º–∞ —ç–∫—Ä–∞–Ω–∞',
        apply: '–ü—Ä–∏–º–µ–Ω–∏—Ç—å',
        keep_original_size: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π —Ä–∞–∑–º–µ—Ä',
        apply_to_original: '–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—É',
        create_rotated_copy: '–°–æ–∑–¥–∞—Ç—å –ø–æ–≤—ë—Ä–Ω—É—Ç—É—é –∫–æ–ø–∏—é',
        // License
        license_free_uses: '–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏',
        license_remaining: '–æ—Å—Ç–∞–ª–æ—Å—å',
        license_unlimited: '–ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ',
        license_get_pro: '–ü–æ–ª—É—á–∏—Ç—å Pro',
        license_limit_reached: '–õ–∏–º–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç–∏–≥–Ω—É—Ç',
        license_limit_message: '–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ 10 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫. –ü–æ–ª—É—á–∏—Ç–µ Pro –≤–µ—Ä—Å–∏—é –¥–ª—è –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞.',
        license_buy_telegram: '–ö—É–ø–∏—Ç—å —á–µ—Ä–µ–∑ Telegram',
        license_pro_active: 'Pro –∞–∫—Ç–∏–≤–Ω–∞',
        license_expires_soon: '–°–∫–æ—Ä–æ –∏—Å—Ç–µ–∫–∞–µ—Ç!',
        license_days_remaining: '–¥–Ω–µ–π –æ—Å—Ç–∞–ª–æ—Å—å',
        license_renew: '–ü—Ä–æ–¥–ª–∏—Ç—å',
        license_feature_unlimited: '–ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–±–æ—Ç–æ–∫',
        activation_label: '–£–∂–µ –µ—Å—Ç—å –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏?',
        activation_placeholder: '–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (CT-...)',
        activation_button: '–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å',
        get_code_button: '–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥ (–µ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∞)',
        status_pro_tooltip: 'Pro –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ù–∞–∂–º–∏—Ç–µ –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π.',
        subscription_info_title: '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ',
        subscription_active: '–ê–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞',
        subscription_unlimited: '–ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º',
        subscription_free: '–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≤–µ—Ä—Å–∏—è',
        subscription_limited: '–û–≥—Ä–∞–Ω–∏—á–µ–Ω–æ 10 –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è–º–∏',
        subscription_manage: '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–æ–π',
        subscription_upgrade: '–ü–æ–ª—É—á–∏—Ç—å PRO',
        price_monthly: '$2.00 / –º–µ—Å—è—Ü',
        price_yearly_note: '–∏–ª–∏ $19.99 / –≥–æ–¥ (—ç–∫–æ–Ω–æ–º–∏—è 17%)',
        subscription_usage_text: '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: {used} –∏–∑ 10 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫',
        modal_close: '–ó–∞–∫—Ä—ã—Ç—å'
      },
      uk: {
        // Interface
        title: 'Image Rotation Studio',
        preview: '–ü–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –ø–µ—Ä–µ–≥–ª—è–¥',
        canvas_mode: '–†–µ–∂–∏–º Canvas',
        no_image_selected: '–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –Ω–µ –≤–∏–±—Ä–∞–Ω–æ',
        rotation: '–ü–æ–≤–æ—Ä–æ—Ç',
        z_rotation: 'Z –ü–æ–≤–æ—Ä–æ—Ç',
        x_rotation: 'X –ü–æ–≤–æ—Ä–æ—Ç',
        y_rotation: 'Y –ü–æ–≤–æ—Ä–æ—Ç',
        reset_all: '–°–∫–∏–Ω—É—Ç–∏ –≤—Å–µ',
        copy_rotation: '–ö–æ–ø—ñ—é–≤–∞—Ç–∏ –ø–æ–≤–æ—Ä–æ—Ç',
        apply_copied: '–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–∏–π',
        match_target_mode: '–†–µ–∂–∏–º —Å—É–º—ñ—â–µ–Ω–Ω—è',
        show_target_overlay: '–ü–æ–∫–∞–∑–∞—Ç–∏ –Ω–∞–∫–ª–∞–¥–µ–Ω–Ω—è —Ü—ñ–ª—ñ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Å—É–º—ñ—â–µ–Ω–Ω—è',
        select_target_object: '–í–∏–±—Ä–∞—Ç–∏ —Ü—ñ–ª—å–æ–≤–∏–π –æ–±\'—î–∫—Ç',
        overlay_opacity: '–ü—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å –Ω–∞–∫–ª–∞–¥–µ–Ω–Ω—è',
        clear_overlay: '–û—á–∏—Å—Ç–∏—Ç–∏ –Ω–∞–∫–ª–∞–¥–µ–Ω–Ω—è',
        smart_insert_mode: '–†–æ–∑—É–º–Ω–∞ –≤—Å—Ç–∞–≤–∫–∞',
        auto_insert_image: '–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –≤—Å—Ç–∞–≤–∫–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –≤ –µ–∫—Ä–∞–Ω —Ç–µ–ª–µ—Ñ–æ–Ω—É',
        select_phone_mockup: '–í–∏–±—Ä–∞—Ç–∏ –º–æ–∫–∞–ø —Ç–µ–ª–µ—Ñ–æ–Ω—É',
        smart_insert: '–†–æ–∑—É–º–Ω–∞ –≤—Å—Ç–∞–≤–∫–∞',
        screen_detection: '–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è –µ–∫—Ä–∞–Ω—É',
        clear_phone: '–û—á–∏—Å—Ç–∏—Ç–∏ —Ç–µ–ª–µ—Ñ–æ–Ω',
        screen_replace_mode: '–ó–∞–º—ñ–Ω–∞ –µ–∫—Ä–∞–Ω—É',
        replace_screen_content: '–ó–∞–º—ñ–Ω–∏—Ç–∏ –≤–º—ñ—Å—Ç –µ–∫—Ä–∞–Ω—É –≤ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è—Ö —Ç–µ–ª–µ—Ñ–æ–Ω—ñ–≤',
        select_phone_image: '–í–∏–±—Ä–∞—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Ç–µ–ª–µ—Ñ–æ–Ω—É',
        replace_screen: '–ó–∞–º—ñ–Ω–∏—Ç–∏ –µ–∫—Ä–∞–Ω',
        screen_shape: '–§–æ—Ä–º–∞ –µ–∫—Ä–∞–Ω—É',
        apply: '–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏',
        keep_original_size: '–ó–±–µ—Ä–µ–≥—Ç–∏ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π —Ä–æ–∑–º—ñ—Ä',
        apply_to_original: '–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –¥–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—É',
        create_rotated_copy: '–°—Ç–≤–æ—Ä–∏—Ç–∏ –ø–æ–≤–µ—Ä–Ω—É—Ç—É –∫–æ–ø—ñ—é',
        // License
        license_free_uses: '–ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω—ñ —Å–ø—Ä–æ–±–∏',
        license_remaining: '–∑–∞–ª–∏—à–∏–ª–æ—Å—å',
        license_unlimited: '–ë–µ–∑–ª—ñ–º—ñ—Ç–Ω–æ',
        license_get_pro: '–û—Ç—Ä–∏–º–∞—Ç–∏ Pro',
        license_limit_reached: '–õ—ñ–º—ñ—Ç –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—å –¥–æ—Å—è–≥–Ω—É—Ç–æ',
        license_limit_message: '–í–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–ª–∏ –≤—Å—ñ 5 –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏—Ö —Å–ø—Ä–æ–±. –û—Ç—Ä–∏–º–∞–π—Ç–µ Pro –≤–µ—Ä—Å—ñ—é –¥–ª—è –Ω–µ–æ–±–º–µ–∂–µ–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø—É.',
        license_buy_telegram: '–ö—É–ø–∏—Ç–∏ —á–µ—Ä–µ–∑ Telegram',
        license_pro_active: 'Pro –∞–∫—Ç–∏–≤–Ω–∞',
        license_expires_soon: '–°–∫–æ—Ä–æ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è!',
        license_days_remaining: '–¥–Ω—ñ–≤ –∑–∞–ª–∏—à–∏–ª–æ—Å—å',
        license_renew: '–ü–æ–Ω–æ–≤–∏—Ç–∏',
        license_feature_unlimited: '–ù–µ–æ–±–º–µ–∂–µ–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–±—Ä–æ–±–æ–∫',
        activation_label: '–í–∂–µ —î –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó?',
        activation_placeholder: '–í–≤–µ–¥—ñ—Ç—å –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó (CT-...)',
        activation_button: '–ê–∫—Ç–∏–≤—É–≤–∞—Ç–∏',
        get_code_button: '–û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–¥ (—î –ø—ñ–¥–ø–∏—Å–∫–∞)',
        status_pro_tooltip: 'Pro –ø—ñ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –¥–ª—è –¥–µ—Ç–∞–ª–µ–π.',
        subscription_info_title: '–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –ø—ñ–¥–ø–∏—Å–∫—É',
        subscription_active: '–ê–∫—Ç–∏–≤–Ω–∞ –ø—ñ–¥–ø–∏—Å–∫–∞',
        subscription_unlimited: '–ù–µ–æ–±–º–µ–∂–µ–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ –≤—Å—ñ—Ö —Ñ—É–Ω–∫—Ü—ñ–π',
        subscription_free: '–ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∞ –≤–µ—Ä—Å—ñ—è',
        subscription_limited: '–û–±–º–µ–∂–µ–Ω–æ 5 –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º–∏',
        subscription_manage: '–£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø—ñ–¥–ø–∏—Å–∫–æ—é',
        subscription_upgrade: '–û—Ç—Ä–∏–º–∞—Ç–∏ PRO',
        price_monthly: '$2.00 / –º—ñ—Å—è—Ü—å',
        price_yearly_note: '–∞–±–æ $19.99 / —Ä—ñ–∫ (–µ–∫–æ–Ω–æ–º—ñ—è 17%)',
        subscription_usage_text: '–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ: {used} –∑ 5 –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏—Ö —Å–ø—Ä–æ–±',
        modal_close: '–ó–∞–∫—Ä–∏—Ç–∏'
      },
      kk: {
        license_limit_reached: '–ü–∞–π–¥–∞–ª–∞–Ω—É —à–µ–≥—ñ –∂–µ—Ç—Ç—ñ',
        license_limit_message: '–°—ñ–∑ –±–∞—Ä–ª—ã“õ 5 —Ç–µ–≥—ñ–Ω ”ô—Ä–µ–∫–µ—Ç—Ç—ñ –ø–∞–π–¥–∞–ª–∞–Ω–¥—ã“£—ã–∑. –®–µ–∫—Å—ñ–∑ “õ–æ–ª –∂–µ—Ç–∫—ñ–∑—É “Ø—à—ñ–Ω Pro –Ω“±—Å“õ–∞—Å—ã–Ω –∞–ª—ã“£—ã–∑.',
        license_buy_telegram: 'Telegram –∞—Ä“õ—ã–ª—ã —Å–∞—Ç—ã–ø –∞–ª—É',
        license_pro_active: 'Pro –±–µ–ª—Å–µ–Ω–¥—ñ',
        license_feature_unlimited: '–®–µ–∫—Å—ñ–∑ ”©“£–¥–µ—É',
        get_code_button: '–ö–æ–¥ –∞–ª—É (–∂–∞–∑—ã–ª—ã–º –±–∞—Ä)',
        price_monthly: '$2.00 / –∞–π',
        price_yearly_note: '–Ω–µ–º–µ—Å–µ $19.99 / –∂—ã–ª (17% “Ø–Ω–µ–º–¥–µ—É)',
        modal_close: '–ñ–∞–±—É'
      },
      ko: {
        license_limit_reached: 'ÏÇ¨Ïö© ÌïúÎèÑ ÎèÑÎã¨',
        license_limit_message: '5Î≤àÏùò Î¨¥Î£å ÏãúÎèÑÎ•º Î™®Îëê ÏÇ¨Ïö©ÌñàÏäµÎãàÎã§. Î¨¥Ï†úÌïú Ïï°ÏÑ∏Ïä§Î•º ÏúÑÌï¥ Pro Î≤ÑÏ†ÑÏùÑ Íµ¨Îß§ÌïòÏÑ∏Ïöî.',
        license_buy_telegram: 'TelegramÏúºÎ°ú Íµ¨Îß§',
        license_pro_active: 'Pro ÌôúÏÑ±',
        license_feature_unlimited: 'Î¨¥Ï†úÌïú Ï≤òÎ¶¨',
        get_code_button: 'ÏΩîÎìú Î∞õÍ∏∞ (Íµ¨ÎèÖ ÏûàÏùå)',
        price_monthly: '$2.00 / Ïõî',
        price_yearly_note: 'ÎòêÎäî $19.99 / ÎÖÑ (17% Ï†àÏïΩ)',
        modal_close: 'Îã´Í∏∞'
      },
      es: {
        license_limit_reached: 'L√≠mite de uso alcanzado',
        license_limit_message: 'Has usado todos los 5 intentos gratuitos. Obt√©n la versi√≥n Pro para acceso ilimitado.',
        license_buy_telegram: 'Comprar v√≠a Telegram',
        license_pro_active: 'Pro Activo',
        license_feature_unlimited: 'Procesamiento ilimitado',
        get_code_button: 'Obtener c√≥digo (tengo suscripci√≥n)',
        price_monthly: '$2.00 / mes',
        price_yearly_note: 'o $19.99 / a√±o (17% de ahorro)',
        modal_close: 'Cerrar'
      },
      de: {
        license_limit_reached: 'Nutzungslimit erreicht',
        license_limit_message: 'Sie haben alle 5 kostenlosen Versuche verwendet. Holen Sie sich die Pro-Version f√ºr unbegrenzten Zugang.',
        license_buy_telegram: '√úber Telegram kaufen',
        license_pro_active: 'Pro Aktiv',
        license_feature_unlimited: 'Unbegrenzte Verarbeitung',
        get_code_button: 'Code erhalten (habe Abonnement)',
        price_monthly: '$2.00 / Monat',
        price_yearly_note: 'oder $19.99 / Jahr (17% Ersparnis)',
        modal_close: 'Schlie√üen'
      },
      ja: {
        license_limit_reached: '‰ΩøÁî®Âà∂Èôê„Å´ÈÅî„Åó„Åæ„Åó„Åü',
        license_limit_message: '5Âõû„ÅÆÁÑ°ÊñôË©¶Ë°å„Çí„Åô„Åπ„Å¶‰ΩøÁî®„Åó„Åæ„Åó„Åü„ÄÇÁÑ°Âà∂Èôê„Ç¢„ÇØ„Çª„Çπ„ÅÆ„Åü„ÇÅ„Å´ProÁâà„ÇíÂèñÂæó„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        license_buy_telegram: 'Telegram„ÅßË≥ºÂÖ•',
        license_pro_active: 'Pro „Ç¢„ÇØ„ÉÜ„Ç£„Éñ',
        license_feature_unlimited: 'ÁÑ°Âà∂ÈôêÂá¶ÁêÜ',
        get_code_button: '„Ç≥„Éº„Éâ„ÇíÂèñÂæóÔºà„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÅÇ„ÇäÔºâ',
        price_monthly: '$2.00 / Êúà',
        price_yearly_note: '„Åæ„Åü„ÅØ $19.99 / Âπ¥ (17% ÁØÄÁ¥Ñ)',
        modal_close: 'Èñâ„Åò„Çã'
      }
    };

    let currentLanguage = 'ru';

    // Language persistence functions
    function saveLanguage(code) {
      try {
        localStorage.setItem('image-rotation-studio-language', code);
      } catch (e) {
        console.warn('Could not save language preference:', e);
      }
    }

    function loadSavedLanguage() {
      try {
        const saved = localStorage.getItem('image-rotation-studio-language');
        if (saved && languages.find(l => l.code === saved)) {
          return saved;
        }
      } catch (e) {
        console.warn('Could not load language preference:', e);
      }

      // Fallback to browser language
      const browserLang = navigator.language || navigator.userLanguage;
      const langCode = browserLang.split('-')[0].toLowerCase();

      // Check if we support this language
      if (languages.find(l => l.code === langCode)) {
        return langCode;
      }

      // Default to Russian
      return 'ru';
    }

    // Languages (copied from –ø—Ä–∏–º–µ—Ä1.html)
    const languages = [
      { code: 'en', name: 'English', flag: 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"%3E%3Crect width="40" height="40" fill="%23012169"/%3E%3Cpath d="M0 0l40 40M40 0L0 40" stroke="%23fff" stroke-width="4"/%3E%3Cpath d="M0 0l40 40M40 0L0 40" stroke="%23c8102e" stroke-width="2"/%3E%3Cpath d="M20 0v40M0 20h40" stroke="%23fff" stroke-width="6"/%3E%3Cpath d="M20 0v40M0 20h40" stroke="%23c8102e" stroke-width="4"/%3E%3C/svg%3E' },
      { code: 'ru', name: '–†—É—Å—Å–∫–∏–π', flag: createFlag(['#ffffff', '#0039a6', '#d52b1e']) },
      { code: 'uk', name: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞', flag: createFlag(['#0057b8', '#ffd700']) },
      { code: 'kk', name: '“ö–∞–∑–∞“õ', flag: createFlag(['#00afca', '#f8d64e', '#00afca']) },
      { code: 'ko', name: 'ÌïúÍµ≠Ïñ¥', flag: createFlag(['#ffffff', '#ffffff', '#ffffff']) },
      { code: 'es', name: 'Espa√±ol', flag: createFlag(['#aa151b', '#f1bf00', '#aa151b']) },
      { code: 'de', name: 'Deutsch', flag: createFlag(['#000000', '#dd0000', '#ffce00']) },
      { code: 'ja', name: 'Êó•Êú¨Ë™û', flag: createFlag(['#ffffff', '#ffffff', '#ffffff']) }
    ];

    function createFlag(stripes) {
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'>${stripes.map((c, i) => `<rect x='0' y='${i * (40 / stripes.length)}' width='40' height='${40 / stripes.length}' fill='${c}' />`).join('')}</svg>`;
      return `data:image/svg+xml,${encodeURIComponent(svg)}`;
    }

    function renderFlag(container, lang) {
      container.textContent = '';
      const img = document.createElement('img');
      img.alt = lang.name;

      if (lang.code === 'ja') {
        const s = `<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'><rect width='40' height='40' fill='#ffffff'/><circle cx='20' cy='20' r='10' fill='#bc002d'/></svg>`;
        img.src = `data:image/svg+xml,${encodeURIComponent(s)}`;
      } else if (lang.code === 'ko') {
        const s = `<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'>
      <defs><clipPath id='cp'><circle cx='20' cy='20' r='10'/></clipPath></defs>
      <rect width='40' height='40' fill='#ffffff'/>
      <rect x='10' y='10' width='20' height='10' fill='#CD2E3A' clip-path='url(#cp)'/>
      <rect x='10' y='20' width='20' height='10' fill='#0047A0' clip-path='url(#cp)'/>
    </svg>`;
        img.src = `data:image/svg+xml,${encodeURIComponent(s)}`;
      } else if (lang.code === 'en') {
        // Use the pre-encoded Union Jack flag
        img.src = lang.flag;
      } else {
        img.src = lang.flag;
      }

      container.appendChild(img);
    }

    function setLanguage(code) {
      currentLanguage = code;
      saveLanguage(code);
      renderLanguageSwitcher();
      updateAllTexts();
      updateLicenseUI();
      updateModalTexts();
    }

    function updateAllTexts() {
      const pack = translations[currentLanguage] || translations.en;

      // Update interface texts (title stays in English)
      // const titleElement = document.querySelector('.title-rainbow');
      // if (titleElement) titleElement.textContent = 'Image Rotation Studio';

      const previewTitle = document.querySelector('.card .group-title');
      if (previewTitle && previewTitle.textContent.includes('Preview')) {
        previewTitle.innerHTML = `${pack.preview || 'Preview'} 
      <label style="float:right; font-size:10px; font-weight:normal;">
        <input type="checkbox" id="useCanvasPreview"> ${pack.canvas_mode || 'Canvas mode'}
      </label>`;
      }

      const noImageText = document.getElementById('previewContent');
      if (noImageText && noImageText.textContent.includes('No image selected')) {
        noImageText.textContent = pack.no_image_selected || 'No image selected';
      }

      // Update rotation section
      const rotationTitles = document.querySelectorAll('.group-title');
      rotationTitles.forEach(title => {
        if (title.textContent === 'Rotation') title.textContent = pack.rotation || 'Rotation';
        if (title.textContent === 'Apply') title.textContent = pack.apply || 'Apply';
      });

      // Update buttons
      const applyBtn = document.getElementById('applyBtn');
      if (applyBtn) applyBtn.textContent = pack.apply_to_original || 'Apply to Original';

      const copyBtn = document.getElementById('copyBtn');
      if (copyBtn) copyBtn.textContent = pack.create_rotated_copy || 'Create Rotated Copy';

      // Update checkbox label
      const keepSizeLabel = document.querySelector('label[style*="display:flex"]');
      if (keepSizeLabel) {
        const checkbox = keepSizeLabel.querySelector('input[type="checkbox"]');
        keepSizeLabel.innerHTML = '';
        keepSizeLabel.appendChild(checkbox);
        keepSizeLabel.appendChild(document.createTextNode(pack.keep_original_size || 'Keep original size'));
      }

      // Update Match Target Mode elements
      const matchTargetTitles = document.querySelectorAll('.group-title');
      matchTargetTitles.forEach(title => {
        if (title.textContent === 'Match Target Mode') title.textContent = pack.match_target_mode || 'Match Target Mode';
      });

      // Update Match Target Mode labels and buttons
      const targetOverlayLabel = document.querySelector('label[style*="font-size:12px"]');
      if (targetOverlayLabel && targetOverlayLabel.textContent.includes('Show target overlay')) {
        const checkbox = targetOverlayLabel.querySelector('input[type="checkbox"]');
        targetOverlayLabel.innerHTML = '';
        targetOverlayLabel.appendChild(checkbox);
        targetOverlayLabel.appendChild(document.createTextNode(pack.show_target_overlay || 'Show target overlay for precise matching'));
      }

      const selectTargetBtn = document.getElementById('selectTargetBtn');
      if (selectTargetBtn) selectTargetBtn.textContent = 'üéØ ' + (pack.select_target_object || 'Select Target Object');
    }

    function updateLicenseUI() {
      const pack = translations[currentLanguage] || translations.en;
      const statusBadge = document.getElementById('statusBadge');
      const statusText = document.getElementById('statusText');
      const licenseInfo_el = document.getElementById('licenseInfo');
      const upgradeBtn = document.getElementById('upgradeBtn');
      const upgradeBtnText = document.getElementById('upgradeBtnText');
      const licenseStatusText = document.getElementById('licenseStatusText');
      const licenseDetailsText = document.getElementById('licenseDetailsText');


      if (!statusBadge || !statusText) return;

      // Update status badge
      statusBadge.classList.remove('pro', 'free', 'warning');

      if (licenseInfo.isPro) {
        // Hide license info for Pro users
        if (licenseInfo_el) licenseInfo_el.style.display = 'none';

        if (licenseInfo.expiryWarning && licenseInfo.daysUntilExpiry !== undefined) {
          statusBadge.classList.add('warning');
          statusText.textContent = 'PRO';
          statusBadge.title = `Pro subscription expires in ${licenseInfo.daysUntilExpiry} days. Click to manage.`;
        } else {
          statusBadge.classList.add('pro');
          statusText.textContent = 'PRO';
          statusBadge.title = pack.status_pro_tooltip || 'Pro subscription active. Click for details.';
        }
      } else {
        statusBadge.classList.add('free');
        statusText.textContent = 'FREE';
        const remaining = licenseInfo.remainingUses !== undefined ? licenseInfo.remainingUses : 10;
        const used = 10 - remaining;
        console.log('License info:', licenseInfo, 'remaining:', remaining, 'used:', used);
        statusBadge.title = `${remaining} free uses remaining. Click to upgrade.`;

        // Show and update license info card
        if (licenseInfo_el) {
          licenseInfo_el.style.display = 'block';

          if (remaining <= 0) {
            licenseInfo_el.className = '';
            licenseInfo_el.classList.add('danger');
            if (licenseStatusText) licenseStatusText.textContent = pack.license_limit_reached || '–õ–∏–º–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç–∏–≥–Ω—É—Ç';
            if (licenseDetailsText) licenseDetailsText.textContent = pack.license_limit_message || '–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ 10 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫. –ü–æ–ª—É—á–∏—Ç–µ Pro –≤–µ—Ä—Å–∏—é –¥–ª—è –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞.';
            if (upgradeBtn) {
              upgradeBtn.style.display = 'block';
              if (upgradeBtnText) upgradeBtnText.textContent = pack.license_get_pro || '–ü–æ–ª—É—á–∏—Ç—å Pro';
            }
          } else {
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–∏–Ω—é—é –ø–ª–∞—à–∫—É: "10 –æ—Å—Ç–∞–ª–æ—Å—å" –∏ "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏ (0/10)"
            licenseInfo_el.className = '';
            licenseInfo_el.classList.add('normal');
            if (licenseStatusText) licenseStatusText.textContent = `${remaining} ${pack.license_remaining || '–æ—Å—Ç–∞–ª–æ—Å—å'}`;
            if (licenseDetailsText) licenseDetailsText.textContent = `${pack.license_free_uses || '–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏'} (${used}/10)`;
            if (upgradeBtn) upgradeBtn.style.display = 'none'; // –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
          }
        }
      }
    }

    function updateModalTexts() {
      const pack = translations[currentLanguage] || translations.en;

      // Update modal texts
      const modalTitle = document.getElementById('modalTitle');
      const modalMessage = document.getElementById('modalMessage');
      const modalFeature = document.getElementById('modalFeature');
      const buyProBtn = document.getElementById('buyProBtn');
      const getCodeBtnText = document.getElementById('getCodeBtnText');
      const modalCancel = document.getElementById('modalCancel');
      const modalPrice = document.getElementById('modalPrice');
      const modalPriceNote = document.getElementById('modalPriceNote');

      if (modalTitle) modalTitle.textContent = pack.license_limit_reached || 'Usage limit reached';
      if (modalMessage) modalMessage.textContent = pack.license_limit_message || 'You have used all 10 free attempts. Get Pro version for unlimited access.';
      if (modalFeature) modalFeature.textContent = '‚ú® ' + (pack.license_feature_unlimited || 'Unlimited processing');
      if (buyProBtn) buyProBtn.textContent = pack.license_buy_telegram || 'Buy via Telegram';
      if (getCodeBtnText) getCodeBtnText.textContent = pack.get_code_button || 'Get Code (Have Subscription)';
      if (modalCancel) modalCancel.textContent = pack.modal_close || 'Cancel';
      if (modalPrice) modalPrice.textContent = pack.price_monthly || '$2.00 / month';
      if (modalPriceNote) modalPriceNote.textContent = pack.price_yearly_note || 'or $19.99 / year (17% savings)';
    }

    function renderLanguageSwitcher() {
      const selBtn = document.getElementById('languageSelected');
      const dd = document.getElementById('languageDropdown');

      if (!selBtn || !dd) return;

      const current = languages.find(l => l.code === currentLanguage) || languages[0];

      // Clear and rebuild button content like in example
      selBtn.textContent = '';
      const flag = document.createElement('span');
      flag.className = 'language-flag';
      renderFlag(flag, current);
      const name = document.createElement('span');
      name.className = 'language-name';
      name.textContent = current.name;
      selBtn.appendChild(flag);
      selBtn.appendChild(name);

      // Clear and rebuild dropdown
      dd.textContent = '';
      languages.filter(l => l.code !== currentLanguage).forEach(lang => {
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'language-option';
        b.dataset.code = lang.code;

        const f = document.createElement('span');
        f.className = 'language-flag';
        renderFlag(f, lang);
        const n = document.createElement('span');
        n.className = 'language-name';
        n.textContent = lang.name;

        b.appendChild(f);
        b.appendChild(n);
        b.addEventListener('click', () => {
          setLanguage(lang.code);
          toggleLanguageDropdown(false);
        });

        dd.appendChild(b);
      });
    }

    let langOpen = false;
    function toggleLanguageDropdown(force) {
      const dd = document.getElementById('languageDropdown');
      if (!dd) return;

      langOpen = (typeof force === 'boolean') ? force : !langOpen;
      if (langOpen) {
        dd.classList.remove('hidden');
      } else {
        dd.classList.add('hidden');
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π –≤ canvas (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
    function applyTransforms(ctx, radX, radY, radZ) {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –ª–æ–≥–∏–∫—É —á—Ç–æ –∏ –≤ exportUsingCanvas –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
      
      // –°–æ–∑–¥–∞–µ–º –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
      let transformMatrix = [1, 0, 0, 1, 0, 0]; // identity matrix

      // 1. Z –ø–æ–≤–æ—Ä–æ—Ç (–æ–±—ã—á–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏) - –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
      if (rotationAngle !== 0) {
        const cosZ = Math.cos(radZ);
        const sinZ = Math.sin(radZ);
        transformMatrix = multiplyMatrix(transformMatrix, [cosZ, -sinZ, sinZ, cosZ, 0, 0]);
      }

      // 2. Y –ø–æ–≤–æ—Ä–æ—Ç (–ø–æ–≤–æ—Ä–æ—Ç –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ) - –≤—ã—Ä–∞–∂–µ–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
      if (rotationY !== 0) {
        const cosY = Math.cos(radY);
        const sinY = Math.sin(radY);
        const scaleX = Math.abs(cosY);
        const skewY = sinY * 0.7; // –¢–æ—Ç –∂–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —á—Ç–æ –≤ —ç–∫—Å–ø–æ—Ä—Ç–µ
        transformMatrix = multiplyMatrix(transformMatrix, [scaleX, 0, skewY, 1, 0, 0]);
      }

      // 3. X –ø–æ–≤–æ—Ä–æ—Ç (–Ω–∞–∫–ª–æ–Ω –≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑) - –≤—ã—Ä–∞–∂–µ–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç  
      if (rotationX !== 0) {
        const cosX = Math.cos(radX);
        const sinX = Math.sin(radX);
        const scaleY = Math.abs(cosX);
        const skewX = sinX * 0.7; // –¢–æ—Ç –∂–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —á—Ç–æ –≤ —ç–∫—Å–ø–æ—Ä—Ç–µ
        transformMatrix = multiplyMatrix(transformMatrix, [1, skewX, 0, scaleY, 0, 0]);
      }

      // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏—Ç–æ–≥–æ–≤—É—é –º–∞—Ç—Ä–∏—Ü—É —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
      ctx.transform(transformMatrix[0], transformMatrix[1], transformMatrix[2], transformMatrix[3], transformMatrix[4], transformMatrix[5]);
    }

    // Theme system
    function initTheme() {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const html = document.documentElement;
      html.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
      document.querySelector('.theme-toggle').textContent = prefersDark ? '‚òÄÔ∏è' : 'üåô';
    }

    function toggleTheme() {
      const html = document.documentElement;
      const isDark = html.getAttribute('data-theme') === 'dark';
      html.setAttribute('data-theme', isDark ? 'light' : 'dark');
      document.querySelector('.theme-toggle').textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
    }

    // Update rotation
    function updateRotation(value) {
      rotationAngle = parseInt(value);
      document.getElementById('rotationValue').textContent = rotationAngle + '¬∞';
      document.getElementById('rotationInput').value = rotationAngle;
      updatePreview();
    }

    function setRotation(angle) {
      rotationAngle = angle;
      document.getElementById('rotationSlider').value = angle;
      document.getElementById('rotationInput').value = angle;
      document.getElementById('rotationValue').textContent = angle + '¬∞';
      updatePreview();
    }

    function updateRotationX(value) {
      rotationX = parseInt(value);
      document.getElementById('rotationXValue').textContent = rotationX + '¬∞';
      document.getElementById('rotationXInput').value = rotationX;
      updatePreview();
    }

    function updateRotationY(value) {
      rotationY = parseInt(value);
      document.getElementById('rotationYValue').textContent = rotationY + '¬∞';
      document.getElementById('rotationYInput').value = rotationY;
      updatePreview();
    }

    function resetAllRotations() {
      rotationAngle = 0;
      rotationX = 0;
      rotationY = 0;
      document.getElementById('rotationSlider').value = 0;
      document.getElementById('rotationXSlider').value = 0;
      document.getElementById('rotationYSlider').value = 0;
      document.getElementById('rotationInput').value = 0;
      document.getElementById('rotationXInput').value = 0;
      document.getElementById('rotationYInput').value = 0;
      document.getElementById('rotationValue').textContent = '0¬∞';
      document.getElementById('rotationXValue').textContent = '0¬∞';
      document.getElementById('rotationYValue').textContent = '0¬∞';
      updatePreview();
    }

    // Main preview update function
    function updatePreview() {
      const previewContent = document.getElementById('previewContent');
      const useCanvas = document.getElementById('useCanvasPreview').checked;

      // Special handling for fullscreen mode
      if (document.body.classList.contains('fs')) {
        updateFullscreenPreview();
        return;
      }

      // Check if Manual Screen Mode should take over the preview
      if (manualScreenEnabled && selectedMockup && selectedScreenArea && currentImage) {
        updateManualScreenPreview();
        return;
      }

      if (currentImage) {
        if (useCanvas) {
          // Canvas preview
          const previewCanvas = document.createElement('canvas');
          const previewCtx = previewCanvas.getContext('2d');

          const previewSize = 180;
          previewCanvas.width = previewSize;
          previewCanvas.height = previewSize;
          previewCanvas.style.cssText = `
            max-width: 100%; 
            max-height: 100%; 
            border-radius: 8px;
          `;

          previewCtx.clearRect(0, 0, previewSize, previewSize);

          const scale = Math.min(previewSize * 0.8 / currentImage.width, previewSize * 0.8 / currentImage.height);
          const scaledWidth = currentImage.width * scale;
          const scaledHeight = currentImage.height * scale;

          previewCtx.save();
          previewCtx.translate(previewSize / 2, previewSize / 2);

          const radZ = (rotationAngle * Math.PI) / 180;
          const radX = (rotationX * Math.PI) / 180;
          const radY = (rotationY * Math.PI) / 180;

          applyTransforms(previewCtx, radX, radY, radZ);

          if (rotationX !== 0 || rotationY !== 0) {
            const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;
            previewCtx.shadowColor = `rgba(0,0,0,${0.3 * shadowIntensity})`;
            previewCtx.shadowBlur = 5 + shadowIntensity * 5;
            previewCtx.shadowOffsetX = Math.sin((rotationY * Math.PI) / 180) * 5;
            previewCtx.shadowOffsetY = Math.sin((rotationX * Math.PI) / 180) * 5;
          }

          previewCtx.drawImage(currentImage, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
          previewCtx.restore();

          previewContent.innerHTML = '';
          previewContent.appendChild(previewCanvas);
        } else {
          // CSS 3D preview
          const container = document.createElement('div');
          container.style.cssText = `
            width: 100%; 
            height: 100%; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            perspective: 800px;
          `;

          const img = document.createElement('img');
          img.src = currentImage.src;

          const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;

          img.style.cssText = `
            max-width: 90%; 
            max-height: 90%; 
            transform: rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationAngle}deg);
            transition: transform 0.2s ease;
            filter: drop-shadow(${Math.sin((rotationY * Math.PI) / 180) * 10}px ${Math.sin((rotationX * Math.PI) / 180) * 10}px ${10 + shadowIntensity * 10}px rgba(0,0,0,${0.3 * shadowIntensity}));
            transform-style: preserve-3d;
          `;

          container.appendChild(img);
          previewContent.innerHTML = '';
          previewContent.appendChild(container);
        }
      } else {
        previewContent.innerHTML = '<div style="color:#666; text-align:center; padding:40px;">No image selected</div>';
      }

      updateOverlayScale();
    }

    // Update fullscreen preview
    function updateFullscreenPreview() {
      const previewContent = document.getElementById('previewContent');
      if (!previewContent) return;

      // Check if Manual Screen Mode should take over the fullscreen preview
      if (manualScreenEnabled && selectedMockup && selectedScreenArea && currentImage) {
        updateManualScreenPreview();
        return;
      }

      // Regular fullscreen preview for non-manual mode
      if (currentImage) {
        const container = document.createElement('div');
        container.style.cssText = `
          width: 100%; 
          height: 100%; 
          display: flex; 
          align-items: center; 
          justify-content: center;
          perspective: 1200px;
          background: #2a2a2a;
        `;

        const img = document.createElement('img');
        img.src = currentImage.src;

        const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;

        img.style.cssText = `
          max-width: 70%; 
          max-height: 70%; 
          transform: rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationAngle}deg);
          transition: transform 0.2s ease;
          filter: drop-shadow(${Math.sin((rotationY * Math.PI) / 180) * 15}px ${Math.sin((rotationX * Math.PI) / 180) * 15}px ${15 + shadowIntensity * 15}px rgba(0,0,0,${0.4 * shadowIntensity}));
          transform-style: preserve-3d;
          border-radius: 8px;
        `;

        container.appendChild(img);
        previewContent.innerHTML = '';
        previewContent.appendChild(container);
      } else {
        previewContent.innerHTML = '<div style="color:#888; text-align:center; padding:60px; font-size:18px;">üì± Select an image to rotate</div>';
      }
    }

    // Update Manual Screen preview to show how image will look in selected area
    function updateManualScreenPreview() {
      if (!manualScreenEnabled || !selectedMockup || !selectedScreenArea || !currentImage) {
        return;
      }

      const previewContent = document.getElementById('previewContent');
      if (!previewContent) return;

      // Create Manual Screen preview container
      const manualPreview = document.createElement('div');
      manualPreview.className = 'manual-screen-preview';
      manualPreview.style.cssText = `
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: ${document.body.classList.contains('fs') ? '#2a2a2a' : '#f8f9fa'};
        border-radius: 8px;
        border: 2px solid #10b981;
      `;

      // Calculate preview scale
      const previewContainer = document.getElementById('imagePreview');
      const containerWidth = previewContainer.offsetWidth * 0.9;
      const containerHeight = previewContainer.offsetHeight * 0.9;

      // Use screen area dimensions for preview scale
      const previewScale = Math.min(
        containerWidth / selectedScreenArea.width,
        containerHeight / selectedScreenArea.height
      ) * (document.body.classList.contains('fs') ? 0.6 : 0.8);

      // Create screen area representation
      const screenAreaDiv = document.createElement('div');
      screenAreaDiv.style.cssText = `
        position: relative;
        width: ${selectedScreenArea.width * previewScale}px;
        height: ${selectedScreenArea.height * previewScale}px;
        border: 2px dashed #10b981;
        background: rgba(16, 185, 129, 0.1);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      `;

      // Add content image with rotation including mockup perspective
      const contentImg = document.createElement('img');
      contentImg.src = currentImage.src;

      // Combine image rotation with mockup perspective
      const totalRotationX = rotationX + (mockupTiltX || 0);
      const totalRotationY = rotationY + (mockupTiltY || 0);
      const totalRotationZ = rotationAngle + (mockupTiltZ || 0);

      // Apply rotation and fit to screen area
      const shadowIntensity = (Math.abs(totalRotationX) + Math.abs(totalRotationY)) / 180;
      contentImg.style.cssText = `
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: rotateX(${totalRotationX}deg) rotateY(${totalRotationY}deg) rotateZ(${totalRotationZ}deg);
        transform-style: preserve-3d;
        filter: drop-shadow(${Math.sin((totalRotationY * Math.PI) / 180) * 3}px ${Math.sin((totalRotationX * Math.PI) / 180) * 3}px ${3 + shadowIntensity * 3}px rgba(0,0,0,${0.3 * shadowIntensity}));
      `;

      screenAreaDiv.appendChild(contentImg);

      // Add label
      const label = document.createElement('div');
      label.style.cssText = `
        position: absolute;
        bottom: -25px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        color: #10b981;
        font-weight: 600;
        background: rgba(16, 185, 129, 0.1);
        padding: 2px 6px;
        border-radius: 4px;
        white-space: nowrap;
      `;
      label.textContent = `Preview: ${selectedScreenArea.name}`;

      manualPreview.appendChild(screenAreaDiv);
      manualPreview.appendChild(label);

      // Replace preview content
      previewContent.innerHTML = '';
      previewContent.appendChild(manualPreview);
    }

    // Update overlay scale to match current image
    function updateOverlayScale() {
      if (!targetObjectData || !currentImage) return;

      const overlay = document.getElementById('targetOverlay');
      const overlayImg = overlay ? overlay.querySelector('img') : null;

      if (overlayImg && targetObjectData.width && targetObjectData.height) {
        const previewContainer = document.getElementById('imagePreview');
        const containerWidth = previewContainer.offsetWidth * 0.9;
        const containerHeight = previewContainer.offsetHeight * 0.9;

        const currentScale = Math.min(containerWidth / currentImage.width, containerHeight / currentImage.height);
        const targetScale = Math.min(containerWidth / targetObjectData.width, containerHeight / targetObjectData.height);

        const uniformScale = Math.min(currentScale, targetScale);

        overlayImg.style.width = (targetObjectData.width * uniformScale) + 'px';
        overlayImg.style.height = (targetObjectData.height * uniformScale) + 'px';
        overlayImg.style.maxWidth = 'none';
        overlayImg.style.maxHeight = 'none';
      }
    }

    // Toggle fullscreen mode
    function toggleFullscreen() {
      const body = document.body;
      const fsLeft = document.getElementById('fsLeft');
      const fsRight = document.getElementById('fsRight');
      const fsExitBtn = document.getElementById('fsExitBtn');
      const fullscreenToggle = document.getElementById('fullscreenToggle');

      if (body.classList.contains('fs')) {
        // Exit fullscreen
        body.classList.remove('fs');
        if (fsLeft) fsLeft.classList.add('hidden');
        if (fsRight) fsRight.classList.add('hidden');
        if (fsExitBtn) fsExitBtn.classList.add('hidden');
        if (fullscreenToggle) fullscreenToggle.textContent = 'üì± Open Fullscreen Mode';
        
        // Sync values back to main controls
        syncFromFullscreenControls();
        
        // Update regular preview
        updatePreview();
      } else {
        // Enter fullscreen
        body.classList.add('fs');
        if (fsLeft) fsLeft.classList.remove('hidden');
        if (fsRight) fsRight.classList.remove('hidden');
        if (fsExitBtn) fsExitBtn.classList.remove('hidden');
        if (fullscreenToggle) fullscreenToggle.textContent = 'üì± Exit Fullscreen Mode';
        
        // Sync values to fullscreen controls
        syncToFullscreenControls();
        
        // Update fullscreen preview
        updateFullscreenPreview();
      }
    }

    // Sync values from main controls to fullscreen controls
    function syncToFullscreenControls() {
      // Rotation controls
      const fsRotationZ = document.getElementById('fsRotationZ');
      const fsRotationX = document.getElementById('fsRotationX');
      const fsRotationY = document.getElementById('fsRotationY');
      const fsRotationZSlider = document.getElementById('fsRotationZSlider');
      const fsRotationXSlider = document.getElementById('fsRotationXSlider');
      const fsRotationYSlider = document.getElementById('fsRotationYSlider');

      if (fsRotationZ) fsRotationZ.value = rotationAngle;
      if (fsRotationX) fsRotationX.value = rotationX;
      if (fsRotationY) fsRotationY.value = rotationY;
      if (fsRotationZSlider) fsRotationZSlider.value = rotationAngle;
      if (fsRotationXSlider) fsRotationXSlider.value = rotationX;
      if (fsRotationYSlider) fsRotationYSlider.value = rotationY;

      // Manual mode
      const fsManualScreenMode = document.getElementById('fsManualScreenMode');
      if (fsManualScreenMode) fsManualScreenMode.checked = manualScreenEnabled;

      updateFullscreenRotationLabels();
    }

    // Sync values from fullscreen controls back to main controls
    function syncFromFullscreenControls() {
      // Update main rotation controls
      document.getElementById('rotationSlider').value = rotationAngle;
      document.getElementById('rotationXSlider').value = rotationX;
      document.getElementById('rotationYSlider').value = rotationY;
      document.getElementById('rotationInput').value = rotationAngle;
      document.getElementById('rotationXInput').value = rotationX;
      document.getElementById('rotationYInput').value = rotationY;
      document.getElementById('rotationValue').textContent = rotationAngle + '¬∞';
      document.getElementById('rotationXValue').textContent = rotationX + '¬∞';
      document.getElementById('rotationYValue').textContent = rotationY + '¬∞';

      // Update manual mode
      const manualScreenMode = document.getElementById('manualScreenMode');
      if (manualScreenMode) manualScreenMode.checked = manualScreenEnabled;
    }

    // Update fullscreen rotation from controls
    function updateFullscreenRotation() {
      const fsRotationZ = document.getElementById('fsRotationZ');
      const fsRotationX = document.getElementById('fsRotationX');
      const fsRotationY = document.getElementById('fsRotationY');

      if (fsRotationZ) rotationAngle = parseInt(fsRotationZ.value) || 0;
      if (fsRotationX) rotationX = parseInt(fsRotationX.value) || 0;
      if (fsRotationY) rotationY = parseInt(fsRotationY.value) || 0;

      updateFullscreenRotationLabels();
      updateFullscreenPreview();
    }

    // Update fullscreen rotation labels
    function updateFullscreenRotationLabels() {
      const fsRotationZValue = document.getElementById('fsRotationZValue');
      const fsRotationXValue = document.getElementById('fsRotationXValue');
      const fsRotationYValue = document.getElementById('fsRotationYValue');

      if (fsRotationZValue) fsRotationZValue.textContent = rotationAngle + '¬∞';
      if (fsRotationXValue) fsRotationXValue.textContent = rotationX + '¬∞';
      if (fsRotationYValue) fsRotationYValue.textContent = rotationY + '¬∞';
    }

    // Set fullscreen preset
    function setFullscreenPreset(x, y, z) {
      rotationX = x;
      rotationY = y;
      rotationAngle = z;

      // Update fullscreen controls
      const fsRotationZ = document.getElementById('fsRotationZ');
      const fsRotationX = document.getElementById('fsRotationX');
      const fsRotationY = document.getElementById('fsRotationY');
      const fsRotationZSlider = document.getElementById('fsRotationZSlider');
      const fsRotationXSlider = document.getElementById('fsRotationXSlider');
      const fsRotationYSlider = document.getElementById('fsRotationYSlider');

      if (fsRotationZ) fsRotationZ.value = z;
      if (fsRotationX) fsRotationX.value = x;
      if (fsRotationY) fsRotationY.value = y;
      if (fsRotationZSlider) fsRotationZSlider.value = z;
      if (fsRotationXSlider) fsRotationXSlider.value = x;
      if (fsRotationYSlider) fsRotationYSlider.value = y;

      updateFullscreenRotationLabels();
      updateFullscreenPreview();
    }

    // Manual mode functions for fullscreen
    function selectMockupForManual() {
      selectMockupStep1();
    }

    function selectScreenAreaForManual() {
      selectScreenAreaStep2();
    }

    function applyManualInsert() {
      manualInsert();
    }

    function applyRotation() {
      applyToOriginal();
    }

    function copyRotationData() {
      copyRotation();
    }

    // Copy current rotation values to clipboard
    function copyRotation() {
      copiedRotation = {
        z: rotationAngle,
        x: rotationX,
        y: rotationY
      };

      // Enable the apply button
      const applyBtn = document.getElementById('applyRotationBtn');
      if (applyBtn) {
        applyBtn.disabled = false;
        applyBtn.textContent = `üìå Apply (${copiedRotation.z}¬∞, ${copiedRotation.x}¬∞, ${copiedRotation.y}¬∞)`;
      }

      // Show notification
      showNotification(`Rotation copied: Z:${rotationAngle}¬∞, X:${rotationX}¬∞, Y:${rotationY}¬∞`, 'success');

      console.log('üéØ Rotation copied:', copiedRotation);
    }

    // Apply copied rotation values
    function applyRotationFromClipboard() {
      if (!copiedRotation) {
        showNotification('No rotation copied yet', 'error');
        return;
      }

      // Apply the copied values
      rotationAngle = copiedRotation.z;
      rotationX = copiedRotation.x;
      rotationY = copiedRotation.y;

      // Update all UI elements
      document.getElementById('rotationSlider').value = rotationAngle;
      document.getElementById('rotationXSlider').value = rotationX;
      document.getElementById('rotationYSlider').value = rotationY;
      document.getElementById('rotationInput').value = rotationAngle;
      document.getElementById('rotationXInput').value = rotationX;
      document.getElementById('rotationYInput').value = rotationY;
      document.getElementById('rotationValue').textContent = rotationAngle + '¬∞';
      document.getElementById('rotationXValue').textContent = rotationX + '¬∞';
      document.getElementById('rotationYValue').textContent = rotationY + '¬∞';

      // Update preview
      updatePreview();

      // Show notification
      showNotification(`Rotation applied: Z:${rotationAngle}¬∞, X:${rotationX}¬∞, Y:${rotationY}¬∞`, 'success');

      console.log('üéØ Rotation applied from clipboard:', copiedRotation);
    }

    // Target overlay variables
    let targetObjectData = null;

    // Main preview update function
    function updatePreview() {
      const previewContent = document.getElementById('previewContent');
      const useCanvas = document.getElementById('useCanvasPreview');

      if (currentImage) {
        if (useCanvas && useCanvas.checked) {
          // Canvas preview
          const previewCanvas = document.createElement('canvas');
          const previewCtx = previewCanvas.getContext('2d');

          const previewSize = 180;
          previewCanvas.width = previewSize;
          previewCanvas.height = previewSize;
          previewCanvas.style.cssText = `
            max-width: 100%; 
            max-height: 100%; 
            border-radius: 8px;
          `;

          previewCtx.clearRect(0, 0, previewSize, previewSize);

          const scale = Math.min(previewSize * 0.8 / currentImage.width, previewSize * 0.8 / currentImage.height);
          const scaledWidth = currentImage.width * scale;
          const scaledHeight = currentImage.height * scale;

          previewCtx.save();
          previewCtx.translate(previewSize / 2, previewSize / 2);

          const radZ = (rotationAngle * Math.PI) / 180;
          const radX = (rotationX * Math.PI) / 180;
          const radY = (rotationY * Math.PI) / 180;

          if (typeof applyTransforms === 'function') {
            applyTransforms(previewCtx, radX, radY, radZ);
          }

          if (rotationX !== 0 || rotationY !== 0) {
            const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;
            previewCtx.shadowColor = `rgba(0,0,0,${0.3 * shadowIntensity})`;
            previewCtx.shadowBlur = 5 + shadowIntensity * 5;
            previewCtx.shadowOffsetX = Math.sin((rotationY * Math.PI) / 180) * 5;
            previewCtx.shadowOffsetY = Math.sin((rotationX * Math.PI) / 180) * 5;
          }

          previewCtx.drawImage(currentImage, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
          previewCtx.restore();

          previewContent.innerHTML = '';
          previewContent.appendChild(previewCanvas);
        } else {
          // CSS 3D preview
          const container = document.createElement('div');
          container.style.cssText = `
            width: 100%; 
            height: 100%; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            perspective: 800px;
          `;

          const img = document.createElement('img');
          img.src = currentImage.src;

          const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;

          img.style.cssText = `
            max-width: 90%; 
            max-height: 90%; 
            transform: rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationAngle}deg);
            transition: transform 0.2s ease;
            filter: drop-shadow(${Math.sin((rotationY * Math.PI) / 180) * 10}px ${Math.sin((rotationX * Math.PI) / 180) * 10}px ${10 + shadowIntensity * 10}px rgba(0,0,0,${0.3 * shadowIntensity}));
            transform-style: preserve-3d;
          `;

          container.appendChild(img);
          previewContent.innerHTML = '';
          previewContent.appendChild(container);
        }
      } else {
        previewContent.innerHTML = '<div style="color:#666; text-align:center; padding:40px;">No image selected</div>';
      }
    }

    // Apply transforms to canvas context (matching export algorithm)
    function applyTransforms(ctx, radX, radY, radZ) {
      // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ –¥–ª—è 3D —ç—Ñ—Ñ–µ–∫—Ç–∞
      
      // 1. Z –ø–æ–≤–æ—Ä–æ—Ç (–æ–±—ã—á–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –≤ –ø–ª–æ—Å–∫–æ—Å—Ç–∏)
      if (radZ !== 0) {
        ctx.rotate(radZ);
      }

      // 2. Y –ø–æ–≤–æ—Ä–æ—Ç (–ø–æ–≤–æ—Ä–æ—Ç –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ) - –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
      if (radY !== 0) {
        const cosY = Math.cos(radY);
        const sinY = Math.sin(radY);
        const scaleX = Math.abs(cosY);
        const skewY = sinY * 0.7; // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã
        ctx.transform(scaleX, 0, skewY, 1, 0, 0);
      }

      // 3. X –ø–æ–≤–æ—Ä–æ—Ç (–Ω–∞–∫–ª–æ–Ω –≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑) - –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç  
      if (radX !== 0) {
        const cosX = Math.cos(radX);
        const sinX = Math.sin(radX);
        const scaleY = Math.abs(cosX);
        const skewX = sinX * 0.7; // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã
        ctx.transform(1, skewX, 0, scaleY, 0, 0);
      }
    }

    // Update overlay scale to match current image
    function updateOverlayScale() {
      // Safe check for targetObjectData
      if (!targetObjectData || !currentImage) return;

      const overlay = document.getElementById('targetOverlay');
      const overlayImg = overlay ? overlay.querySelector('img') : null;

      if (overlayImg && targetObjectData.width && targetObjectData.height) {
        const previewContainer = document.getElementById('imagePreview');
        const containerWidth = previewContainer.offsetWidth * 0.9;
        const containerHeight = previewContainer.offsetHeight * 0.9;

        const currentScale = Math.min(containerWidth / currentImage.width, containerHeight / currentImage.height);
        const targetScale = Math.min(containerWidth / targetObjectData.width, containerHeight / targetObjectData.height);

        const uniformScale = Math.min(currentScale, targetScale);

        overlayImg.style.width = (targetObjectData.width * uniformScale) + 'px';
        overlayImg.style.height = (targetObjectData.height * uniformScale) + 'px';
        overlayImg.style.maxWidth = 'none';
        overlayImg.style.maxHeight = 'none';
      }
    }









    function updatePreview() {
      const previewContent = document.getElementById('previewContent');
      const useCanvas = document.getElementById('useCanvasPreview').checked;

      // Special handling for fullscreen mode
      if (document.body.classList.contains('fs')) {
        updateFullscreenPreview();
        return;
      }

      // Check if Manual Screen Mode should take over the preview
      if (manualScreenEnabled && selectedMockup && selectedScreenArea && currentImage) {
        updateManualScreenPreview();
        return;
      }

      if (currentImage) {
        if (useCanvas) {
          // Canvas –ø—Ä–µ–≤—å—é (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ –∫–∞–∫ —ç–∫—Å–ø–æ—Ä—Ç - –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è –æ—Ç CSS)
          const previewCanvas = document.createElement('canvas');
          const previewCtx = previewCanvas.getContext('2d');

          // –†–∞–∑–º–µ—Ä –ø—Ä–µ–≤—å—é
          const previewSize = 180;
          previewCanvas.width = previewSize;
          previewCanvas.height = previewSize;
          previewCanvas.style.cssText = `
        max-width: 100%; 
        max-height: 100%; 
        border-radius: 8px;
      `;

          // –û—á–∏—â–∞–µ–º –ø—Ä–µ–≤—å—é
          previewCtx.clearRect(0, 0, previewSize, previewSize);

          // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø—Ä–µ–≤—å—é
          const scale = Math.min(previewSize * 0.8 / currentImage.width, previewSize * 0.8 / currentImage.height);
          const scaledWidth = currentImage.width * scale;
          const scaledHeight = currentImage.height * scale;

          previewCtx.save();
          previewCtx.translate(previewSize / 2, previewSize / 2);

          // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ –∂–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ —á—Ç–æ –∏ –≤ —ç–∫—Å–ø–æ—Ä—Ç–µ
          const radZ = (rotationAngle * Math.PI) / 180;
          const radX = (rotationX * Math.PI) / 180;
          const radY = (rotationY * Math.PI) / 180;

          // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
          applyTransforms(previewCtx, radX, radY, radZ);

          // –¢–µ–Ω—å
          if (rotationX !== 0 || rotationY !== 0) {
            const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;
            previewCtx.shadowColor = `rgba(0,0,0,${0.3 * shadowIntensity})`;
            previewCtx.shadowBlur = 5 + shadowIntensity * 5;
            previewCtx.shadowOffsetX = Math.sin((rotationY * Math.PI) / 180) * 5;
            previewCtx.shadowOffsetY = Math.sin((rotationX * Math.PI) / 180) * 5;
          }

          // –†–∏—Å—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
          previewCtx.drawImage(currentImage, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
          previewCtx.restore();

          previewContent.innerHTML = '';
          previewContent.appendChild(previewCanvas);
        } else {
          // CSS 3D –ø—Ä–µ–≤—å—é (–∫—Ä–∞—Å–∏–≤—ã–π, –Ω–æ –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è)
          const container = document.createElement('div');
          container.style.cssText = `
        width: 100%; 
        height: 100%; 
        display: flex; 
        align-items: center; 
        justify-content: center;
        perspective: 800px;
      `;

          const img = document.createElement('img');
          img.src = currentImage.src;

          const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;

          img.style.cssText = `
        max-width: 90%; 
        max-height: 90%; 
        transform: rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationAngle}deg);
        transition: transform 0.2s ease;
        filter: drop-shadow(${Math.sin((rotationY * Math.PI) / 180) * 10}px ${Math.sin((rotationX * Math.PI) / 180) * 10}px ${10 + shadowIntensity * 10}px rgba(0,0,0,${0.3 * shadowIntensity}));
        transform-style: preserve-3d;
      `;

          container.appendChild(img);
          previewContent.innerHTML = '';
          previewContent.appendChild(container);
        }
      } else {
        // No image selected - show placeholder
        previewContent.innerHTML = '<div style="color:#666; text-align:center; padding:40px;">No image selected</div>';
      }

      // Update overlay scale if target is set
      updateOverlayScale();
    }

    // Update overlay scale to match current image
    function updateOverlayScale() {
      if (!targetObjectData || !currentImage) return;

      const overlay = document.getElementById('targetOverlay');
      const overlayImg = overlay ? overlay.querySelector('img') : null;

      if (overlayImg && targetObjectData.width && targetObjectData.height) {
        const previewContainer = document.getElementById('imagePreview');
        const containerWidth = previewContainer.offsetWidth * 0.9;
        const containerHeight = previewContainer.offsetHeight * 0.9;

        // Calculate scale for both images to fit in container
        const currentScale = Math.min(containerWidth / currentImage.width, containerHeight / currentImage.height);
        const targetScale = Math.min(containerWidth / targetObjectData.width, containerHeight / targetObjectData.height);

        // Use the same scale for both images
        const uniformScale = Math.min(currentScale, targetScale);

        overlayImg.style.width = (targetObjectData.width * uniformScale) + 'px';
        overlayImg.style.height = (targetObjectData.height * uniformScale) + 'px';
        overlayImg.style.maxWidth = 'none';
        overlayImg.style.maxHeight = 'none';
      }
    }



    // Update fullscreen preview
    function updateFullscreenPreview() {
      const previewContent = document.getElementById('previewContent');
      if (!previewContent) return;

      // Check if Manual Screen Mode should take over the fullscreen preview
      if (manualScreenEnabled && selectedMockup && selectedScreenArea && currentImage) {
        updateManualScreenPreview();
        return;
      }

      // Regular fullscreen preview for non-manual mode
      if (currentImage) {
        const container = document.createElement('div');
        container.style.cssText = `
          width: 100%; 
          height: 100%; 
          display: flex; 
          align-items: center; 
          justify-content: center;
          perspective: 1200px;
          background: #f8f9fa;
        `;

        const img = document.createElement('img');
        img.src = currentImage.src;

        const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;

        img.style.cssText = `
          max-width: 90%; 
          max-height: 90%; 
          transform: rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationAngle}deg);
          transition: transform 0.2s ease;
          filter: drop-shadow(${Math.sin((rotationY * Math.PI) / 180) * 15}px ${Math.sin((rotationX * Math.PI) / 180) * 15}px ${15 + shadowIntensity * 15}px rgba(0,0,0,${0.4 * shadowIntensity}));
          transform-style: preserve-3d;
        `;

        container.appendChild(img);
        previewContent.innerHTML = '';
        previewContent.appendChild(container);
      } else {
        // No image selected - show placeholder
        previewContent.innerHTML = '<div style="color:#666; text-align:center; padding:40px; font-size: 18px;">No image selected</div>';
      }
    }

    // Update Manual Screen preview to show how image will look in selected area
    function updateManualScreenPreview() {
      if (!manualScreenEnabled || !selectedMockup || !selectedScreenArea || !currentImage) {
        return;
      }

      const previewContent = document.getElementById('previewContent');
      if (!previewContent) return;

      // Create Manual Screen preview container
      const manualPreview = document.createElement('div');
      manualPreview.className = 'manual-screen-preview';
      manualPreview.style.cssText = `
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f8f9fa;
        border-radius: 8px;
        border: 2px solid #10b981;
      `;

      // Calculate preview scale
      const previewContainer = document.getElementById('imagePreview');
      const containerWidth = previewContainer.offsetWidth * 0.9;
      const containerHeight = previewContainer.offsetHeight * 0.9;

      // Use screen area dimensions for preview scale
      const previewScale = Math.min(
        containerWidth / selectedScreenArea.width,
        containerHeight / selectedScreenArea.height
      ) * 0.8; // 80% to leave some margin

      // Create screen area representation
      const screenAreaDiv = document.createElement('div');
      screenAreaDiv.style.cssText = `
        position: relative;
        width: ${selectedScreenArea.width * previewScale}px;
        height: ${selectedScreenArea.height * previewScale}px;
        border: 2px dashed #10b981;
        background: rgba(16, 185, 129, 0.1);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      `;

      // Add content image with rotation including mockup perspective
      const contentImg = document.createElement('img');
      contentImg.src = currentImage.src;

      // Combine image rotation with mockup perspective
      const totalRotationX = rotationX + mockupTiltX;
      const totalRotationY = rotationY + mockupTiltY;
      const totalRotationZ = rotationAngle + mockupTiltZ;

      // Apply rotation and fit to screen area
      const shadowIntensity = (Math.abs(totalRotationX) + Math.abs(totalRotationY)) / 180;
      contentImg.style.cssText = `
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: rotateX(${totalRotationX}deg) rotateY(${totalRotationY}deg) rotateZ(${totalRotationZ}deg);
        transform-style: preserve-3d;
        filter: drop-shadow(${Math.sin((totalRotationY * Math.PI) / 180) * 3}px ${Math.sin((totalRotationX * Math.PI) / 180) * 3}px ${3 + shadowIntensity * 3}px rgba(0,0,0,${0.3 * shadowIntensity}));
      `;

      screenAreaDiv.appendChild(contentImg);

      // Add label
      const label = document.createElement('div');
      label.style.cssText = `
        position: absolute;
        bottom: -25px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        color: #10b981;
        font-weight: 600;
        background: rgba(16, 185, 129, 0.1);
        padding: 2px 6px;
        border-radius: 4px;
        white-space: nowrap;
      `;
      label.textContent = `Preview: ${selectedScreenArea.name}`;

      manualPreview.appendChild(screenAreaDiv);
      manualPreview.appendChild(label);

      // Replace preview content
      previewContent.innerHTML = '';
      previewContent.appendChild(manualPreview);
    }



    // ===== MANUAL SCREEN MODE FUNCTIONS =====

    // Toggle Manual Screen Mode
    function toggleManualScreenMode() {
      const checkbox = document.getElementById('manualScreenMode');
      const fsCheckbox = document.getElementById('fsManualScreenMode');
      const controls = document.getElementById('manualScreenControls');
      const fsControls = document.getElementById('fsManualControls');

      // Sync checkboxes
      if (checkbox && fsCheckbox) {
        if (event.target === checkbox) {
          fsCheckbox.checked = checkbox.checked;
        } else if (event.target === fsCheckbox) {
          checkbox.checked = fsCheckbox.checked;
        }
      }

      manualScreenEnabled = (checkbox && checkbox.checked) || (fsCheckbox && fsCheckbox.checked);

      if (manualScreenEnabled) {
        if (controls) controls.style.display = 'block';
        if (fsControls) fsControls.style.display = 'block';
        showNotification('üéØ Manual Screen Mode enabled. This gives you precise control over image placement.', 'info');
      } else {
        if (controls) controls.style.display = 'none';
        if (fsControls) fsControls.style.display = 'none';
        clearManualSelection();
        showNotification('Manual Screen Mode disabled.', 'info');
      }
    }

    // Step 1: Select mockup
    function selectMockupStep1() {
      showNotification('üì± Step 1: Now select the phone mockup in Figma (frame, group, or component)', 'info');

      // Update button state
      const btn = document.getElementById('selectMockupBtn');
      if (btn) {
        btn.textContent = '‚è≥ Waiting for selection...';
        btn.disabled = true;
      }

      parent.postMessage({
        pluginMessage: {
          type: 'manual-select-mockup'
        }
      }, '*');
    }

    // Step 2: Select screen area
    function selectScreenAreaStep2() {
      if (!selectedMockup) {
        showNotification('‚ùå Please complete Step 1 first - select the phone mockup', 'error');
        return;
      }

      showNotification('üìê Step 2: Now select the screen area (rectangle that defines where image should go)', 'info');

      // Update button state
      const btn = document.getElementById('selectScreenBtn');
      if (btn) {
        btn.textContent = '‚è≥ Waiting for selection...';
        btn.disabled = true;
      }

      parent.postMessage({
        pluginMessage: {
          type: 'manual-select-screen-area'
        }
      }, '*');
    }

    // Set selected mockup (Step 1 result)
    function setSelectedMockup(data) {
      selectedMockup = data;

      const mockupStatus = document.getElementById('mockupStatus');
      const selectScreenBtn = document.getElementById('selectScreenBtn');
      const selectMockupBtn = document.getElementById('selectMockupBtn');

      // Update status and enable next step
      if (mockupStatus) mockupStatus.innerHTML = `‚úÖ <strong>${data.name}</strong> selected`;
      if (selectScreenBtn) {
        selectScreenBtn.disabled = false;
        selectScreenBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
        selectScreenBtn.style.color = '#fff';
      }

      // Reset mockup button
      if (selectMockupBtn) {
        selectMockupBtn.textContent = 'üì± Select Phone Mockup';
        selectMockupBtn.disabled = false;
      }

      showNotification(`‚úÖ Step 1 complete: ${data.name}. Now select screen area.`, 'success');
    }

    // Set selected screen area (Step 2 result)
    function setSelectedScreenArea(data) {
      selectedScreenArea = data;

      const screenStatus = document.getElementById('screenStatus');
      const readyInfo = document.getElementById('manualReadyInfo');
      const insertBtn = document.getElementById('manualInsertBtn');
      const selectScreenBtn = document.getElementById('selectScreenBtn');

      // Update status and show ready section
      if (screenStatus) screenStatus.innerHTML = `‚úÖ <strong>${data.name}</strong> selected`;
      if (readyInfo) readyInfo.style.display = 'block';

      // Reset screen button
      if (selectScreenBtn) {
        selectScreenBtn.textContent = 'üìê Select Screen Rectangle';
        selectScreenBtn.disabled = false;
        selectScreenBtn.style.background = '';
        selectScreenBtn.style.color = '';
      }

      // Enable insert if we have image
      if (insertBtn) {
        if (currentImage) {
          insertBtn.disabled = false;
          insertBtn.textContent = 'üéØ Insert Image into Screen';
          insertBtn.style.background = 'linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%)';
        } else {
          insertBtn.disabled = true;
          insertBtn.textContent = '‚ö†Ô∏è Select an image first';
          insertBtn.style.background = '';
        }
      }
      
      // Update preview to show the result
      updatePreview();

      showNotification(`‚úÖ Step 2 complete: ${data.name}. ${currentImage ? 'Ready to insert!' : 'Select an image to continue.'}`, 'success');
    }

    // Manual insert into selected screen area
    function manualInsert() {
      if (!selectedMockup || !selectedScreenArea || !currentImage) {
        let missing = [];
        if (!selectedMockup) missing.push('phone mockup');
        if (!selectedScreenArea) missing.push('screen area');
        if (!currentImage) missing.push('image');

        showNotification(`‚ùå Missing: ${missing.join(', ')}`, 'error');
        return;
      }

      // Check license before processing
      if (!checkUsageLimit()) {
        return;
      }

      showNotification('üéØ Inserting image into screen area...', 'info');

      // Update button state
      const insertBtn = document.getElementById('manualInsertBtn');
      if (insertBtn) {
        insertBtn.textContent = '‚è≥ Processing...';
        insertBtn.disabled = true;
      }

      // Send manual insert request with all rotation data including mockup perspective
      parent.postMessage({
        pluginMessage: {
          type: 'manual-insert',
          mockupData: selectedMockup,
          screenAreaData: selectedScreenArea,
          imageData: currentImage.src,
          rotation: {
            z: rotationAngle,
            x: rotationX,
            y: rotationY
          },
          mockupPerspective: {
            x: mockupTiltX,
            y: mockupTiltY,
            z: mockupTiltZ
          }
        }
      }, '*');
    }

    // Clear manual selection
    function clearManualSelection() {
      selectedMockup = null;
      selectedScreenArea = null;

      // Reset mockup tilt
      mockupTiltX = 0;
      mockupTiltY = 0;
      mockupTiltZ = 0;
      resetMockupTilt();

      const mockupStatus = document.getElementById('mockupStatus');
      const screenStatus = document.getElementById('screenStatus');
      const selectScreenBtn = document.getElementById('selectScreenBtn');
      const selectMockupBtn = document.getElementById('selectMockupBtn');
      const readyInfo = document.getElementById('manualReadyInfo');
      const insertBtn = document.getElementById('manualInsertBtn');

      // Reset all UI elements to initial state
      if (mockupStatus) mockupStatus.textContent = 'Click button, then select phone in Figma';
      if (screenStatus) screenStatus.textContent = 'Select rectangle that defines screen area';

      if (selectScreenBtn) {
        selectScreenBtn.disabled = true;
        selectScreenBtn.style.background = '';
        selectScreenBtn.style.color = '';
        selectScreenBtn.textContent = 'üìê Select Screen Rectangle';
      }

      if (selectMockupBtn) {
        selectMockupBtn.disabled = false;
        selectMockupBtn.textContent = 'üì± Select Phone Mockup';
      }

      if (readyInfo) readyInfo.style.display = 'none';

      if (insertBtn) {
        insertBtn.disabled = true;
        insertBtn.textContent = 'üéØ Insert Image into Screen';
        insertBtn.style.background = '';
      }

      showNotification('üóëÔ∏è Manual selection cleared. Start over with Step 1.', 'success');
    }

    // Update mockup tilt from sliders
    function updateMockupTilt() {
      const xSlider = document.getElementById('mockupTiltXSlider');
      const ySlider = document.getElementById('mockupTiltYSlider');
      const zSlider = document.getElementById('mockupTiltZSlider');

      const xInput = document.getElementById('mockupTiltXInput');
      const yInput = document.getElementById('mockupTiltYInput');
      const zInput = document.getElementById('mockupTiltZInput');

      const xValue = document.getElementById('mockupTiltXValue');
      const yValue = document.getElementById('mockupTiltYValue');
      const zValue = document.getElementById('mockupTiltZValue');

      if (xSlider && ySlider && zSlider) {
        mockupTiltX = parseInt(xSlider.value);
        mockupTiltY = parseInt(ySlider.value);
        mockupTiltZ = parseInt(zSlider.value);

        // Update input fields
        if (xInput) xInput.value = mockupTiltX;
        if (yInput) yInput.value = mockupTiltY;
        if (zInput) zInput.value = mockupTiltZ;

        // Update labels
        if (xValue) xValue.textContent = mockupTiltX + '¬∞';
        if (yValue) yValue.textContent = mockupTiltY + '¬∞';
        if (zValue) zValue.textContent = mockupTiltZ + '¬∞';

        // Sync with fullscreen controls
        if (document.getElementById('fsRotationX')) {
          document.getElementById('fsRotationX').value = mockupTiltX;
          document.getElementById('fsRotationXSlider').value = mockupTiltX;
          document.getElementById('fsRotationXValue').textContent = mockupTiltX + '¬∞';
          
          document.getElementById('fsRotationY').value = mockupTiltY;
          document.getElementById('fsRotationYSlider').value = mockupTiltY;
          document.getElementById('fsRotationYValue').textContent = mockupTiltY + '¬∞';
        }

        // Update preview if available
        updatePreview();
      }
    }

    // Update mockup tilt from input fields
    function updateMockupTiltFromInput() {
      const xInput = document.getElementById('mockupTiltXInput');
      const yInput = document.getElementById('mockupTiltYInput');
      const zInput = document.getElementById('mockupTiltZInput');

      const xSlider = document.getElementById('mockupTiltXSlider');
      const ySlider = document.getElementById('mockupTiltYSlider');
      const zSlider = document.getElementById('mockupTiltZSlider');

      if (xInput && yInput && zInput) {
        const newX = Math.max(-90, Math.min(90, parseInt(xInput.value) || 0));
        const newY = Math.max(-90, Math.min(90, parseInt(yInput.value) || 0));
        const newZ = Math.max(-180, Math.min(180, parseInt(zInput.value) || 0));

        // Update values
        mockupTiltX = newX;
        mockupTiltY = newY;
        mockupTiltZ = newZ;

        // Update input fields (in case they were clamped)
        xInput.value = newX;
        yInput.value = newY;
        zInput.value = newZ;

        // Update sliders
        if (xSlider) xSlider.value = newX;
        if (ySlider) ySlider.value = newY;
        if (zSlider) zSlider.value = newZ;

        // Update labels
        const xValue = document.getElementById('mockupTiltXValue');
        const yValue = document.getElementById('mockupTiltYValue');
        const zValue = document.getElementById('mockupTiltZValue');

        if (xValue) xValue.textContent = newX + '¬∞';
        if (yValue) yValue.textContent = newY + '¬∞';
        if (zValue) zValue.textContent = newZ + '¬∞';

        // Update preview
        updatePreview();
      }
    }

    // Set specific mockup tilt values
    function setMockupTilt(x, y, z) {
      mockupTiltX = x;
      mockupTiltY = y;
      mockupTiltZ = z;

      const xSlider = document.getElementById('mockupTiltXSlider');
      const ySlider = document.getElementById('mockupTiltYSlider');
      const zSlider = document.getElementById('mockupTiltZSlider');

      const xInput = document.getElementById('mockupTiltXInput');
      const yInput = document.getElementById('mockupTiltYInput');
      const zInput = document.getElementById('mockupTiltZInput');

      if (xSlider) xSlider.value = x;
      if (ySlider) ySlider.value = y;
      if (zSlider) zSlider.value = z;

      if (xInput) xInput.value = x;
      if (yInput) yInput.value = y;
      if (zInput) zInput.value = z;

      updateMockupTilt();
    }

    // Reset mockup tilt
    function resetMockupTilt() {
      setMockupTilt(0, 0, 0);
    }



    function loadImage(imageData, width, height, name, detectedRotation) {
      currentImage = new Image();
      currentImage.name = name; // Store the name for comparison
      currentImage.onload = () => {
        updatePreview();
        document.getElementById('applyBtn').disabled = false;
        document.getElementById('copyBtn').disabled = false;



        // Enable Manual Insert if both mockup and screen area are selected
        const manualInsertBtn = document.getElementById('manualInsertBtn');
        if (manualInsertBtn && selectedMockup && selectedScreenArea) {
          manualInsertBtn.disabled = false;
          manualInsertBtn.textContent = 'üéØ Insert Image into Screen';
          manualInsertBtn.style.background = 'linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%)';
        }

        // If rotation was detected, show auto-copy option
        if (detectedRotation && (detectedRotation.z !== 0 || detectedRotation.x !== 0 || detectedRotation.y !== 0)) {
          showRotationDetectedNotification(detectedRotation);
        }
      };
      currentImage.src = imageData;
    }

    // Show notification when rotation is detected with option to auto-copy
    function showRotationDetectedNotification(detectedRotation) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 16px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
        z-index: 1000;
        background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
        color: #fff;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-width: 200px;
      `;

      const message = document.createElement('div');
      message.textContent = `üéØ Rotation detected: ${detectedRotation.z}¬∞`;

      const button = document.createElement('button');
      button.textContent = 'üìã Auto-copy rotation';
      button.style.cssText = `
        padding: 4px 8px;
        border: none;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.2);
        color: #fff;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      `;

      button.addEventListener('click', () => {
        // Auto-copy the detected rotation
        copiedRotation = {
          z: detectedRotation.z,
          x: detectedRotation.x,
          y: detectedRotation.y
        };

        // Enable the apply button
        const applyBtn = document.getElementById('applyRotationBtn');
        if (applyBtn) {
          applyBtn.disabled = false;
          applyBtn.textContent = `üìå Apply (${copiedRotation.z}¬∞, ${copiedRotation.x}¬∞, ${copiedRotation.y}¬∞)`;
        }

        showNotification('Rotation auto-copied from selected object!', 'success');
        notification.remove();
      });

      button.addEventListener('mouseenter', () => {
        button.style.background = 'rgba(255, 255, 255, 0.3)';
      });

      button.addEventListener('mouseleave', () => {
        button.style.background = 'rgba(255, 255, 255, 0.2)';
      });

      notification.appendChild(message);
      notification.appendChild(button);
      document.body.appendChild(notification);

      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 5000);
    }

    async function exportRotatedImage() {
      if (!currentImage) return null;

      // –ò—Å–ø–æ–ª—å–∑—É–µ–º canvas –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ —Å –≤—ã—Å–æ–∫–∏–º –∫–∞—á–µ—Å—Ç–≤–æ–º
      return await exportUsingCanvas();

      // –ü—Ä–æ—Å—Ç—ã–µ —É–≥–ª—ã –ø–æ–≤–æ—Ä–æ—Ç–∞
      const radZ = (rotationAngle * Math.PI) / 180;
      const radX = (rotationX * Math.PI) / 180;
      const radY = (rotationY * Math.PI) / 180;

      // –†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ canvas —Å —É—á–µ—Ç–æ–º –≤—Å–µ—Ö –ø–æ–≤–æ—Ä–æ—Ç–æ–≤
      const sin = Math.abs(Math.sin(radZ));
      const cos = Math.abs(Math.cos(radZ));

      let canvasWidth = currentImage.width * cos + currentImage.height * sin;
      let canvasHeight = currentImage.width * sin + currentImage.height * cos;

      // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–ª—è 3D —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
      if (rotationX !== 0 || rotationY !== 0) {
        const factor = 1 + (Math.abs(rotationX) + Math.abs(rotationY)) / 180 * 0.3;
        canvasWidth *= factor;
        canvasHeight *= factor;
      }

      // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∞—Å
      canvasWidth += 50;
      canvasHeight += 50;

      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –¥–ª—è Figma
      const MAX_SIZE = 2048;
      canvasWidth = Math.min(canvasWidth, MAX_SIZE);
      canvasHeight = Math.min(canvasHeight, MAX_SIZE);

      canvas.width = Math.ceil(canvasWidth);
      canvas.height = Math.ceil(canvasHeight);

      // –û—á–∏—â–∞–µ–º canvas –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º —Ñ–æ–Ω–æ–º
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);

      // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ –ø–æ–≤–æ—Ä–æ—Ç—ã
      // X –ø–æ–≤–æ—Ä–æ—Ç (–Ω–∞–∫–ª–æ–Ω)
      if (rotationX !== 0) {
        const cosX = Math.cos(radX);
        const sinX = Math.sin(radX);
        ctx.transform(1, 0, 0, cosX, 0, 0);
        ctx.transform(1, sinX * 0.2, 0, 1, 0, 0);
      }

      // Y –ø–æ–≤–æ—Ä–æ—Ç (–≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ)
      if (rotationY !== 0) {
        const cosY = Math.cos(radY);
        const sinY = Math.sin(radY);
        ctx.transform(cosY, 0, 0, 1, 0, 0);
        ctx.transform(1, 0, sinY * 0.2, 1, 0, 0);
      }

      // Z –ø–æ–≤–æ—Ä–æ—Ç (–æ–±—ã—á–Ω—ã–π)
      if (rotationAngle !== 0) {
        ctx.rotate(radZ);
      }

      // –¢–µ–Ω—å —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ CSS (drop-shadow)
      if (rotationX !== 0 || rotationY !== 0) {
        const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;
        ctx.shadowColor = `rgba(0,0,0,${0.3 * shadowIntensity})`;
        ctx.shadowBlur = 10 + shadowIntensity * 10;
        ctx.shadowOffsetX = Math.sin(radY) * 10;
        ctx.shadowOffsetY = Math.sin(radX) * 10;
      }

      // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –¥–ª—è 3D —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
      if (rotationX !== 0 || rotationY !== 0) {
        const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;
        ctx.shadowColor = `rgba(0,0,0,${0.3 * shadowIntensity})`;
        ctx.shadowBlur = 10 + shadowIntensity * 10;
        ctx.shadowOffsetX = Math.sin(radY) * 10;
        ctx.shadowOffsetY = Math.sin(radX) * 10;
      }

      // –†–∏—Å—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
      ctx.drawImage(currentImage, -currentImage.width / 2, -currentImage.height / 2);
      ctx.restore();

      // –ü—Ä–æ—Å—Ç–æ–π —ç–∫—Å–ø–æ—Ä—Ç PNG
      return canvas.toDataURL('image/png');
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ html2canvas
    function loadHtml2Canvas() {
      return new Promise((resolve, reject) => {
        if (typeof html2canvas !== 'undefined') {
          resolve();
          return;
        }
        
        const script = document.createElement('script');
        script.src = 'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
        script.onload = () => {
          console.log('‚úÖ html2canvas loaded dynamically');
          resolve();
        };
        script.onerror = () => {
          console.log('‚ùå html2canvas dynamic load failed');
          reject(new Error('Failed to load html2canvas'));
        };
        document.head.appendChild(script);
      });
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ø—É—Å—Ç—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π canvas
    function cropCanvas(canvas) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      let minX = canvas.width;
      let minY = canvas.height;
      let maxX = 0;
      let maxY = 0;
      
      // –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—Ü—ã –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π
      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          const alpha = data[(y * canvas.width + x) * 4 + 3];
          if (alpha > 0) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      
      // –ï—Å–ª–∏ –Ω–µ—Ç –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª
      if (minX >= maxX || minY >= maxY) {
        return canvas;
      }
      
      // –î–æ–±–∞–≤–ª—è–µ–º –±–æ–ª—å—à–æ–π –æ—Ç—Å—Ç—É–ø –¥–ª—è 3D —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
      const padding = Math.max(currentImage.width, currentImage.height) * 0.2; // 20% –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      minX = Math.max(0, minX - padding);
      minY = Math.max(0, minY - padding);
      maxX = Math.min(canvas.width, maxX + padding);
      maxY = Math.min(canvas.height, maxY + padding);
      
      console.log('üîç Crop bounds:', { minX, minY, maxX, maxY, padding });
      
      // –°–æ–∑–¥–∞–µ–º –æ–±—Ä–µ–∑–∞–Ω–Ω—ã–π canvas
      const croppedCanvas = document.createElement('canvas');
      const croppedCtx = croppedCanvas.getContext('2d');
      
      croppedCanvas.width = maxX - minX;
      croppedCanvas.height = maxY - minY;
      
      croppedCtx.drawImage(canvas, minX, minY, croppedCanvas.width, croppedCanvas.height, 0, 0, croppedCanvas.width, croppedCanvas.height);
      
      return croppedCanvas;
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–º–Ω–æ–∂–µ–Ω–∏—è –º–∞—Ç—Ä–∏—Ü —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
    function multiplyMatrix(m1, m2) {
      return [
        m1[0] * m2[0] + m1[2] * m2[1],  // a
        m1[1] * m2[0] + m1[3] * m2[1],  // b  
        m1[0] * m2[2] + m1[2] * m2[3],  // c
        m1[1] * m2[2] + m1[3] * m2[3],  // d
        m1[0] * m2[4] + m1[2] * m2[5] + m1[4], // e
        m1[1] * m2[4] + m1[3] * m2[5] + m1[5]  // f
      ];
    }

    // –≠–∫—Å–ø–æ—Ä—Ç —á–µ—Ä–µ–∑ Canvas —Å –≤—ã—Å–æ–∫–∏–º –∫–∞—á–µ—Å—Ç–≤–æ–º –∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ 3D —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è–º–∏
    async function exportUsingCanvas() {
      if (!currentImage) return null;

      console.log('üì∏ Capturing preview with improved quality');

      try {
        // –ù–∞—Ö–æ–¥–∏–º –æ–±–ª–∞—Å—Ç—å –ø—Ä–µ–≤—å—é
        const previewContent = document.getElementById('previewContent');
        if (!previewContent) {
          throw new Error('Preview not found');
        }

        // –£–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ html2canvas –∑–∞–≥—Ä—É–∂–µ–Ω
        if (typeof html2canvas === 'undefined') {
          console.log('üîÑ Loading html2canvas...');
          await loadHtml2Canvas();
          
          if (typeof html2canvas === 'undefined') {
            throw new Error('Failed to load html2canvas');
          }
        }

        console.log('üì∏ Capturing preview with html2canvas at high quality...');
        
        // –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º –ø—Ä–µ–≤—å—é —Å –ø–æ–º–æ—â—å—é html2canvas —Å –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–º scale
        const canvas = await html2canvas(previewContent, {
          backgroundColor: null,
          scale: 8, // –û—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π scale –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞
          useCORS: true,
          allowTaint: true,
          logging: false,
          width: previewContent.offsetWidth,
          height: previewContent.offsetHeight
        });

        console.log('‚úÖ Preview captured successfully, size:', canvas.width, 'x', canvas.height);

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        return {
          imageData: canvas.toDataURL('image/png', 0.95), // –í—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
          canvasWidth: canvas.width,
          canvasHeight: canvas.height
        };

      } catch (error) {
        console.error('‚ùå Preview capture with scale 8 failed:', error);
        
        // Fallback 1 - –ø–æ–ø—Ä–æ–±—É–µ–º —Å –º–µ–Ω—å—à–∏–º scale
        try {
          console.log('üîÑ Trying fallback with scale 6...');
          const canvas = await html2canvas(previewContent, {
            backgroundColor: null,
            scale: 6, // –ß—É—Ç—å –º–µ–Ω—å—à–∏–π scale
            useCORS: true,
            allowTaint: true,
            logging: false,
            width: previewContent.offsetWidth,
            height: previewContent.offsetHeight
          });

          return {
            imageData: canvas.toDataURL('image/png', 0.95),
            canvasWidth: canvas.width,
            canvasHeight: canvas.height
          };
        } catch (fallbackError) {
          console.error('‚ùå Fallback with scale 6 also failed:', fallbackError);
        }
        
        // Fallback 2 - –µ—â–µ –º–µ–Ω—å—à–∏–π scale
        try {
          console.log('üîÑ Trying fallback with scale 4...');
          const canvas = await html2canvas(previewContent, {
            backgroundColor: null,
            scale: 4, // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã—Å–æ–∫–∏–π scale
            useCORS: true,
            allowTaint: true,
            logging: false,
            width: previewContent.offsetWidth,
            height: previewContent.offsetHeight
          });

          return {
            imageData: canvas.toDataURL('image/png', 0.95),
            canvasWidth: canvas.width,
            canvasHeight: canvas.height
          };
        } catch (fallbackError2) {
          console.error('‚ùå All html2canvas attempts failed:', fallbackError2);
        }
        
        // –ü–æ—Å–ª–µ–¥–Ω–∏–π fallback - –ø—Ä–æ—Å—Ç–æ–π canvas —ç–∫—Å–ø–æ—Ä—Ç –±–µ–∑ 3D
        console.log('üîÑ Using simple canvas fallback');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = currentImage.width;
        canvas.height = currentImage.height;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(currentImage, 0, 0);
        
        return {
          imageData: canvas.toDataURL('image/png', 0.95),
          canvasWidth: canvas.width,
          canvasHeight: canvas.height
        };
      }
    }

    // –§—É–Ω–∫—Ü–∏—è —É–º–Ω–æ–∂–µ–Ω–∏—è 4x4 –º–∞—Ç—Ä–∏—Ü –¥–ª—è 3D —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π
    function multiply4x4(a, b) {
      const result = new Array(16);
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          result[i * 4 + j] = 
            a[i * 4 + 0] * b[0 * 4 + j] +
            a[i * 4 + 1] * b[1 * 4 + j] +
            a[i * 4 + 2] * b[2 * 4 + j] +
            a[i * 4 + 3] * b[3 * 4 + j];
        }
      }
      return result;
    }



    // –≠–∫—Å–ø–æ—Ä—Ç —á–µ—Ä–µ–∑ CSS - —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –ø—Ä–µ–≤—å—é (—Å—Ç–∞—Ä–∞—è –≤–µ—Ä—Å–∏—è)
    async function exportUsingCSS() {
      // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ –ø—Ä–µ–≤—å—é
      const tempContainer = document.createElement('div');
      // –ë–æ–ª—å—à–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      const rotationFactor = 1 + (Math.abs(rotationX) + Math.abs(rotationY)) / 90; // –ë–æ–ª—å—à–µ –º–µ—Å—Ç–∞ –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–æ–≤
      const containerWidth = currentImage.width * 4 * rotationFactor;
      const containerHeight = currentImage.height * 4 * rotationFactor;

      tempContainer.style.cssText = `
    position: fixed;
    top: -9999px;
    left: -9999px;
    width: ${containerWidth}px;
    height: ${containerHeight}px;
    perspective: 800px;
    background: transparent;
    display: flex;
    align-items: center;
    justify-content: center;
  `;

      const tempImg = document.createElement('img');
      tempImg.src = currentImage.src;

      // –¢–æ—á–Ω–æ —Ç–∞–∫–∏–µ –∂–µ —Å—Ç–∏–ª–∏ –∫–∞–∫ –≤ –ø—Ä–µ–≤—å—é
      const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;
      tempImg.style.cssText = `
    width: ${currentImage.width}px;
    height: ${currentImage.height}px;
    transform: rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationAngle}deg);
    transform-style: preserve-3d;
    filter: drop-shadow(${Math.sin((rotationY * Math.PI) / 180) * 10}px ${Math.sin((rotationX * Math.PI) / 180) * 10}px ${10 + shadowIntensity * 10}px rgba(0,0,0,${0.3 * shadowIntensity}));
  `;

      tempContainer.appendChild(tempImg);
      document.body.appendChild(tempContainer);

      try {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π API –¥–ª—è –∑–∞—Ö–≤–∞—Ç–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
        await new Promise(resolve => setTimeout(resolve, 100)); // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ —Ä–µ–Ω–¥–µ—Ä

        // –°–æ–∑–¥–∞–µ–º canvas –∏ —Ä–∏—Å—É–µ–º —ç–ª–µ–º–µ–Ω—Ç
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // –û—á–µ–Ω—å –±–æ–ª—å—à–æ–π canvas —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –ø–æ–º–µ—Å—Ç–∏–ª–æ—Å—å
        const diagonal = Math.sqrt(currentImage.width * currentImage.width + currentImage.height * currentImage.height);
        const canvasSize = Math.min(diagonal * 5, 4096); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤ 5 —Ä–∞–∑

        canvas.width = canvasSize;
        canvas.height = canvasSize;

        // –ü–æ–ª—É—á–∞–µ–º computed —Å—Ç–∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        const imgRect = tempImg.getBoundingClientRect();
        const containerRect = tempContainer.getBoundingClientRect();

        // –†–∏—Å—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º CSS transform
        ctx.save();

        // –ü—Ä–∏–º–µ–Ω—è–µ–º transform matrix –∏–∑ CSS
        const style = window.getComputedStyle(tempImg);
        const matrix = new DOMMatrix(style.transform);

        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ–º canvas
        ctx.translate(canvasSize / 2, canvasSize / 2);

        // –ü—Ä–∏–º–µ–Ω—è–µ–º CSS transform matrix (–≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –±—ã–ª–æ)
        ctx.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);

        // –†–∏—Å—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Ü–µ–Ω—Ç—Ä–µ
        ctx.drawImage(currentImage, -currentImage.width / 2, -currentImage.height / 2);

        ctx.restore();

        document.body.removeChild(tempContainer);

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ä–∞–∑–º–µ—Ä–∞—Ö
        return {
          imageData: canvas.toDataURL('image/png'),
          canvasWidth: canvas.width,
          canvasHeight: canvas.height
        };
      } catch (error) {
        console.error('CSS export failed:', error);
        document.body.removeChild(tempContainer);
        return exportUsingCanvasFallback();
      }
    }

    // Fallback –∫ canvas –∫–æ–≥–¥–∞ html2canvas –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
    function exportUsingCanvasFallback() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –¥–ª—è Figma
      const MAX_SIZE = 2048;
      let scale = 1;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏ —Ä–∞–∑–º–µ—Ä –ª–∏–º–∏—Ç
      if (currentImage.width > MAX_SIZE || currentImage.height > MAX_SIZE) {
        scale = Math.min(MAX_SIZE / currentImage.width, MAX_SIZE / currentImage.height);
      }

      canvas.width = Math.min(currentImage.width * scale, MAX_SIZE);
      canvas.height = Math.min(currentImage.height * scale, MAX_SIZE);

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(scale, scale);

      // –ü—Ä–æ—Å—Ç—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
      const radZ = (rotationAngle * Math.PI) / 180;
      const radX = (rotationX * Math.PI) / 180;
      const radY = (rotationY * Math.PI) / 180;

      // Z –ø–æ–≤–æ—Ä–æ—Ç (—Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ—á–Ω–æ)
      if (rotationAngle !== 0) {
        ctx.rotate(radZ);
      }

      // X –ø–æ–≤–æ—Ä–æ—Ç (–Ω–∞–∫–ª–æ–Ω –≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑) - —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è
      if (rotationX !== 0) {
        const cosX = Math.cos(radX);
        const sinX = Math.sin(radX);
        // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ + skew –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã
        ctx.transform(1, 0, 0, cosX, 0, 0);
        ctx.transform(1, sinX * 0.7, 0, 1, 0, 0);
      }

      // Y –ø–æ–≤–æ—Ä–æ—Ç (–≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ) - —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è
      if (rotationY !== 0) {
        const cosY = Math.cos(radY);
        const sinY = Math.sin(radY);
        // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ + skew –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã
        ctx.transform(cosY, 0, 0, 1, 0, 0);
        ctx.transform(1, 0, sinY * 0.7, 1, 0, 0);
      }

      // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –¥–ª—è 3D —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
      if (rotationX !== 0 || rotationY !== 0) {
        const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;
        ctx.shadowColor = `rgba(0,0,0,${0.3 * shadowIntensity})`;
        ctx.shadowBlur = 10 + shadowIntensity * 10;
        ctx.shadowOffsetX = Math.sin(radY) * 10;
        ctx.shadowOffsetY = Math.sin(radX) * 10;
      }

      ctx.drawImage(currentImage, -currentImage.width / 2, -currentImage.height / 2);
      ctx.restore();

      return canvas.toDataURL('image/png');
    }

    async function applyToOriginal() {
      // Check license before processing
      if (!checkUsageLimit()) {
        return;
      }

      const result = await exportRotatedImage();
      const keepSize = document.getElementById('keepOriginalSize').checked;
      const hasRotation = rotationX !== 0 || rotationY !== 0 || rotationAngle !== 0;

      if (result) {
        const imageData = typeof result === 'string' ? result : result.imageData;
        const canvasWidth = typeof result === 'object' ? result.canvasWidth : null;
        const canvasHeight = typeof result === 'object' ? result.canvasHeight : null;

        parent.postMessage({
          pluginMessage: {
            type: 'apply-rotation',
            imageData: imageData,
            isOriginal: true,
            keepOriginalSize: keepSize,
            hasRotation: hasRotation,
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight,
            rotation: {
              x: rotationX,
              y: rotationY,
              z: rotationAngle
            }
          }
        }, '*');

        // Increment usage after successful operation
        incrementUsage();
      }
    }

    async function createCopy() {
      // Check license before processing
      if (!checkUsageLimit()) {
        return;
      }

      const result = await exportRotatedImage();
      const keepSize = document.getElementById('keepOriginalSize').checked;
      const hasRotation = rotationX !== 0 || rotationY !== 0 || rotationAngle !== 0;

      if (result) {
        const imageData = typeof result === 'string' ? result : result.imageData;
        const canvasWidth = typeof result === 'object' ? result.canvasWidth : null;
        const canvasHeight = typeof result === 'object' ? result.canvasHeight : null;
        parent.postMessage({
          pluginMessage: {
            type: 'apply-rotation',
            imageData: imageData,
            isOriginal: false,
            keepOriginalSize: keepSize,
            hasRotation: hasRotation,
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight,
            rotation: {
              x: rotationX,
              y: rotationY,
              z: rotationAngle
            }
          }
        }, '*');

        // Increment usage after successful operation
        incrementUsage();
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–æ—á–Ω–æ—Å—Ç–∏ –ø—Ä–µ–≤—å—é
    function testPreviewAccuracy() {
      if (!currentImage) return;

      // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π canvas —Å —Ç–µ–º–∏ –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ —á—Ç–æ –∏ —ç–∫—Å–ø–æ—Ä—Ç
      const testCanvas = document.createElement('canvas');
      const testCtx = testCanvas.getContext('2d');

      // –ú–∞–ª–µ–Ω—å–∫–∏–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ç–µ—Å—Ç–∞
      testCanvas.width = 100;
      testCanvas.height = 100;

      // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ –∂–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
      testCtx.save();
      testCtx.translate(50, 50);

      const radZ = (rotationAngle * Math.PI) / 180;
      const radX = (rotationX * Math.PI) / 180;
      const radY = (rotationY * Math.PI) / 180;
      const perspective = 800;

      if (rotationX !== 0) {
        const cosX = Math.cos(radX);
        const sinX = Math.sin(radX);
        const scaleY = cosX;
        const skewY = sinX * (perspective / (perspective + Math.abs(rotationX) * 5));
        testCtx.transform(1, skewY, 0, scaleY, 0, 0);
      }

      if (rotationY !== 0) {
        const cosY = Math.cos(radY);
        const sinY = Math.sin(radY);
        const scaleX = cosY;
        const skewX = sinY * (perspective / (perspective + Math.abs(rotationY) * 5));
        testCtx.transform(scaleX, 0, skewX, 1, 0, 0);
      }

      if (rotationAngle !== 0) {
        testCtx.rotate(radZ);
      }

      testCtx.restore();

      console.log('Preview accuracy test completed');
    }

    // Handle messages from Figma
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;

      if (msg.type === 'image-exported') {
        loadImage(msg.data, msg.width, msg.height, msg.name, msg.detectedRotation);
      }

      if (msg.type === 'no-selection') {
        currentImage = null;
        updatePreview(); // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–≤—å—é –ø–æ—Å–ª–µ —Å–±—Ä–æ—Å–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        document.getElementById('applyBtn').disabled = true;
        document.getElementById('copyBtn').disabled = true;
      }

      if (msg.type === 'success') {
        showNotification(msg.message, 'success');

        // Reset manual insert button if it was a manual insert operation
        if (msg.message && msg.message.includes('Manual insert completed')) {
          const insertBtn = document.getElementById('manualInsertBtn');
          if (insertBtn) {
            insertBtn.textContent = 'üéØ Insert Image into Screen';
            insertBtn.disabled = false;
            insertBtn.style.background = 'linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%)';
          }
        }
      }

      if (msg.type === 'error') {
        showNotification(msg.message, 'error');
      }

      if (msg.type === 'export-progress') {
        showNotification(msg.message, 'info');
      }

      // License-related messages
      if (msg.type === 'license-info-response') {
        licenseInfo = {
          usageCount: msg.usageCount || 0,
          isPro: msg.isPro || false,
          remainingUses: msg.remainingUses !== undefined ? msg.remainingUses : 10,
          keyInfo: msg.keyInfo || null,
          expiryWarning: msg.expiryWarning || false,
          daysUntilExpiry: msg.daysUntilExpiry
        };
        updateLicenseUI();
      }

      if (msg.type === 'usage-updated') {
        licenseInfo.usageCount = msg.usageCount;
        licenseInfo.remainingUses = msg.remainingUses;
        updateLicenseUI();
      }

      if (msg.type === 'usage-limit-reached') {
        showLicenseModal();
      }

      if (msg.type === 'key-activation-response') {
        console.log('Key activation response:', msg);
        if (msg.success) {
          if (msg.action === 'activate') {
            licenseInfo.isPro = true;
            licenseInfo.remainingUses = -1;
            licenseInfo.keyInfo = msg.keyInfo;
            updateLicenseUI();
            hideSubscriptionModal();
            showNotification('Pro –≤–µ—Ä—Å–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!', 'success');
          } else if (msg.action === 'reset') {
            licenseInfo.isPro = false;
            licenseInfo.remainingUses = 10;
            licenseInfo.usageCount = 0;
            licenseInfo.keyInfo = null;
            updateLicenseUI();
            hideSubscriptionModal();
            showNotification('–ü–æ–¥–ø–∏—Å–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞!', 'success');
          }
        } else {
          let errorMsg = '–û—à–∏–±–∫–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∫–ª—é—á–∞';
          if (msg.error === 'format') {
            errorMsg = '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–ª—é—á–∞';
          } else if (msg.error === 'expired') {
            errorMsg = '–ö–ª—é—á –∏—Å—Ç–µ–∫';
          } else if (msg.error === 'device_mismatch') {
            errorMsg = '–ö–ª—é—á –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –¥—Ä—É–≥–æ–º—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É';
          } else if (msg.error === 'validation') {
            errorMsg = '–ö–ª—é—á –ø–æ–≤—Ä–µ–∂–¥–µ–Ω –∏–ª–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω';
          }
          showNotification(errorMsg, 'error');
        }
      }

      if (msg.type === 'challenge-response') {
        // Open Telegram bot with challenge
        if (msg.botUrl) {
          window.open(msg.botUrl, '_blank');
        }
      }



      if (msg.type === 'pro-activation-response') {
        if (msg.success) {
          licenseInfo.isPro = true;
          licenseInfo.remainingUses = -1;
          hideLicenseModal();
          showNotification('Pro –≤–µ—Ä—Å–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!', 'success');
        }
      }

      // Manual Screen Mode responses
      if (msg.type === 'manual-mockup-selected') {
        if (manualScreenEnabled) {
          setSelectedMockup({
            name: msg.name,
            width: msg.width,
            height: msg.height,
            x: msg.x,
            y: msg.y,
            transform: msg.transform,
            id: msg.id
          });
        }
      }

      if (msg.type === 'mockup-image-response') {
        if (selectedMockup && msg.imageData) {
          selectedMockup.imageData = msg.imageData;
          // Update preview with real mockup image
          if (document.body.classList.contains('fs') && manualScreenEnabled) {
            createRealMockupPreview();
          }
        }
      }

      if (msg.type === 'mockup-image-error') {
        console.error('Mockup image error:', msg.error);
        // Show fallback preview
        if (document.body.classList.contains('fs') && manualScreenEnabled) {
          const previewContent = document.getElementById('previewContent');
          previewContent.innerHTML = `
            <div style="
              width: 100%; 
              height: 100%; 
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              color: #888;
              font-size: 16px;
              text-align: center;
              gap: 20px;
            ">
              <div>‚ö†Ô∏è Could not load mockup preview</div>
              <div style="font-size: 14px;">
                Selected: ${selectedMockup ? selectedMockup.name : 'None'}<br>
                You can still apply the rotation
              </div>
            </div>
          `;
        }
      }

      if (msg.type === 'manual-screen-area-selected') {
        if (manualScreenEnabled) {
          setSelectedScreenArea({
            name: msg.name,
            width: msg.width,
            height: msg.height,
            x: msg.x,
            y: msg.y,
            transform: msg.transform,
            id: msg.id
          });
        }
      }
    };

    // Add slider event listeners
    document.getElementById('rotationSlider').addEventListener('input', (e) => {
      updateRotation(e.target.value);
    });

    document.getElementById('rotationXSlider').addEventListener('input', (e) => {
      updateRotationX(e.target.value);
    });

    document.getElementById('rotationYSlider').addEventListener('input', (e) => {
      updateRotationY(e.target.value);
    });

    // Add input field event listeners
    document.getElementById('rotationInput').addEventListener('input', (e) => {
      const value = Math.max(-180, Math.min(180, parseInt(e.target.value) || 0));
      e.target.value = value;
      document.getElementById('rotationSlider').value = value;
      updateRotation(value);
    });

    document.getElementById('rotationXInput').addEventListener('input', (e) => {
      const value = Math.max(-90, Math.min(90, parseInt(e.target.value) || 0));
      e.target.value = value;
      document.getElementById('rotationXSlider').value = value;
      updateRotationX(value);
    });

    document.getElementById('rotationYInput').addEventListener('input', (e) => {
      const value = Math.max(-90, Math.min(90, parseInt(e.target.value) || 0));
      e.target.value = value;
      document.getElementById('rotationYSlider').value = value;
      updateRotationY(value);
    });

    document.getElementById('useCanvasPreview').addEventListener('change', () => {
      updatePreview();
    });



    function showNotification(message, type) {
      const notification = document.createElement('div');
      notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 600;
    z-index: 1000;
    animation: slideIn 0.3s ease;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  `;

      if (type === 'success') {
        notification.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
        notification.style.color = '#fff';
        notification.textContent = '‚úì ' + message;
      } else if (type === 'info') {
        notification.style.background = 'linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%)';
        notification.style.color = '#fff';
        notification.textContent = '‚è≥ ' + message;
      } else {
        notification.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
        notification.style.color = '#fff';
        notification.textContent = '‚úó ' + message;
      }

      document.body.appendChild(notification);
      setTimeout(() => notification.remove(), 3000);
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      initTheme();

      // Load saved language
      currentLanguage = loadSavedLanguage();

      // Initialize all texts
      updateAllTexts();

      // Request license information first
      parent.postMessage({ pluginMessage: { type: 'get-license-info' } }, '*');

      // Auto-export after a short delay to ensure license info is loaded
      setTimeout(() => {
        parent.postMessage({ pluginMessage: { type: 'auto-export' } }, '*');
      }, 100);
    });

    // License functions
    function showLicenseModal() {
      showSubscriptionModal();
    }

    function showSubscriptionModal() {
      const modal = document.getElementById('subscriptionModal');
      if (modal) {
        updateSubscriptionModal();
        modal.classList.remove('hidden');
      }
    }

    function hideLicenseModal() {
      hideSubscriptionModal();
    }

    function hideSubscriptionModal() {
      const modal = document.getElementById('subscriptionModal');
      if (modal) {
        modal.classList.add('hidden');
      }
    }

    function updateSubscriptionModal() {
      const pack = (translations && translations[state.language]) || (translations && translations.en) || {};

      // Update modal title
      const title = document.getElementById('subModalTitle');
      if (title) title.textContent = pack.subscription_info_title || '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ';

      // Update status section
      const statusBadge = document.getElementById('subStatusBadge');
      const statusText = document.getElementById('subStatusText');
      const statusDescription = document.getElementById('subStatusDescription');
      const statusDetails = document.getElementById('subStatusDetails');

      // Update details section elements
      const subDetailsSection = document.getElementById('subDetailsSection');
      const subType = document.getElementById('subType');
      const subPurchaseDate = document.getElementById('subPurchaseDate');
      const subExpiryDate = document.getElementById('subExpiryDate');
      const subDaysLeft = document.getElementById('subDaysLeft');

      if (licenseInfo.isPro) {
        if (statusBadge) {
          statusBadge.className = 'status-badge pro';
        }
        if (statusText) statusText.textContent = 'PRO';
        if (statusDescription) statusDescription.textContent = pack.subscription_active || '–ê–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞';
        if (statusDetails) statusDetails.textContent = pack.subscription_unlimited || '–ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º';

        // Show details section for PRO users
        if (subDetailsSection) subDetailsSection.style.display = 'block';

        // Fill in subscription details
        if (licenseInfo.keyInfo) {
          const keyInfo = licenseInfo.keyInfo;

          // Subscription type
          if (subType) {
            let typeText = keyInfo.subscriptionType || 'Unknown';
            if (typeText === 'promo') typeText = '–ü—Ä–æ–º–æ (7 –¥–Ω–µ–π)';
            else if (typeText === 'monthly') typeText = '–ú–µ—Å—è—á–Ω–∞—è';
            else if (typeText === 'yearly') typeText = '–ì–æ–¥–æ–≤–∞—è';
            else if (typeText === 'lifetime') typeText = '–ü–æ–∂–∏–∑–Ω–µ–Ω–Ω–∞—è';
            subType.textContent = typeText;
          }

          // Purchase date
          if (subPurchaseDate && keyInfo.purchaseDate) {
            const purchaseDate = new Date(keyInfo.purchaseDate);
            subPurchaseDate.textContent = purchaseDate.toLocaleDateString('ru-RU');
          }

          // Expiry date and days left
          if (keyInfo.expirationDate) {
            const expiryDate = new Date(keyInfo.expirationDate);
            const now = new Date();
            const daysLeft = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));

            if (subExpiryDate) {
              subExpiryDate.textContent = expiryDate.toLocaleDateString('ru-RU');
            }
            if (subDaysLeft) {
              if (daysLeft > 0) {
                subDaysLeft.textContent = daysLeft.toString();
                subDaysLeft.style.color = daysLeft <= 3 ? '#ef4444' : '#374151';
              } else {
                subDaysLeft.textContent = '–ò—Å—Ç–µ–∫–ª–∞';
                subDaysLeft.style.color = '#ef4444';
              }
            }
          } else {
            // Lifetime subscription
            if (subExpiryDate) subExpiryDate.textContent = '–ù–∏–∫–æ–≥–¥–∞';
            if (subDaysLeft) {
              subDaysLeft.textContent = '‚àû';
              subDaysLeft.style.color = '#10b981';
            }
          }
        }
      } else {
        if (statusBadge) {
          statusBadge.className = 'status-badge free';
        }
        if (statusText) statusText.textContent = 'FREE';
        if (statusDescription) statusDescription.textContent = pack.subscription_free || '–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≤–µ—Ä—Å–∏—è';
        if (statusDetails) {
          const remaining = licenseInfo.remainingUses || 0;
          statusDetails.textContent = `${pack.subscription_limited || '–û–≥—Ä–∞–Ω–∏—á–µ–Ω–æ'}: ${remaining}/10 ${pack.license_remaining || '–æ—Å—Ç–∞–ª–æ—Å—å'}`;
        }

        // Hide details section for FREE users
        if (subDetailsSection) subDetailsSection.style.display = 'none';
      }

      // Update close button
      const closeBtn = document.getElementById('subModalCancel');
      if (closeBtn) closeBtn.textContent = pack.close || '–ó–∞–∫—Ä—ã—Ç—å';
    }

    function checkUsageLimit() {
      // Only check if we have valid license info (not initial state)
      if (licenseInfo.usageCount > 0 && !licenseInfo.isPro && licenseInfo.remainingUses <= 0) {
        showLicenseModal();
        return false;
      }
      return true;
    }

    function incrementUsage() {
      if (!licenseInfo.isPro) {
        licenseInfo.usageCount++;
        licenseInfo.remainingUses = Math.max(0, 10 - licenseInfo.usageCount);

        // Update UI immediately
        updateLicenseUI();

        // Send usage update to main thread
        parent.postMessage({
          pluginMessage: {
            type: 'update-usage',
            usageCount: licenseInfo.usageCount,
            remainingUses: licenseInfo.remainingUses
          }
        }, '*');
      }
    }

    // Debug function for testing license states
    function testLicenseState(remaining) {
      if (remaining === -1) {
        // Pro state
        licenseInfo.isPro = true;
        licenseInfo.remainingUses = -1;
        licenseInfo.usageCount = 0;
      } else {
        // Free state
        licenseInfo.isPro = false;
        licenseInfo.remainingUses = remaining;
        licenseInfo.usageCount = 10 - remaining;
      }
      updateLicenseUI();
    }

    // Force red banner
    function forceRedBanner() {
      const licenseInfo_el = document.getElementById('licenseInfo');
      const licenseStatusText = document.getElementById('licenseStatusText');
      const licenseDetailsText = document.getElementById('licenseDetailsText');
      const upgradeBtn = document.getElementById('upgradeBtn');

      if (licenseInfo_el) {
        licenseInfo_el.className = '';
        licenseInfo_el.classList.add('danger');
        licenseInfo_el.style.display = 'block';
      }
      if (licenseStatusText) licenseStatusText.textContent = '–õ–∏–º–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç–∏–≥–Ω—É—Ç';
      if (licenseDetailsText) licenseDetailsText.textContent = '–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ 10 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫. –ü–æ–ª—É—á–∏—Ç–µ Pro –≤–µ—Ä—Å–∏—é –¥–ª—è –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞.';
      if (upgradeBtn) upgradeBtn.style.display = 'block';
    }

    // Show debug buttons in development (remove in production)
    if (window.location.protocol === 'file:') {
      setTimeout(() => {
        const debugButtons = document.getElementById('debugButtons');
        if (debugButtons) debugButtons.style.display = 'block';
      }, 1000);
    }

    console.log('Image Rotation Studio loaded');
    console.log('html2canvas available:', typeof html2canvas !== 'undefined');

    // License Modal HTML and Event Listeners
    document.addEventListener('DOMContentLoaded', () => {
      // Create modal HTML first
      document.body.insertAdjacentHTML('beforeend', `
  <!-- License Modal -->
  <div id="licenseModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modalTitle">–õ–∏–º–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç–∏–≥–Ω—É—Ç</h3>
        <button id="modalClose" class="modal-close">√ó</button>
      </div>
      <div class="modal-body">
        <p id="modalMessage">–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ 10 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫. –ü–æ–ª—É—á–∏—Ç–µ Pro –≤–µ—Ä—Å–∏—é –¥–ª—è –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞.</p>
        <div class="modal-features">
          <div class="feature" id="modalFeature">‚ú® –ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–±–æ—Ç–æ–∫</div>
        </div>
        <div class="modal-price">
          <div class="price" id="modalPrice">$2.00 / month</div>
          <div class="price-note" id="modalPriceNote">or $19.99 / year (17% savings)</div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="buyProBtn" class="primary-button">–ö—É–ø–∏—Ç—å —á–µ—Ä–µ–∑ Telegram</button>
        <button id="getCodeBtn" class="button-secondary" style="margin-top: 8px;">
          <span id="getCodeBtnText">–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥ (–µ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∞)</span>
        </button>
        <button id="modalCancel" class="button-secondary" style="margin-top: 12px;">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </div>
  </div>
`);

      // Add event listeners after HTML is created
      setTimeout(() => {
        const modalClose = document.getElementById('modalClose');
        const modalCancel = document.getElementById('modalCancel');
        const buyProBtn = document.getElementById('buyProBtn');
        const getCodeBtn = document.getElementById('getCodeBtn');

        if (modalClose) {
          modalClose.addEventListener('click', hideLicenseModal);
          console.log('Modal close button listener added');
        }
        if (modalCancel) {
          modalCancel.addEventListener('click', hideLicenseModal);
          console.log('Modal cancel button listener added');
        }

        if (buyProBtn) {
          buyProBtn.addEventListener('click', () => {
            console.log('Buy Pro button clicked');
            parent.postMessage({ pluginMessage: { type: 'generate-challenge' } }, '*');
          });
          console.log('Buy Pro button listener added');
        }

        if (getCodeBtn) {
          getCodeBtn.addEventListener('click', () => {
            console.log('Get Code button clicked');
            parent.postMessage({ pluginMessage: { type: 'generate-recovery-challenge' } }, '*');
          });
          console.log('Get Code button listener added');
        }
      }, 100);

      // Initialize language switcher with saved language
      renderLanguageSwitcher();

      // Initialize license UI
      updateLicenseUI();

      // Status badge click handler
      const statusBadge = document.getElementById('statusBadge');
      if (statusBadge) {
        statusBadge.addEventListener('click', () => {
          // For now, show license modal (later will be subscription modal)
          showLicenseModal();
        });
      }



      // Language switcher events
      const langBtn = document.getElementById('languageSelected');
      if (langBtn) {
        langBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleLanguageDropdown();
        });
      }

      // Close dropdown on outside click
      document.addEventListener('click', (e) => {
        const switcher = document.getElementById('languageSwitcher');
        if (switcher && !switcher.contains(e.target)) {
          toggleLanguageDropdown(false);
        }
      });

      // Upgrade button click handler  
      setTimeout(() => {
        const upgradeBtn = document.getElementById('upgradeBtn');
        if (upgradeBtn) {
          upgradeBtn.addEventListener('click', () => {
            showLicenseModal();
          });
        }

        // Subscription modal event listeners
        const subModalClose = document.getElementById('subModalClose');
        const subModalCancel = document.getElementById('subModalCancel');
        const subUpgradeBtn = document.getElementById('subUpgradeBtn');
        const subRecoverBtn = document.getElementById('subRecoverBtn');
        const activateKeyBtn = document.getElementById('activateKeyBtn');

        if (subModalClose) {
          subModalClose.addEventListener('click', hideSubscriptionModal);
        }
        if (subModalCancel) {
          subModalCancel.addEventListener('click', hideSubscriptionModal);
        }
        if (subUpgradeBtn) {
          subUpgradeBtn.addEventListener('click', () => {
            console.log('Generate purchase challenge');
            parent.postMessage({ pluginMessage: { type: 'generate-challenge' } }, '*');
          });
        }
        if (subRecoverBtn) {
          subRecoverBtn.addEventListener('click', () => {
            console.log('Generate recovery challenge');
            parent.postMessage({ pluginMessage: { type: 'generate-recovery-challenge' } }, '*');
          });
        }
        if (activateKeyBtn) {
          console.log('‚úÖ Activate key button found, adding event listener');
          activateKeyBtn.addEventListener('click', () => {
            console.log('üîë Activate key button clicked');
            const keyInput = document.getElementById('activationKeyInput');
            const key = keyInput ? keyInput.value.trim() : '';
            console.log('Key from input:', key);
            if (key) {
              console.log('Activating key:', key);
              parent.postMessage({ pluginMessage: { type: 'activate-with-key', key: key } }, '*');
            } else {
              alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏');
            }
          });
        } else {
          console.log('‚ùå Activate key button NOT found');
        }

        // Close modal on outside click
        const subscriptionModal = document.getElementById('subscriptionModal');
        if (subscriptionModal) {
          subscriptionModal.addEventListener('click', (e) => {
            if (e.target === subscriptionModal) {
              hideSubscriptionModal();
            }
          });
        }
      }, 100);
    });

    // Fullscreen Mode Toggle
    let isFullscreen = false;
    
    document.getElementById('fullscreenToggle').addEventListener('click', () => {
      isFullscreen = !isFullscreen;
      
      if (isFullscreen) {
        // Enter fullscreen mode
        document.body.classList.add('fs');
        document.getElementById('fsLeft').classList.remove('hidden');
        document.getElementById('fsRight').classList.remove('hidden');
        document.getElementById('fsExitBtn').classList.remove('hidden');
        document.getElementById('fullscreenToggle').innerHTML = '‚Üô Exit Fullscreen';
        
        // Resize plugin window to fullscreen
        parent.postMessage({
          pluginMessage: {
            type: 'resize-window',
            width: Math.max(1200, window.screen.width * 0.9),
            height: Math.max(800, window.screen.height * 0.9)
          }
        }, '*');
        
      } else {
        // Exit fullscreen mode
        document.body.classList.remove('fs');
        document.getElementById('fsLeft').classList.add('hidden');
        document.getElementById('fsRight').classList.add('hidden');
        document.getElementById('fsExitBtn').classList.add('hidden');
        document.getElementById('fullscreenToggle').innerHTML = 'üì± Open Fullscreen Mode';
        
        // Resize plugin window back to normal
        parent.postMessage({
          pluginMessage: {
            type: 'resize-window',
            width: 400,
            height: 800
          }
        }, '*');
      }
    });

    // Fullscreen rotation controls (only for image inside screen area)
    function updateFullscreenRotation() {
      const newRotationX = parseFloat(document.getElementById('fsRotationX').value);
      const newRotationY = parseFloat(document.getElementById('fsRotationY').value);
      const newRotationZ = parseFloat(document.getElementById('fsRotationZ').value);
      
      // Update fullscreen display values
      document.getElementById('fsRotationXValue').textContent = newRotationX + '¬∞';
      document.getElementById('fsRotationYValue').textContent = newRotationY + '¬∞';
      document.getElementById('fsRotationZValue').textContent = newRotationZ + '¬∞';
      
      // Update global variables (these affect only the image, not the mockup)
      rotationX = newRotationX;
      rotationY = newRotationY;
      rotationAngle = newRotationZ;
      
      // Update main controls
      if (document.getElementById('rotationSlider')) {
        document.getElementById('rotationSlider').value = newRotationZ;
        document.getElementById('rotationInput').value = newRotationZ;
        document.getElementById('rotationValue').textContent = newRotationZ + '¬∞';
      }
      
      if (document.getElementById('rotationXSlider')) {
        document.getElementById('rotationXSlider').value = newRotationX;
        document.getElementById('rotationXInput').value = newRotationX;
        document.getElementById('rotationXValue').textContent = newRotationX + '¬∞';
      }
      
      if (document.getElementById('rotationYSlider')) {
        document.getElementById('rotationYSlider').value = newRotationY;
        document.getElementById('rotationYInput').value = newRotationY;
        document.getElementById('rotationYValue').textContent = newRotationY + '¬∞';
      }
      
      // Update preview (only image rotation, mockup stays static)
      updatePreview();
    }

    function setFullscreenPreset(x, y, z) {
      document.getElementById('fsRotationX').value = x;
      document.getElementById('fsRotationY').value = y;
      document.getElementById('fsRotationZ').value = z;
      updateFullscreenRotation();
    }

    // Fullscreen Manual Mode functions
    function selectMockupForManual() {
      selectMockupStep1();
    }

    function selectScreenAreaForManual() {
      selectScreenAreaStep2();
    }

    function applyManualInsert() {
      manualInsert();
    }

    // Update Manual Screen preview to show how image will look in selected area
    function updateManualScreenPreview() {
      if (!manualScreenEnabled || !selectedMockup || !selectedScreenArea || !currentImage) {
        return;
      }

      const previewContent = document.getElementById('previewContent');
      if (!previewContent) return;

      // Create Manual Screen preview container
      const manualPreview = document.createElement('div');
      manualPreview.className = 'manual-screen-preview';
      manualPreview.style.cssText = `
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: ${document.body.classList.contains('fs') ? '#2a2a2a' : '#f8f9fa'};
        border-radius: 8px;
        border: 2px solid #10b981;
      `;

      // Calculate preview scale
      const previewContainer = document.getElementById('imagePreview');
      const containerWidth = previewContainer.offsetWidth * 0.9;
      const containerHeight = previewContainer.offsetHeight * 0.9;

      // Use screen area dimensions for preview scale
      const previewScale = Math.min(
        containerWidth / selectedScreenArea.width,
        containerHeight / selectedScreenArea.height
      ) * (document.body.classList.contains('fs') ? 0.6 : 0.8);

      // Create screen area representation
      const screenAreaDiv = document.createElement('div');
      screenAreaDiv.style.cssText = `
        position: relative;
        width: ${selectedScreenArea.width * previewScale}px;
        height: ${selectedScreenArea.height * previewScale}px;
        border: 2px dashed #10b981;
        background: rgba(16, 185, 129, 0.1);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      `;

      // Add content image with rotation including mockup perspective
      const contentImg = document.createElement('img');
      contentImg.src = currentImage.src;

      // Combine image rotation with mockup perspective
      const totalRotationX = rotationX + (mockupTiltX || 0);
      const totalRotationY = rotationY + (mockupTiltY || 0);
      const totalRotationZ = rotationAngle + (mockupTiltZ || 0);

      // Apply rotation and fit to screen area
      const shadowIntensity = (Math.abs(totalRotationX) + Math.abs(totalRotationY)) / 180;
      contentImg.style.cssText = `
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: rotateX(${totalRotationX}deg) rotateY(${totalRotationY}deg) rotateZ(${totalRotationZ}deg);
        transform-style: preserve-3d;
        filter: drop-shadow(${Math.sin((totalRotationY * Math.PI) / 180) * 3}px ${Math.sin((totalRotationX * Math.PI) / 180) * 3}px ${3 + shadowIntensity * 3}px rgba(0,0,0,${0.3 * shadowIntensity}));
      `;

      screenAreaDiv.appendChild(contentImg);

      // Add label
      const label = document.createElement('div');
      label.style.cssText = `
        position: absolute;
        bottom: -25px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        color: #10b981;
        font-weight: 600;
        background: rgba(16, 185, 129, 0.1);
        padding: 2px 6px;
        border-radius: 4px;
        white-space: nowrap;
      `;
      label.textContent = `Preview: ${selectedScreenArea.name}`;

      manualPreview.appendChild(screenAreaDiv);
      manualPreview.appendChild(label);

      // Replace preview content
      previewContent.innerHTML = '';
      previewContent.appendChild(manualPreview);
    }

    // Create preview with real mockup image for fullscreen mode
    function createRealMockupPreview() {
      const previewContent = document.getElementById('previewContent');
      
      const container = document.createElement('div');
      container.style.cssText = `
        width: 100%; 
        height: 100%; 
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        background: #2a2a2a;
      `;

      // Create mockup container (static, no transforms)
      const mockupContainer = document.createElement('div');
      mockupContainer.style.cssText = `
        position: relative;
        display: inline-block;
        isolation: isolate;
      `;

      // Create mockup image (static, no rotation from regular controls)
      const mockupImg = document.createElement('img');
      mockupImg.src = selectedMockup.imageData;
      
      // Calculate proper size to maintain aspect ratio
      const maxWidth = 600;
      const maxHeight = 800;
      const aspectRatio = selectedMockup.width / selectedMockup.height;
      
      let displayWidth, displayHeight;
      if (aspectRatio > maxWidth / maxHeight) {
        displayWidth = maxWidth;
        displayHeight = maxWidth / aspectRatio;
      } else {
        displayHeight = maxHeight;
        displayWidth = maxHeight * aspectRatio;
      }
      
      mockupImg.style.cssText = `
        width: ${displayWidth}px;
        height: ${displayHeight}px;
        box-shadow: 0 25px 80px rgba(0,0,0,0.3);
        border-radius: 8px;
        display: block;
        position: relative;
        z-index: 1;
      `;

      mockupContainer.appendChild(mockupImg);

      // Use setTimeout to ensure image is loaded and has dimensions
      setTimeout(() => {
        // If screen area is selected, create screen area container
        if (selectedScreenArea && currentImage) {
          // Calculate screen area position relative to mockup
          const imgWidth = mockupImg.offsetWidth || mockupImg.naturalWidth || 600;
          const imgHeight = mockupImg.offsetHeight || mockupImg.naturalHeight || 800;
          
          // Use uniform scaling to match Figma's behavior
          const scale = Math.min(imgWidth / selectedMockup.width, imgHeight / selectedMockup.height);
          const scaleX = scale;
          const scaleY = scale;
          
          // Create screen area container (this clips the content)
          const screenAreaDiv = document.createElement('div');
          screenAreaDiv.style.cssText = `
            position: absolute;
            left: ${selectedScreenArea.x * scaleX}px;
            top: ${selectedScreenArea.y * scaleY}px;
            width: ${selectedScreenArea.width * scaleX}px;
            height: ${selectedScreenArea.height * scaleY}px;
            overflow: hidden;
            z-index: 2;
            clip-path: inset(0);
            contain: layout style paint;
          `;
          
          // Create content image inside screen area
          const contentImg = document.createElement('img');
          contentImg.src = currentImage.src;
          contentImg.className = 'fs-content-image';
          
          // Combine regular rotation with mockup perspective
          const totalRotationX = rotationX + (mockupTiltX || 0);
          const totalRotationY = rotationY + (mockupTiltY || 0);
          const totalRotationZ = rotationAngle + (mockupTiltZ || 0);
          
          contentImg.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: 
              rotateX(${totalRotationX}deg) 
              rotateY(${totalRotationY}deg) 
              rotateZ(${totalRotationZ}deg);
            transform-style: preserve-3d;
            transform-origin: center center;
            display: block;
            transition: transform 0.1s ease;
          `;
          
          screenAreaDiv.appendChild(contentImg);
          mockupContainer.appendChild(screenAreaDiv);
        }
      }, 100);

      container.appendChild(mockupContainer);

      // Add status indicators
      const statusDiv = document.createElement('div');
      statusDiv.style.cssText = `
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #888;
        font-size: 14px;
        text-align: center;
        white-space: nowrap;
        background: rgba(0,0,0,0.7);
        padding: 8px 16px;
        border-radius: 20px;
      `;
      
      let status = '';
      if (!selectedMockup) status += 'üì± Select Mockup ‚Ä¢ ';
      if (!selectedScreenArea) status += 'üì∫ Select Screen ‚Ä¢ ';
      if (!currentImage) status += 'üñºÔ∏è Select Image ‚Ä¢ ';
      if (status === '') status = '‚úÖ Ready to Apply';
      else status = status.slice(0, -3); // Remove last " ‚Ä¢ "
      
      statusDiv.textContent = status;
      container.appendChild(statusDiv);
      
      previewContent.innerHTML = '';
      previewContent.appendChild(container);
    }

    // Fullscreen zoom and pan functionality
    let fsZoom = 1;
    let fsPanX = 0;
    let fsPanY = 0;
    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    function initFullscreenControls() {
      const preview = document.getElementById('imagePreview');
      const previewContent = document.getElementById('previewContent');
      
      if (!preview || !previewContent) return;

      // Mouse wheel zoom
      preview.addEventListener('wheel', (e) => {
        if (!document.body.classList.contains('fs')) return;
        
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        fsZoom = Math.max(0.1, Math.min(5, fsZoom * delta));
        updatePreviewTransform();
      });

      // Mouse pan
      preview.addEventListener('mousedown', (e) => {
        if (!document.body.classList.contains('fs')) return;
        
        isPanning = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        preview.style.cursor = 'grabbing';
      });

      document.addEventListener('mousemove', (e) => {
        if (!isPanning || !document.body.classList.contains('fs')) return;
        
        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;
        
        fsPanX += deltaX;
        fsPanY += deltaY;
        
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        
        updatePreviewTransform();
      });

      document.addEventListener('mouseup', () => {
        isPanning = false;
        const preview = document.getElementById('imagePreview');
        if (preview) preview.style.cursor = 'grab';
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (!document.body.classList.contains('fs')) return;
        
        switch(e.key) {
          case '=':
          case '+':
            e.preventDefault();
            fsZoom = Math.min(5, fsZoom * 1.2);
            updatePreviewTransform();
            break;
          case '-':
            e.preventDefault();
            fsZoom = Math.max(0.1, fsZoom * 0.8);
            updatePreviewTransform();
            break;
          case '0':
            e.preventDefault();
            fsZoom = 1;
            fsPanX = 0;
            fsPanY = 0;
            updatePreviewTransform();
            break;
        }
      });
    }

    function updatePreviewTransform() {
      const previewContent = document.getElementById('previewContent');
      if (previewContent && document.body.classList.contains('fs')) {
        previewContent.style.transform = `scale(${fsZoom}) translate(${fsPanX/fsZoom}px, ${fsPanY/fsZoom}px)`;
      }
    }

    // Initialize controls when page loads
    document.addEventListener('DOMContentLoaded', initFullscreenControls);

    // Update existing content image transform without recreating
    function updateExistingContentImage(contentImg) {
      if (!contentImg) return;
      
      // Combine regular rotation with mockup perspective
      const totalRotationX = rotationX + (mockupTiltX || 0);
      const totalRotationY = rotationY + (mockupTiltY || 0);
      const totalRotationZ = rotationAngle + (mockupTiltZ || 0);
      
      contentImg.style.transform = `
        rotateX(${totalRotationX}deg) 
        rotateY(${totalRotationY}deg) 
        rotateZ(${totalRotationZ}deg)
      `;
    }

    // Fullscreen mode variables (declared elsewhere)

    // Toggle fullscreen mode
    function toggleFullscreen() {
      const body = document.body;
      const fsLeft = document.getElementById('fsLeft');
      const fsRight = document.getElementById('fsRight');
      const fsExitBtn = document.getElementById('fsExitBtn');
      const fullscreenToggle = document.getElementById('fullscreenToggle');

      if (body.classList.contains('fs')) {
        // Exit fullscreen
        body.classList.remove('fs');
        if (fsLeft) fsLeft.classList.add('hidden');
        if (fsRight) fsRight.classList.add('hidden');
        if (fsExitBtn) fsExitBtn.classList.add('hidden');
        if (fullscreenToggle) fullscreenToggle.textContent = 'üì± Open Fullscreen Mode';
        
        // Sync values back to main controls
        syncFromFullscreenControls();
        
        // Update regular preview
        updatePreview();
      } else {
        // Enter fullscreen
        body.classList.add('fs');
        if (fsLeft) fsLeft.classList.remove('hidden');
        if (fsRight) fsRight.classList.remove('hidden');
        if (fsExitBtn) fsExitBtn.classList.remove('hidden');
        if (fullscreenToggle) fullscreenToggle.textContent = 'üì± Exit Fullscreen Mode';
        
        // Sync values to fullscreen controls
        syncToFullscreenControls();
        
        // Update fullscreen preview
        updateFullscreenPreview();
      }
    }

    // Sync values from main controls to fullscreen controls
    function syncToFullscreenControls() {
      // Rotation controls
      const fsRotationZ = document.getElementById('fsRotationZ');
      const fsRotationX = document.getElementById('fsRotationX');
      const fsRotationY = document.getElementById('fsRotationY');
      const fsRotationZSlider = document.getElementById('fsRotationZSlider');
      const fsRotationXSlider = document.getElementById('fsRotationXSlider');
      const fsRotationYSlider = document.getElementById('fsRotationYSlider');

      if (fsRotationZ) fsRotationZ.value = rotationAngle;
      if (fsRotationX) fsRotationX.value = rotationX;
      if (fsRotationY) fsRotationY.value = rotationY;
      if (fsRotationZSlider) fsRotationZSlider.value = rotationAngle;
      if (fsRotationXSlider) fsRotationXSlider.value = rotationX;
      if (fsRotationYSlider) fsRotationYSlider.value = rotationY;

      // Manual mode
      const fsManualScreenMode = document.getElementById('fsManualScreenMode');
      if (fsManualScreenMode) fsManualScreenMode.checked = manualScreenEnabled;

      updateFullscreenRotationLabels();
    }

    // Sync values from fullscreen controls back to main controls
    function syncFromFullscreenControls() {
      // Update main rotation controls
      document.getElementById('rotationSlider').value = rotationAngle;
      document.getElementById('rotationXSlider').value = rotationX;
      document.getElementById('rotationYSlider').value = rotationY;
      document.getElementById('rotationInput').value = rotationAngle;
      document.getElementById('rotationXInput').value = rotationX;
      document.getElementById('rotationYInput').value = rotationY;
      document.getElementById('rotationValue').textContent = rotationAngle + '¬∞';
      document.getElementById('rotationXValue').textContent = rotationX + '¬∞';
      document.getElementById('rotationYValue').textContent = rotationY + '¬∞';

      // Update manual mode
      const manualScreenMode = document.getElementById('manualScreenMode');
      if (manualScreenMode) manualScreenMode.checked = manualScreenEnabled;
    }

    // Update fullscreen rotation from controls
    function updateFullscreenRotation() {
      const fsRotationZ = document.getElementById('fsRotationZ');
      const fsRotationX = document.getElementById('fsRotationX');
      const fsRotationY = document.getElementById('fsRotationY');

      if (fsRotationZ) rotationAngle = parseInt(fsRotationZ.value) || 0;
      if (fsRotationX) rotationX = parseInt(fsRotationX.value) || 0;
      if (fsRotationY) rotationY = parseInt(fsRotationY.value) || 0;

      updateFullscreenRotationLabels();
      updateFullscreenPreview();
    }

    // Update fullscreen rotation labels
    function updateFullscreenRotationLabels() {
      const fsRotationZValue = document.getElementById('fsRotationZValue');
      const fsRotationXValue = document.getElementById('fsRotationXValue');
      const fsRotationYValue = document.getElementById('fsRotationYValue');

      if (fsRotationZValue) fsRotationZValue.textContent = rotationAngle + '¬∞';
      if (fsRotationXValue) fsRotationXValue.textContent = rotationX + '¬∞';
      if (fsRotationYValue) fsRotationYValue.textContent = rotationY + '¬∞';
    }

    // Set fullscreen preset
    function setFullscreenPreset(x, y, z) {
      rotationX = x;
      rotationY = y;
      rotationAngle = z;

      // Update fullscreen controls
      const fsRotationZ = document.getElementById('fsRotationZ');
      const fsRotationX = document.getElementById('fsRotationX');
      const fsRotationY = document.getElementById('fsRotationY');
      const fsRotationZSlider = document.getElementById('fsRotationZSlider');
      const fsRotationXSlider = document.getElementById('fsRotationXSlider');
      const fsRotationYSlider = document.getElementById('fsRotationYSlider');

      if (fsRotationZ) fsRotationZ.value = z;
      if (fsRotationX) fsRotationX.value = x;
      if (fsRotationY) fsRotationY.value = y;
      if (fsRotationZSlider) fsRotationZSlider.value = z;
      if (fsRotationXSlider) fsRotationXSlider.value = x;
      if (fsRotationYSlider) fsRotationYSlider.value = y;

      updateFullscreenRotationLabels();
      updateFullscreenPreview();
    }

    // Update preview transform (for zoom/pan)
    function updatePreviewTransform() {
      const previewContent = document.getElementById('previewContent');
      if (previewContent && document.body.classList.contains('fs')) {
        previewContent.style.transform = `scale(${fsZoom}) translate(${fsPanX}px, ${fsPanY}px)`;
      }
    }

    // Manual mode functions for fullscreen
    function selectMockupForManual() {
      selectMockupStep1();
    }

    function selectScreenAreaForManual() {
      selectScreenAreaStep2();
    }

    function applyManualInsert() {
      manualInsert();
    }

    function applyRotation() {
      applyToOriginal();
    }

    function copyRotationData() {
      copyRotation();
    }

    // Update preview in fullscreen mode
    function updateFullscreenPreview() {
      const previewContent = document.getElementById('previewContent');
      
      if (manualScreenEnabled) {
        // Check if we need to recreate or just update existing image
        const existingImg = previewContent.querySelector('.fs-content-image');
        if (existingImg && selectedMockup && selectedScreenArea && currentImage) {
          // Just update the transform of existing image
          updateExistingContentImage(existingImg);
        } else {
          // Create new preview
          createFullscreenManualPreview();
        }
        return;
      }
      
      if (currentImage) {
        // Create large preview for fullscreen mode
        const container = document.createElement('div');
        container.style.cssText = `
          width: 100%; 
          height: 100%; 
          display: flex;
          align-items: center;
          justify-content: center;
          position: relative;
          background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        `;

        const img = document.createElement('img');
        img.src = currentImage.src;
        img.style.cssText = `
          max-width: 60%;
          max-height: 60%;
          transform: 
            rotateX(${rotationX}deg) 
            rotateY(${rotationY}deg) 
            rotateZ(${rotationAngle}deg);
          transform-style: preserve-3d;
          border-radius: 12px;
          box-shadow: 0 20px 60px rgba(0,0,0,0.4);
          transition: transform 0.1s ease;
        `;

        container.appendChild(img);
        previewContent.innerHTML = '';
        previewContent.appendChild(container);
      } else {
        previewContent.innerHTML = '<div style="color:#888; text-align:center; padding:60px; font-size:18px;">üì± Select an image to rotate</div>';
      }
    }

    // Create manual preview for fullscreen mode
    function createFullscreenManualPreview() {
      const previewContent = document.getElementById('previewContent');
      
      if (selectedMockup && selectedMockup.imageData) {
        // Show real mockup from Figma
        createRealMockupPreview();
      } else if (selectedMockup) {
        // Request mockup image from Figma
        parent.postMessage({
          pluginMessage: {
            type: 'get-mockup-image',
            mockupData: selectedMockup
          }
        }, '*');
        
        // Show loading state
        previewContent.innerHTML = `
          <div style="
            width: 100%; 
            height: 100%; 
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 18px;
          ">
            üì± Loading mockup preview...
          </div>
        `;
      } else {
        // Show selection state
        previewContent.innerHTML = `
          <div style="
            width: 100%; 
            height: 100%; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 16px;
            text-align: center;
            gap: 20px;
          ">
            <div>üì± Manual Mode Active</div>
            <div style="font-size: 14px;">
              1. Select Mockup<br>
              2. Select Screen Area<br>
              3. Choose Image
            </div>
          </div>
        `;
      }
    }

    // Create preview with real mockup image
    function createRealMockupPreview() {
      const previewContent = document.getElementById('previewContent');
      
      const container = document.createElement('div');
      container.style.cssText = `
        width: 100%; 
        height: 100%; 
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      `;

      // Create mockup container (static, no transforms)
      const mockupContainer = document.createElement('div');
      mockupContainer.style.cssText = `
        position: relative;
        display: inline-block;
        isolation: isolate;
      `;

      // Create mockup image (static, no rotation from regular controls)
      const mockupImg = document.createElement('img');
      mockupImg.src = selectedMockup.imageData;
      
      // Calculate proper size to maintain aspect ratio
      const maxWidth = 600;
      const maxHeight = 800;
      const aspectRatio = selectedMockup.width / selectedMockup.height;
      
      let displayWidth, displayHeight;
      if (aspectRatio > maxWidth / maxHeight) {
        displayWidth = maxWidth;
        displayHeight = maxWidth / aspectRatio;
      } else {
        displayHeight = maxHeight;
        displayWidth = maxHeight * aspectRatio;
      }
      
      mockupImg.style.cssText = `
        width: ${displayWidth}px;
        height: ${displayHeight}px;
        box-shadow: 0 25px 80px rgba(0,0,0,0.3);
        border-radius: 8px;
        display: block;
        position: relative;
        z-index: 1;
      `;
      
      console.log('Mockup image sizing:', {
        originalWidth: selectedMockup.width,
        originalHeight: selectedMockup.height,
        displayWidth, displayHeight,
        aspectRatio
      });

      mockupContainer.appendChild(mockupImg);

      // Add image to container first
      mockupContainer.appendChild(mockupImg);

      // Use setTimeout to ensure image is loaded and has dimensions
      setTimeout(() => {
        // If screen area is selected, create screen area container
        if (selectedScreenArea && currentImage) {
          console.log('Creating screen area with:', {
            selectedScreenArea,
            mockupWidth: selectedMockup.width,
            mockupHeight: selectedMockup.height,
            imgWidth: mockupImg.offsetWidth || mockupImg.naturalWidth,
            imgHeight: mockupImg.offsetHeight || mockupImg.naturalHeight
          });
          
          // Calculate screen area position relative to mockup
          // IMPORTANT: Use the same scaling logic as in Figma
          const imgWidth = mockupImg.offsetWidth || mockupImg.naturalWidth || 600;
          const imgHeight = mockupImg.offsetHeight || mockupImg.naturalHeight || 800;
          
          // Use uniform scaling to match Figma's behavior
          const scale = Math.min(imgWidth / selectedMockup.width, imgHeight / selectedMockup.height);
          const scaleX = scale;
          const scaleY = scale;
          
          console.log('Scaling calculation:', {
            imgWidth, imgHeight,
            mockupWidth: selectedMockup.width,
            mockupHeight: selectedMockup.height,
            scale, scaleX, scaleY
          });
          
          // Create screen area container (this clips the content)
          const screenAreaDiv = document.createElement('div');
          screenAreaDiv.style.cssText = `
            position: absolute;
            left: ${selectedScreenArea.x * scaleX}px;
            top: ${selectedScreenArea.y * scaleY}px;
            width: ${selectedScreenArea.width * scaleX}px;
            height: ${selectedScreenArea.height * scaleY}px;
            overflow: hidden;
            z-index: 2;
            clip-path: inset(0);
            contain: layout style paint;
          `;
          
          console.log('Screen area positioned at:', {
            left: selectedScreenArea.x * scaleX,
            top: selectedScreenArea.y * scaleY,
            width: selectedScreenArea.width * scaleX,
            height: selectedScreenArea.height * scaleY,
            scaleX, scaleY
          });
          
          // Create content image inside screen area
          const contentImg = document.createElement('img');
          contentImg.src = currentImage.src;
          contentImg.className = 'fs-content-image';
          
          // Combine regular rotation with mockup perspective
          const totalRotationX = rotationX + (mockupTiltX || 0);
          const totalRotationY = rotationY + (mockupTiltY || 0);
          const totalRotationZ = rotationAngle + (mockupTiltZ || 0);
          
          contentImg.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: 
              rotateX(${totalRotationX}deg) 
              rotateY(${totalRotationY}deg) 
              rotateZ(${totalRotationZ}deg);
            transform-style: preserve-3d;
            transform-origin: center center;
            display: block;
            transition: transform 0.1s ease;
          `;
          
          console.log('Image transform:', {
            rotationX, rotationY, rotationAngle,
            mockupTiltX, mockupTiltY, mockupTiltZ,
            totalRotationX, totalRotationY, totalRotationZ,
            imageSrc: currentImage.src
          });
          
          screenAreaDiv.appendChild(contentImg);
          mockupContainer.appendChild(screenAreaDiv);
        }
      }, 100);

      container.appendChild(mockupContainer);

      // Add status indicators
      const statusDiv = document.createElement('div');
      statusDiv.style.cssText = `
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #888;
        font-size: 14px;
        text-align: center;
        white-space: nowrap;
        background: rgba(0,0,0,0.7);
        padding: 8px 16px;
        border-radius: 20px;
      `;
      
      let status = '';
      if (!selectedMockup) status += 'üì± Select Mockup ‚Ä¢ ';
      if (!selectedScreenArea) status += 'üì∫ Select Screen ‚Ä¢ ';
      if (!currentImage) status += 'üñºÔ∏è Select Image ‚Ä¢ ';
      if (status === '') status = '‚úÖ Ready to Apply';
      else status = status.slice(0, -3); // Remove last " ‚Ä¢ "
      
      statusDiv.textContent = status;
      container.appendChild(statusDiv);
      
      previewContent.innerHTML = '';
      previewContent.appendChild(container);
    }

    // Update Mockup Perspective in fullscreen left panel (only affects mockup orientation)
    function updateFsMockupPerspective() {
      const x = parseFloat(document.getElementById('fsMockupX').value);
      const y = parseFloat(document.getElementById('fsMockupY').value);
      const z = parseFloat(document.getElementById('fsMockupZ').value);
      
      // Update display values
      document.getElementById('fsMockupXValue').textContent = x + '¬∞';
      document.getElementById('fsMockupYValue').textContent = y + '¬∞';
      document.getElementById('fsMockupZValue').textContent = z + '¬∞';
      
      // Update global variables (these affect only the mockup orientation)
      mockupTiltX = x;
      mockupTiltY = y;
      mockupTiltZ = z;
      
      // Sync with main controls
      if (document.getElementById('mockupTiltXSlider')) {
        document.getElementById('mockupTiltXSlider').value = x;
        document.getElementById('mockupTiltXInput').value = x;
        document.getElementById('mockupTiltXValue').textContent = x + '¬∞';
        
        document.getElementById('mockupTiltYSlider').value = y;
        document.getElementById('mockupTiltYInput').value = y;
        document.getElementById('mockupTiltYValue').textContent = y + '¬∞';
        
        document.getElementById('mockupTiltZSlider').value = z;
        document.getElementById('mockupTiltZInput').value = z;
        document.getElementById('mockupTiltZValue').textContent = z + '¬∞';
      }
      
      // Update preview (only mockup perspective, image rotation stays separate)
      updatePreview();
    }

    // ===== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –ü–õ–ê–ì–ò–ù–ê =====

    // Export rotated image (–£–î–ê–õ–ï–ù–ê - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–µ—Ä–≤–∞—è –≤–µ—Ä—Å–∏—è –≤—ã—à–µ)
    async function exportRotatedImageOLD() {
      if (!currentImage) {
        showNotification('No image selected', 'error');
        return null;
      }

      try {
        // Create canvas for export
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Calculate canvas size based on rotation
        const radZ = (rotationAngle * Math.PI) / 180;
        const radX = (rotationX * Math.PI) / 180;
        const radY = (rotationY * Math.PI) / 180;

        // Calculate bounding box for rotated image
        const imgWidth = currentImage.width;
        const imgHeight = currentImage.height;

        // For 3D rotations, we need to account for perspective
        const perspective = 800;
        let scaleX = 1, scaleY = 1;

        if (rotationX !== 0) {
          scaleY = Math.cos(radX);
        }
        if (rotationY !== 0) {
          scaleX = Math.cos(radY);
        }

        // Calculate rotated corners for Z rotation
        const corners = [
          [-imgWidth/2, -imgHeight/2],
          [imgWidth/2, -imgHeight/2],
          [imgWidth/2, imgHeight/2],
          [-imgWidth/2, imgHeight/2]
        ];

        const rotatedCorners = corners.map(([x, y]) => [
          x * Math.cos(radZ) - y * Math.sin(radZ),
          x * Math.sin(radZ) + y * Math.cos(radZ)
        ]);

        const minX = Math.min(...rotatedCorners.map(([x]) => x));
        const maxX = Math.max(...rotatedCorners.map(([x]) => x));
        const minY = Math.min(...rotatedCorners.map(([, y]) => y));
        const maxY = Math.max(...rotatedCorners.map(([, y]) => y));

        let canvasWidth = Math.ceil((maxX - minX) * Math.abs(scaleX)) + 40;
        let canvasHeight = Math.ceil((maxY - minY) * Math.abs(scaleY)) + 40;

        // Limit canvas size to prevent "Image too large" error
        const maxSize = 4096; // Figma's limit
        if (canvasWidth > maxSize || canvasHeight > maxSize) {
          const scale = Math.min(maxSize / canvasWidth, maxSize / canvasHeight);
          canvasWidth = Math.floor(canvasWidth * scale);
          canvasHeight = Math.floor(canvasHeight * scale);
        }

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // Clear canvas
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // Move to center
        ctx.save();
        ctx.translate(canvasWidth / 2, canvasHeight / 2);

        // Apply rotations in correct order
        if (rotationAngle !== 0) {
          ctx.rotate(radZ);
        }

        // Apply 3D perspective effects (improved to match CSS)
        if (rotationX !== 0) {
          const cosX = Math.cos(radX);
          const sinX = Math.sin(radX);
          // Reduce the perspective effect to match CSS better
          ctx.transform(1, sinX * 0.15, 0, cosX, 0, 0);
        }

        if (rotationY !== 0) {
          const cosY = Math.cos(radY);
          const sinY = Math.sin(radY);
          // Reduce the perspective effect to match CSS better
          ctx.transform(cosY, 0, sinY * 0.15, 1, 0, 0);
        }

        // Add shadow for 3D effects
        if (rotationX !== 0 || rotationY !== 0) {
          const shadowIntensity = (Math.abs(rotationX) + Math.abs(rotationY)) / 180;
          ctx.shadowColor = `rgba(0,0,0,${0.3 * shadowIntensity})`;
          ctx.shadowBlur = 10 + shadowIntensity * 10;
          ctx.shadowOffsetX = Math.sin(radY) * 10;
          ctx.shadowOffsetY = Math.sin(radX) * 10;
        }

        // Draw image
        ctx.drawImage(currentImage, -imgWidth / 2, -imgHeight / 2);
        ctx.restore();

        return {
          imageData: canvas.toDataURL('image/png'),
          canvasWidth: canvasWidth,
          canvasHeight: canvasHeight
        };
      } catch (error) {
        console.error('Export error:', error);
        showNotification('Export failed', 'error');
        return null;
      }
    }

    // Apply rotation to original
    async function applyToOriginal() {
      // Check license before processing
      if (!checkUsageLimit()) {
        return;
      }

      const result = await exportRotatedImage();
      const keepSize = document.getElementById('keepOriginalSize').checked;
      const hasRotation = rotationX !== 0 || rotationY !== 0 || rotationAngle !== 0;

      if (result) {
        const imageData = typeof result === 'string' ? result : result.imageData;
        const canvasWidth = typeof result === 'object' ? result.canvasWidth : null;
        const canvasHeight = typeof result === 'object' ? result.canvasHeight : null;

        parent.postMessage({
          pluginMessage: {
            type: 'apply-rotation',
            imageData: imageData,
            isOriginal: true,
            keepOriginalSize: keepSize,
            hasRotation: hasRotation,
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight,
            rotation: {
              x: rotationX,
              y: rotationY,
              z: rotationAngle
            }
          }
        }, '*');

        // Increment usage after successful operation
        incrementUsage();
      }
    }

    // Create rotated copy
    async function createCopy() {
      // Check license before processing
      if (!checkUsageLimit()) {
        return;
      }

      const result = await exportRotatedImage();
      const keepSize = document.getElementById('keepOriginalSize').checked;
      const hasRotation = rotationX !== 0 || rotationY !== 0 || rotationAngle !== 0;

      if (result) {
        const imageData = typeof result === 'string' ? result : result.imageData;
        const canvasWidth = typeof result === 'object' ? result.canvasWidth : null;
        const canvasHeight = typeof result === 'object' ? result.canvasHeight : null;
        
        parent.postMessage({
          pluginMessage: {
            type: 'apply-rotation',
            imageData: imageData,
            isOriginal: false,
            keepOriginalSize: keepSize,
            hasRotation: hasRotation,
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight,
            rotation: {
              x: rotationX,
              y: rotationY,
              z: rotationAngle
            }
          }
        }, '*');

        // Increment usage after successful operation
        incrementUsage();
      }
    }

    // Check usage limit
    function checkUsageLimit() {
      if (!licenseInfo.isPro && licenseInfo.remainingUses <= 0) {
        showLicenseModal();
        return false;
      }
      return true;
    }

    // Increment usage counter
    function incrementUsage() {
      if (!licenseInfo.isPro) {
        licenseInfo.usageCount++;
        licenseInfo.remainingUses = Math.max(0, 10 - licenseInfo.usageCount);
        updateLicenseUI();
      }
    }

    // Load image function
    function loadImage(dataUrl, width, height, name, detectedRotation) {
      const img = new Image();
      img.onload = () => {
        currentImage = img;
        
        // Apply detected rotation if available
        if (detectedRotation && (detectedRotation.z !== 0 || detectedRotation.x !== 0 || detectedRotation.y !== 0)) {
          rotationAngle = detectedRotation.z || 0;
          rotationX = detectedRotation.x || 0;
          rotationY = detectedRotation.y || 0;
          
          // Update UI controls
          document.getElementById('rotationSlider').value = rotationAngle;
          document.getElementById('rotationXSlider').value = rotationX;
          document.getElementById('rotationYSlider').value = rotationY;
          document.getElementById('rotationInput').value = rotationAngle;
          document.getElementById('rotationXInput').value = rotationX;
          document.getElementById('rotationYInput').value = rotationY;
          document.getElementById('rotationValue').textContent = rotationAngle + '¬∞';
          document.getElementById('rotationXValue').textContent = rotationX + '¬∞';
          document.getElementById('rotationYValue').textContent = rotationY + '¬∞';
        }
        
        // Enable buttons
        document.getElementById('applyBtn').disabled = false;
        document.getElementById('copyBtn').disabled = false;
        
        // Update preview
        updatePreview();
        
        console.log('‚úÖ Image loaded:', name, width + 'x' + height);
      };
      
      img.onerror = () => {
        console.error('‚ùå Failed to load image');
        showNotification('Failed to load image', 'error');
      };
      
      img.src = dataUrl;
    }

    // Handle messages from Figma
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;

      if (msg.type === 'image-exported') {
        loadImage(msg.data, msg.width, msg.height, msg.name, msg.detectedRotation);
      }

      if (msg.type === 'no-selection') {
        currentImage = null;
        updatePreview(); // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–≤—å—é –ø–æ—Å–ª–µ —Å–±—Ä–æ—Å–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        document.getElementById('applyBtn').disabled = true;
        document.getElementById('copyBtn').disabled = true;
      }

      if (msg.type === 'success') {
        showNotification(msg.message, 'success');

        // Reset manual insert button if it was a manual insert operation
        if (msg.message && msg.message.includes('Manual insert completed')) {
          const insertBtn = document.getElementById('manualInsertBtn');
          if (insertBtn) {
            insertBtn.textContent = 'üéØ Insert Image into Screen';
            insertBtn.disabled = false;
            insertBtn.style.background = 'linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%)';
          }
        }
      }

      if (msg.type === 'error') {
        showNotification(msg.message, 'error');
      }

      if (msg.type === 'export-progress') {
        showNotification(msg.message, 'info');
      }

      // License-related messages
      if (msg.type === 'license-info-response') {
        licenseInfo = {
          usageCount: msg.usageCount || 0,
          isPro: msg.isPro || false,
          remainingUses: msg.remainingUses !== undefined ? msg.remainingUses : 10,
          keyInfo: msg.keyInfo || null,
          expiryWarning: msg.expiryWarning || false,
          daysUntilExpiry: msg.daysUntilExpiry
        };
        updateLicenseUI();
      }

      if (msg.type === 'usage-updated') {
        licenseInfo.usageCount = msg.usageCount;
        licenseInfo.remainingUses = msg.remainingUses;
        updateLicenseUI();
      }

      if (msg.type === 'usage-limit-reached') {
        showLicenseModal();
      }

      if (msg.type === 'key-activation-response') {
        console.log('Key activation response:', msg);
        if (msg.success) {
          if (msg.action === 'activate') {
            licenseInfo.isPro = true;
            licenseInfo.remainingUses = -1;
            licenseInfo.keyInfo = msg.keyInfo;
            updateLicenseUI();
            hideSubscriptionModal();
            showNotification('Pro –≤–µ—Ä—Å–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!', 'success');
          } else if (msg.action === 'reset') {
            licenseInfo.isPro = false;
            licenseInfo.remainingUses = 10;
            licenseInfo.usageCount = 0;
            licenseInfo.keyInfo = null;
            updateLicenseUI();
            hideSubscriptionModal();
            showNotification('–ü–æ–¥–ø–∏—Å–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞!', 'success');
          }
        } else {
          let errorMsg = '–û—à–∏–±–∫–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∫–ª—é—á–∞';
          if (msg.error === 'format') {
            errorMsg = '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–ª—é—á–∞';
          } else if (msg.error === 'expired') {
            errorMsg = '–ö–ª—é—á –∏—Å—Ç–µ–∫';
          } else if (msg.error === 'device_mismatch') {
            errorMsg = '–ö–ª—é—á –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –¥—Ä—É–≥–æ–º—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É';
          } else if (msg.error === 'validation') {
            errorMsg = '–ö–ª—é—á –ø–æ–≤—Ä–µ–∂–¥–µ–Ω –∏–ª–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω';
          }
          showNotification(errorMsg, 'error');
        }
      }

      if (msg.type === 'challenge-response') {
        // Open Telegram bot with challenge
        if (msg.botUrl) {
          window.open(msg.botUrl, '_blank');
        }
      }

      if (msg.type === 'pro-activation-response') {
        if (msg.success) {
          licenseInfo.isPro = true;
          licenseInfo.remainingUses = -1;
          hideLicenseModal();
          showNotification('Pro –≤–µ—Ä—Å–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!', 'success');
        }
      }

      // Manual Screen Mode responses
      if (msg.type === 'manual-mockup-selected') {
        if (manualScreenEnabled) {
          setSelectedMockup({
            name: msg.name,
            width: msg.width,
            height: msg.height,
            x: msg.x,
            y: msg.y,
            transform: msg.transform,
            id: msg.id
          });
        }
      }

      if (msg.type === 'mockup-image-response') {
        if (selectedMockup && msg.imageData) {
          selectedMockup.imageData = msg.imageData;
          // Update preview with real mockup image
          if (document.body.classList.contains('fs') && manualScreenEnabled) {
            createRealMockupPreview();
          }
        }
      }

      if (msg.type === 'mockup-image-error') {
        console.error('Mockup image error:', msg.error);
        // Show fallback preview
        if (document.body.classList.contains('fs') && manualScreenEnabled) {
          const previewContent = document.getElementById('previewContent');
          previewContent.innerHTML = `
            <div style="
              width: 100%; 
              height: 100%; 
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              color: #888;
              font-size: 16px;
              text-align: center;
              gap: 20px;
            ">
              <div>‚ö†Ô∏è Could not load mockup preview</div>
              <div style="font-size: 14px;">
                Selected: ${selectedMockup ? selectedMockup.name : 'None'}<br>
                You can still apply the rotation
              </div>
            </div>
          `;
        }
      }

      if (msg.type === 'manual-screen-area-selected') {
        if (manualScreenEnabled) {
          setSelectedScreenArea({
            name: msg.name,
            width: msg.width,
            height: msg.height,
            x: msg.x,
            y: msg.y,
            transform: msg.transform,
            id: msg.id
          });
        }
      }
    };

  </script>

  <!-- Fullscreen Panels -->
  <button id="fsExitBtn" class="fs-exit-btn hidden" onclick="document.getElementById('fullscreenToggle').click()">‚úï Exit Fullscreen</button>
  
  <div id="fsLeft" class="fs-side fs-left hidden">
    <div class="fs-panel">
      <div class="fs-panel-title">üéØ Manual Mode</div>
      <label style="display:flex; align-items:center; gap:6px; font-size:11px; color:#666; margin-bottom:8px;">
        <input type="checkbox" id="fsManualScreenMode" onchange="toggleManualScreenMode()"> Enable Manual
      </label>
      <div id="fsManualControls" style="display:none;">
        <button onclick="selectMockupForManual()" style="width:100%; padding:6px; font-size:10px; background:#3b82f6; color:white; border:none; border-radius:4px; margin-bottom:4px;">Select Mockup</button>
        <button onclick="selectScreenAreaForManual()" style="width:100%; padding:6px; font-size:10px; background:#10b981; color:white; border:none; border-radius:4px; margin-bottom:4px;">Select Screen</button>
        <button onclick="applyManualInsert()" style="width:100%; padding:6px; font-size:10px; background:#f59e0b; color:white; border:none; border-radius:4px;">Apply Manual</button>
        
        <!-- Mockup Perspective controls for Manual Mode -->
        <div id="fsMockupPerspective" style="margin-top:8px; padding:6px; background:rgba(255,255,255,0.1); border-radius:4px;">
          <div style="font-size:9px; color:#ccc; margin-bottom:4px;">üìê Mockup Perspective</div>
          
          <div style="display:flex; align-items:center; gap:4px; margin-bottom:3px;">
            <label style="flex:1; font-size:8px; color:#aaa;">X: <span id="fsMockupXValue">0¬∞</span></label>
            <input type="number" id="fsMockupX" style="width:30px; padding:2px; font-size:8px;" min="-90" max="90" value="0" oninput="updateFsMockupPerspective()">
            <input type="range" id="fsMockupXSlider" style="flex:2;" min="-90" max="90" value="0" oninput="document.getElementById('fsMockupX').value = this.value; updateFsMockupPerspective()">
          </div>
          
          <div style="display:flex; align-items:center; gap:4px; margin-bottom:3px;">
            <label style="flex:1; font-size:8px; color:#aaa;">Y: <span id="fsMockupYValue">0¬∞</span></label>
            <input type="number" id="fsMockupY" style="width:30px; padding:2px; font-size:8px;" min="-90" max="90" value="0" oninput="updateFsMockupPerspective()">
            <input type="range" id="fsMockupYSlider" style="flex:2;" min="-90" max="90" value="0" oninput="document.getElementById('fsMockupY').value = this.value; updateFsMockupPerspective()">
          </div>
          
          <div style="display:flex; align-items:center; gap:4px;">
            <label style="flex:1; font-size:8px; color:#aaa;">Z: <span id="fsMockupZValue">0¬∞</span></label>
            <input type="number" id="fsMockupZ" style="width:30px; padding:2px; font-size:8px;" min="-180" max="180" value="0" oninput="updateFsMockupPerspective()">
            <input type="range" id="fsMockupZSlider" style="flex:2;" min="-180" max="180" value="0" oninput="document.getElementById('fsMockupZ').value = this.value; updateFsMockupPerspective()">
          </div>
        </div>
      </div>
    </div>
    
    <div class="fs-panel">
      <div class="fs-panel-title">üîç View Controls</div>
      <div class="fs-preset-buttons">
        <button class="fs-preset-btn" onclick="fsZoom *= 1.2; updatePreviewTransform()">üîç Zoom In</button>
        <button class="fs-preset-btn" onclick="fsZoom *= 0.8; updatePreviewTransform()">üîç Zoom Out</button>
        <button class="fs-preset-btn" onclick="fsZoom = 1; fsPanX = 0; fsPanY = 0; updatePreviewTransform()">üéØ Fit</button>
        <button class="fs-preset-btn" onclick="fsZoom = 1; updatePreviewTransform()">üìè 100%</button>
      </div>
    </div>

    <div class="fs-panel">
      <div class="fs-panel-title">üéØ Quick Presets</div>
      <div class="fs-preset-buttons">
        <button class="fs-preset-btn" onclick="setFullscreenPreset(0, 0, 0)">üì± Straight</button>
        <button class="fs-preset-btn" onclick="setFullscreenPreset(-15, 8, 0)">üì± Left</button>
        <button class="fs-preset-btn" onclick="setFullscreenPreset(-15, -8, 0)">üì± Right</button>
        <button class="fs-preset-btn" onclick="setFullscreenPreset(0, 0, 90)">üì± Portrait</button>
        <button class="fs-preset-btn" onclick="setFullscreenPreset(0, 0, -90)">üì± Landscape</button>
        <button class="fs-preset-btn" onclick="setFullscreenPreset(0, 0, 180)">üì± Upside</button>
      </div>
    </div>
  </div>

  <div id="fsRight" class="fs-side fs-right hidden">
    <div class="fs-panel">
      <div class="fs-panel-title">üîÑ Rotation Controls</div>
      <div class="fs-rotation-controls">
        <div class="fs-rotation-row">
          <label class="fs-rotation-label">Z Rotation: <span id="fsRotationZValue">0¬∞</span></label>
          <input type="number" id="fsRotationZ" class="fs-rotation-input" min="-180" max="180" value="0" oninput="updateFullscreenRotation()">
          <input type="range" id="fsRotationZSlider" class="fs-rotation-slider" min="-180" max="180" value="0" oninput="document.getElementById('fsRotationZ').value = this.value; updateFullscreenRotation()">
        </div>
        
        <div class="fs-rotation-row">
          <label class="fs-rotation-label">X Rotation: <span id="fsRotationXValue">0¬∞</span></label>
          <input type="number" id="fsRotationX" class="fs-rotation-input" min="-90" max="90" value="0" oninput="updateFullscreenRotation()">
          <input type="range" id="fsRotationXSlider" class="fs-rotation-slider" min="-90" max="90" value="0" oninput="document.getElementById('fsRotationX').value = this.value; updateFullscreenRotation()">
        </div>
        
        <div class="fs-rotation-row">
          <label class="fs-rotation-label">Y Rotation: <span id="fsRotationYValue">0¬∞</span></label>
          <input type="number" id="fsRotationY" class="fs-rotation-input" min="-90" max="90" value="0" oninput="updateFullscreenRotation()">
          <input type="range" id="fsRotationYSlider" class="fs-rotation-slider" min="-90" max="90" value="0" oninput="document.getElementById('fsRotationY').value = this.value; updateFullscreenRotation()">
        </div>
      </div>
    </div>

    <div class="fs-panel">
      <div class="fs-panel-title">‚öôÔ∏è Actions</div>
      <button onclick="applyRotation()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; font-weight: 600; margin-bottom: 8px;">Apply to Figma</button>
      <button onclick="copyRotationData()" style="width: 100%; padding: 8px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 8px; font-weight: 600;">Copy Data</button>
    </div>
  </div>

</body>

</html>



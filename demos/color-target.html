<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <title>Color Target</title>
  <style>
    :root {
      color-scheme: light;
    }

    body {
      font-family: "Inter", sans-serif;
      margin: 0;
      padding: 16px;
      width: 100%;
      background: #f0f2f5;
      color: #333;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 14px;
      user-select: none;
      padding-bottom: 8px;
      /* –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ —Å–∫—Ä–æ–ª–ª–∞ */
    }

    input,
    textarea {
      user-select: text;
    }

    * {
      -webkit-tap-highlight-color: transparent;
    }

    h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #222;
      text-align: left;
      white-space: nowrap;
    }

    .title-rainbow {
      background: linear-gradient(90deg, #ff6b6b, #f7b267, #ffd93d, #6bcb77, #4d96ff, #8358ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .hidden {
      display: none !important;
    }

    .card {
      background: #fff;
      border-radius: 14px;
      padding: 14px 12px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .08);
    }

    .preview-sticky-wrapper {
      position: sticky;
      top: 16px;
      z-index: 15;
      margin-bottom: 4px;
    }

    .preview-sticky-wrapper>#image-preview {
      position: relative;
    }

    /* Fullscreen button overlay */
    .preview-overlay-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 30;
      display: flex;
      gap: 8px;
      pointer-events: none;
    }

    .preview-overlay-btn {
      padding: 10px 16px;
      background: linear-gradient(135deg, rgba(75, 139, 245, 0.95) 0%, rgba(30, 100, 208, 0.95) 100%);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 6px;
      pointer-events: auto;
    }

    .preview-overlay-btn:hover {
      background: linear-gradient(135deg, rgba(90, 155, 255, 0.95) 0%, rgba(46, 116, 224, 0.95) 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(75, 139, 245, 0.4);
    }

    .preview-overlay-btn:active {
      transform: translateY(0px);
    }

    html[data-theme='dark'] .preview-overlay-btn {
      background: linear-gradient(135deg, rgba(75, 139, 245, 0.9) 0%, rgba(30, 100, 208, 0.9) 100%);
      border-color: rgba(255, 255, 255, 0.15);
    }

    body.fs .preview-overlay-controls {
      display: none;
    }

    /* Exit fullscreen button */
    #fsExitBtn {
      display: none;
    }

    body.fs #fsExitBtn {
      display: inline-flex;
    }

    .preview-controls {
      margin-top: 0;
    }

    .card>*+* {
      margin-top: 8px;
    }

    .group-title {
      font-size: 12px;
      font-weight: 700;
      color: #25314c;
      letter-spacing: .2px;
      margin-bottom: 8px;
    }

    label {
      display: block;
      margin-bottom: 6px;
      font-size: 12px;
      color: #4a5875;
      font-weight: 600;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #d6ddeb;
      font-size: 13px;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), 0 2px 8px rgba(0, 0, 0, 0.1);
      background: #fff;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(75, 139, 245, 0.3);
      transition: all .2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 3px 8px rgba(75, 139, 245, 0.4);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(75, 139, 245, 0.3);
    }

    select {
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      border: 1px solid #d6ddeb;
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 13px;
      color: #4a5875;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    select:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-color: #94a3b8;
    }

    /* Custom tool selector dropdown */
    .tool-selector {
      position: relative;
      display: inline-block;
    }

    .tool-selector-button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #d6ddeb;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      color: #4a5875;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      font-size: 13px;
      min-width: 80px;
    }

    .tool-selector-button:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-color: #94a3b8;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
    }

    .tool-selector-button svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .tool-selector-button::after {
      content: "";
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 5px solid currentColor;
      opacity: .7;
      margin-left: auto;
    }

    .tool-selector-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      min-width: 100%;
      background: #fff;
      border-radius: 10px;
      border: 1px solid #d6ddeb;
      box-shadow: 0 8px 24px rgba(15, 30, 60, .12);
      padding: 4px;
      display: none;
      flex-direction: column;
      gap: 2px;
      z-index: 100;
    }

    .tool-selector-dropdown.open {
      display: flex;
    }

    .tool-selector-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 8px;
      border: none;
      background: transparent;
      color: #4a5875;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s ease;
      text-align: left;
    }

    .tool-selector-option:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      color: #1e40af;
    }

    .tool-selector-option svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .tool-selector-option.selected {
      background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
      color: #1e40af;
    }

    html[data-theme='dark'] .tool-selector-button {
      background: linear-gradient(135deg, #343434 0%, #2d3238 100%);
      border-color: #4a4a4a;
      color: #e8e8e8;
    }

    html[data-theme='dark'] .tool-selector-button:hover {
      background: linear-gradient(135deg, #4a4f56 0%, #343434 100%);
      border-color: #6b7280;
    }

    html[data-theme='dark'] .tool-selector-dropdown {
      background: #343434;
      border-color: #4a4a4a;
      box-shadow: 0 12px 30px rgba(0, 0, 0, .45);
    }

    html[data-theme='dark'] .tool-selector-option {
      color: #e8e8e8;
    }

    html[data-theme='dark'] .tool-selector-option:hover {
      background: linear-gradient(135deg, #4a4f56 0%, #3a3f46 100%);
      color: #93c5fd;
    }

    html[data-theme='dark'] .tool-selector-option.selected {
      background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
      color: #dbeafe;
    }

    /* –°—Ç–∏–ª–∏–∑–∞—Ü–∏—è —á–µ–∫–±–æ–∫—Å–æ–≤ */
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      border: 2px solid #d6ddeb;
      border-radius: 4px;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      cursor: pointer;
      position: relative;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    input[type="checkbox"]:hover {
      border-color: #94a3b8;
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      transform: scale(1.05);
    }

    input[type="checkbox"]:checked {
      background: linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%);
      border-color: #3b82f6;
      box-shadow: 0 2px 6px rgba(75, 139, 245, 0.3);
    }

    input[type="checkbox"]:checked::after {
      content: '‚úì';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 12px;
      font-weight: bold;
    }

    input[type="checkbox"]:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), 0 2px 6px rgba(75, 139, 245, 0.3);
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .row-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      align-items: center;
    }

    .hint {
      font-size: 12px;
      color: #666;
    }

    .chip {
      display: flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #d6ddeb;
      border-radius: 8px;
      padding: 4px 6px;
    }

    .primary-button {
      display: block;
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%);
      border: none;
      border-radius: 12px;
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 2px 8px rgba(75, 139, 245, 0.3);
      position: relative;
      overflow: hidden;
    }

    .primary-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .primary-button:hover::before {
      left: 100%;
    }

    .primary-button:disabled {
      background: linear-gradient(135deg, #c5cedd 0%, #a8b3c7 100%);
      cursor: not-allowed;
      opacity: .7;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .primary-button:not(:disabled):hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(75, 139, 245, 0.4);
      background: linear-gradient(135deg, #5a9bff 0%, #2e74e0 100%);
    }

    .primary-button:not(:disabled):active {
      transform: translateY(0px);
      box-shadow: 0 2px 8px rgba(75, 139, 245, 0.3);
    }

    .button-secondary {
      border: 1px solid #d6ddeb;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      color: #4a5875;
      font-weight: 600;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
    }

    .button-secondary:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-color: #94a3b8;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
    }

    .button-secondary:active {
      transform: translateY(0px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    /* Recovery button - special styling */
    .button-recovery {
      display: block;
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border: none;
      border-radius: 12px;
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s ease;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
      position: relative;
      overflow: hidden;
    }

    .button-recovery::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .button-recovery:hover::before {
      left: 100%;
    }

    .button-recovery:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
      background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
    }

    .button-recovery:active {
      transform: translateY(0px);
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }

    /* –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å –¥–ª—è –∫–Ω–æ–ø–∫–∏ –æ—á–∏—Å—Ç–∫–∏ */
    .icon-btn.clear-btn {
      background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%) !important;
      border-color: #fca5a5 !important;
      color: #dc2626 !important;
    }

    .icon-btn.clear-btn::before {
      background: rgba(220, 38, 38, 0.1) !important;
    }

    .icon-btn.clear-btn:hover {
      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%) !important;
      border-color: #f87171 !important;
      color: #b91c1c !important;
    }

    .icon-btn.clear-btn:active {
      background: linear-gradient(135deg, #fecaca 0%, #fca5a5 100%) !important;
    }

    html[data-theme='dark'] .icon-btn.clear-btn {
      background: linear-gradient(135deg, #450a0a 0%, #3c0a0a 100%) !important;
      border-color: #7f1d1d !important;
      color: #fca5a5 !important;
    }

    html[data-theme='dark'] .icon-btn.clear-btn:hover {
      background: linear-gradient(135deg, #7f1d1d 0%, #450a0a 100%) !important;
      border-color: #991b1b !important;
      color: #f87171 !important;
    }

    .toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      position: relative;
      z-index: 30;
      min-width: 0;
    }

    .toolbar h2 {
      flex-shrink: 0;
    }

    .toolbar>div {
      flex-shrink: 0;
    }

    /* Responsive toolbar for smaller widths */
    @media (max-width: 500px) {
      .toolbar {
        gap: 4px;
      }

      .toolbar h2 {
        font-size: 16px;
      }

      .toolbar .button-secondary {
        padding: 4px 8px !important;
        font-size: 12px;
      }
    }

    .language-switcher {
      position: relative;
      display: inline-block;
      z-index: 20;
    }

    .language-selected {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px 6px 10px;
      border-radius: 999px;
      border: 1px solid #d5dceb;
      background: #fff;
      color: #4a5875;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }

    .language-name {
      white-space: nowrap;
    }

    .language-code {
      font-weight: 700;
      letter-spacing: .3px;
    }

    .language-selected::after {
      content: "";
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 5px solid currentColor;
      opacity: .7;
      margin-left: 4px;
    }

    .language-dropdown {
      position: absolute;
      right: 0;
      top: calc(100% + 8px);
      min-width: 160px;
      background: #fff;
      border-radius: 12px;
      border: 1px solid #dce3f1;
      box-shadow: 0 8px 24px rgba(15, 30, 60, .12);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 10;
    }

    .language-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: #4a5875;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }

    .language-flag {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .language-flag img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .footer {
      margin-top: auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-top: 2px;
      padding-bottom: 2px;
      min-height: 24px;
    }

    .footer-link {
      color: #4b8bf5;
      font-weight: 600;
      text-decoration: none;
    }

    .theme-toggle {
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      border-radius: 999px;
      border: 1px solid #d5dceb;
      background: #fff;
      color: #4a5875;
      font-size: 14px;
      line-height: 1;
      cursor: pointer;
    }

    #image-preview {
      width: 100%;
      height: 240px;
      background: #f0f2f0;
      border: 1px solid #e1e6ef;
      position: relative;
      cursor: crosshair;
      overflow: auto;
      border-radius: 14px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .08);
    }

    #image-preview img {
      pointer-events: none;
      transform-origin: top left;
      display: block;
    }

    .marker {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #fff;
      background: red;
      position: absolute;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    #image-preview.panning {
      cursor: grabbing !important;
    }

    #image-preview canvas.result-overlay {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      transform-origin: top left;
      z-index: 10;
    }

    /* allow pointer events for selection editing */
    #image-preview canvas.result-overlay.interactive {
      pointer-events: auto;
      z-index: 20;
    }

    .selection-rect {
      position: absolute;
      border: 1.5px dashed #3b82f6;
      background: rgba(59, 130, 246, .12);
      pointer-events: none;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, .6) inset;
    }

    /* Zoom HUD removed per request; keep only Ctrl+wheel and FS buttons */
    .icon-btn {
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #d6ddeb;
      background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
      color: #4a5875;
      border-radius: 10px;
      cursor: pointer;
      font-size: 14px;
      padding: 0;
      flex: 0 0 auto;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
    }

    .icon-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(75, 139, 245, 0.1);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
    }

    .icon-btn:hover::before {
      width: 100%;
      height: 100%;
    }

    .icon-btn:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-color: #94a3b8;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
      color: #1e40af;
    }

    .icon-btn:active {
      transform: translateY(0px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    html[data-theme='dark'] .icon-btn {
      background: linear-gradient(135deg, #3a3f46 0%, #2d3238 100%);
      border-color: #4a4f56;
      color: #e0e0e0;
    }

    html[data-theme='dark'] .icon-btn:hover {
      background: linear-gradient(135deg, #4a4f56 0%, #3a3f46 100%);
      border-color: #6b7280;
      color: #93c5fd;
    }

    .icon-btn.is-active {
      border-color: #3b82f6;
      background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
      color: #1e40af;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, .25), 0 2px 8px rgba(59, 130, 246, .2);
    }

    html[data-theme='dark'] .icon-btn.is-active {
      background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
      color: #dbeafe;
    }

    /* –¶–≤–µ—Ç–Ω—ã–µ –∫–Ω–æ–ø–∫–∏-–ø–∏–ø–µ—Ç–∫–∏ */
    .icon-btn.pipette-target {
      background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%) !important;
      color: #fff !important;
      border: none !important;
      box-shadow: 0 2px 8px rgba(14, 165, 233, 0.3);
    }

    .icon-btn.pipette-target:hover {
      background: linear-gradient(135deg, #38bdf8 0%, #0ea5e9 100%) !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(14, 165, 233, 0.4);
    }

    .icon-btn.pipette-target:active {
      transform: translateY(0px);
      box-shadow: 0 2px 8px rgba(14, 165, 233, 0.3);
    }

    .icon-btn.pipette-source {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
      color: #fff !important;
      border: none !important;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }

    .icon-btn.pipette-source:hover {
      background: linear-gradient(135deg, #34d399 0%, #10b981 100%) !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }

    .icon-btn.pipette-source:active {
      transform: translateY(0px);
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }

    .icon-btn.pipette-ignore {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
      color: #fff !important;
      border: none !important;
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
    }

    .icon-btn.pipette-ignore:hover {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }

    .icon-btn.pipette-ignore:active {
      transform: translateY(0px);
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
    }

    #zoomBadge {
      font-size: 12px;
      color: #4a5875;
      min-width: 34px;
      text-align: center;
    }

    html[data-theme='dark'] #zoomBadge {
      color: #e0e0e0;
    }

    /* Fullscreen workspace */
    body.fs {
      padding: 8px;
    }

    body.fs .card {
      display: none;
    }

    body.fs .preview-card {
      display: block;
      background: transparent;
      box-shadow: none;
      padding: 0;
      margin: 0;
    }

    body.fs #image-preview {
      background: #0f1113;
      border: 1px solid #2b3036;
      width: calc(100vw - 220px);
      height: calc(100vh - 120px);
      margin: 8px auto 0;
      border-radius: 12px;
    }

    body.fs #create-btn {
      display: none;
    }

    .fs-side {
      position: fixed;
      top: 56px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 12;
    }

    .fs-left {
      left: 8px;
      width: 92px;
    }

    .fs-right {
      right: 8px;
      width: 240px;
      top: 80px;
      max-height: calc(100vh - 90px);
      overflow-y: auto;
      padding-bottom: 8px;
    }

    /* Dark-friendly buttons inside fullscreen panels */
    .fs-panel .button-secondary {
      background: linear-gradient(135deg, #eef3f8 0%, #e1e8ed 100%);
      border-color: #d6ddeb;
      color: #25314c;
      flex: 0 0 auto;
      min-width: 40px;
      font-weight: 600;
      transition: all .2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    .fs-panel .button-secondary:hover {
      background: linear-gradient(135deg, #e1e8ed 0%, #d4dde4 100%);
      border-color: #94a3b8;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
    }

    html[data-theme='dark'] .fs-panel .button-secondary {
      background: linear-gradient(135deg, #2b3036 0%, #232830 100%);
      border-color: #3a4048;
      color: #e8e8e8;
    }

    html[data-theme='dark'] .fs-panel .button-secondary:hover {
      background: linear-gradient(135deg, #3a4048 0%, #2b3036 100%);
      border-color: #4a5568;
      color: #f7fafc;
    }

    .fs-panel {
      background: #fff;
      border: 1px solid #d6ddeb;
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 4px 14px rgba(0, 0, 0, .12);
    }

    html[data-theme='dark'] .fs-panel {
      background: #343434;
      border-color: #4a4a4a;
      box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
    }

    .tool-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .tool-title {
      font-size: 11px;
      font-weight: 700;
      color: #4a5875;
    }

    html[data-theme='dark'] .tool-title {
      color: #cfd8ea;
    }

    /* –ö–æ–º–ø–∞–∫—Ç–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏ */
    .fs-panel {
      padding: 4px;
      margin-bottom: 3px !important;
    }

    .fs-panel input[type="text"] {
      padding: 3px 5px;
      font-size: 10px;
      border-radius: 4px;
      height: auto;
    }

    .fs-panel input[type="range"] {
      height: 3px;
    }

    .fs-panel input[type="range"]::-webkit-slider-thumb {
      width: 12px;
      height: 12px;
    }

    .fs-panel input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
    }

    .fs-panel label {
      font-size: 9px;
      margin-bottom: 0px;
    }

    .fs-panel .tool-title {
      margin-bottom: 2px;
    }

    /* –ú–∞–ª–µ–Ω—å–∫–∏–µ –ø–∏–ø–µ—Ç–∫–∏ —Ä—è–¥–æ–º —Å –ø–æ–ª—è–º–∏ */
    #fsPipetteTarget,
    #fsPipetteSource,
    #fsPipetteIgnore {
      transition: all 0.2s ease;
    }

    #fsPipetteTarget:hover,
    #fsPipetteSource:hover,
    #fsPipetteIgnore:hover {
      transform: scale(1.05);
    }

    /* –ü—Ä–æ–∫—Ä—É—Ç–∫–∞ –¥–ª—è –ø—Ä–∞–≤–æ–π –ø–∞–Ω–µ–ª–∏ */
    .fs-right::-webkit-scrollbar {
      width: 4px;
    }

    .fs-right::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 2px;
    }

    .fs-right::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 2px;
    }

    .fs-right::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.5);
    }

    /* Dark theme overrides */
    html[data-theme='dark'] {
      color-scheme: dark;
    }

    html[data-theme='dark'] body {
      background: #2c2c2c;
      color: #e8e8e8;
    }

    html[data-theme='dark'] .card {
      background: #343434;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .35);
    }

    html[data-theme='dark'] .group-title {
      color: #d0d0d0;
    }

    html[data-theme='dark'] .hint {
      color: #b0b0b0;
    }

    html[data-theme='dark'] #sourceStepHint,
    html[data-theme='dark'] #targetStepHint,
    html[data-theme='dark'] #thresholdsStepHint {
      color: #a8b4c0 !important;
    }

    html[data-theme='dark'] #fsTargetLabel,
    html[data-theme='dark'] #fsSourceLabel,
    html[data-theme='dark'] #fsThresholdsStepHint,
    html[data-theme='dark'] #fsHueTolVal,
    html[data-theme='dark'] #fsSatTolVal,
    html[data-theme='dark'] #fsLightTolVal,
    html[data-theme='dark'] #fsIntensityVal {
      color: #b0b0b0 !important;
    }

    html[data-theme='dark'] label {
      color: #cfd8ea;
    }

    html[data-theme='dark'] input[type="text"] {
      background: linear-gradient(135deg, #343434 0%, #2d3238 100%);
      color: #e8e8e8;
      border-color: #4a4a4a;
    }

    html[data-theme='dark'] input[type="text"]:focus {
      border-color: #3b82f6;
      background: #3a3f46;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2), 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    html[data-theme='dark'] input[type="range"] {
      background: linear-gradient(135deg, #4a4f56 0%, #3a3f46 100%);
    }

    html[data-theme='dark'] select {
      background: linear-gradient(135deg, #343434 0%, #2d3238 100%);
      border-color: #4a4a4a;
      color: #e8e8e8;
    }

    html[data-theme='dark'] select:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2), 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    html[data-theme='dark'] select:hover {
      background: linear-gradient(135deg, #4a4f56 0%, #343434 100%);
      border-color: #6b7280;
    }

    html[data-theme='dark'] input[type="checkbox"] {
      background: linear-gradient(135deg, #343434 0%, #2d3238 100%);
      border-color: #4a4a4a;
    }

    html[data-theme='dark'] input[type="checkbox"]:hover {
      border-color: #6b7280;
      background: linear-gradient(135deg, #4a4f56 0%, #343434 100%);
    }

    html[data-theme='dark'] input[type="checkbox"]:checked {
      background: linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%);
      border-color: #3b82f6;
    }

    html[data-theme='dark'] #image-preview {
      background: #2c2c2c;
      border-color: #4a4a4a;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .35);
    }

    html[data-theme='dark'] .footer-link {
      color: #9ec5ff;
    }

    html[data-theme='dark'] .language-selected,
    html[data-theme='dark'] .theme-toggle {
      background: #343434;
      border-color: #4a4a4a;
      color: #e0e0e0;
    }

    html[data-theme='dark'] .language-dropdown {
      background: #343434;
      border-color: #4a4a4a;
      box-shadow: 0 12px 30px rgba(0, 0, 0, .45);
    }

    /* Selection overlay must be above result overlay */
    #image-preview canvas.selection-overlay {
      z-index: 25 !important;
    }

    /* License Info Block */
    #licenseInfo {
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
      border: 1px solid #e2e8f0;
      transition: all 0.2s ease;
    }

    #licenseInfo.pro {
      background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
      border-color: #22c55e;
    }

    #licenseInfo.pro #licenseStatusText {
      color: #15803d;
    }

    #licenseInfo.warning {
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
      border-color: #f59e0b;
    }

    #licenseInfo.warning #licenseStatusText {
      color: #d97706;
    }

    #licenseInfo.danger {
      background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
      border-color: #ef4444;
    }

    #licenseInfo.danger #licenseStatusText {
      color: #dc2626;
    }

    #upgradeBtn {
      background: linear-gradient(135deg, #4b8bf5 0%, #1e64d0 100%);
      color: #fff;
      border: none;
      box-shadow: 0 2px 6px rgba(75, 139, 245, 0.3);
    }

    #upgradeBtn:hover {
      background: linear-gradient(135deg, #5a9bff 0%, #2e74e0 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(75, 139, 245, 0.4);
    }

    /* Dark theme for license info */
    html[data-theme='dark'] #licenseInfo {
      background: linear-gradient(135deg, #374151 0%, #2d3748 100%);
      border-color: #4a5568;
    }

    html[data-theme='dark'] #licenseInfo.pro {
      background: linear-gradient(135deg, #1a2e05 0%, #22543d 100%);
      border-color: #38a169;
    }

    html[data-theme='dark'] #licenseInfo.pro #licenseStatusText {
      color: #68d391;
    }

    html[data-theme='dark'] #licenseInfo.warning {
      background: linear-gradient(135deg, #2d1b0e 0%, #744210 100%);
      border-color: #d69e2e;
    }

    html[data-theme='dark'] #licenseInfo.warning #licenseStatusText {
      color: #f6e05e;
    }

    html[data-theme='dark'] #licenseInfo.danger {
      background: linear-gradient(135deg, #2d1b1b 0%, #742a2a 100%);
      border-color: #e53e3e;
    }

    html[data-theme='dark'] #licenseInfo.danger #licenseStatusText {
      color: #fc8181;
    }

    html[data-theme='dark'] #licenseDetailsText {
      color: #a0aec0 !important;
    }

    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-content {
      background: #fff;
      border-radius: 16px;
      max-width: 440px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px 12px;
      border-bottom: 1px solid #e5e7eb;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #111827;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: #6b7280;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .modal-close:hover {
      background: #f3f4f6;
      color: #374151;
    }

    .modal-body {
      padding: 16px 20px;
    }

    .modal-body p {
      margin: 0 0 20px;
      color: #4b5563;
      line-height: 1.5;
    }

    .modal-features {
      margin: 20px 0;
    }

    .feature {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      font-size: 14px;
      color: #374151;
    }

    .modal-price {
      text-align: center;
      margin: 24px 0;
      padding: 16px;
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      border-radius: 12px;
      border: 1px solid #0ea5e9;
    }

    .price {
      font-size: 24px;
      font-weight: 700;
      color: #0c4a6e;
      margin-bottom: 4px;
    }

    .price-note {
      font-size: 12px;
      color: #0369a1;
    }

    .modal-footer {
      padding: 12px 20px 20px;
      display: flex;
      gap: 12px;
      flex-direction: column;
    }

    /* Dark theme for modal */
    html[data-theme='dark'] .modal-content {
      background: #374151;
      color: #f9fafb;
    }

    html[data-theme='dark'] .modal-header {
      border-color: #4b5563;
    }

    html[data-theme='dark'] .modal-header h3 {
      color: #f9fafb;
    }

    html[data-theme='dark'] .modal-close {
      color: #9ca3af;
    }

    html[data-theme='dark'] .modal-close:hover {
      background: #4b5563;
      color: #d1d5db;
    }

    html[data-theme='dark'] .modal-body p {
      color: #d1d5db;
    }

    html[data-theme='dark'] .feature {
      color: #e5e7eb;
    }

    html[data-theme='dark'] .modal-price {
      background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
      border-color: #3b82f6;
    }

    html[data-theme='dark'] .price {
      color: #dbeafe;
    }

    html[data-theme='dark'] .price-note {
      color: #93c5fd;
    }

    /* Activation section styles */
    #activationSection {
      transition: all 0.2s ease;
    }

    #activationKey {
      transition: all 0.2s ease;
    }

    #activationKey:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    #activateBtn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: #fff;
      border: none;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    #activateBtn:hover {
      background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    #activateBtn:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* Dark theme for activation section */
    html[data-theme='dark'] #activationSection {
      border-color: #4b5563;
    }

    html[data-theme='dark'] #activationLabel {
      color: #9ca3af;
    }

    html[data-theme='dark'] #activationKey {
      background: #374151;
      border-color: #4b5563;
      color: #f9fafb;
    }

    html[data-theme='dark'] #activationKey:focus {
      border-color: #3b82f6;
      background: #4b5563;
    }

    html[data-theme='dark'] #activationError {
      background: #2d1b1b;
      border-color: #7f1d1d;
      color: #fca5a5;
    }

    html[data-theme='dark'] #activationSuccess {
      background: #1a2e05;
      border-color: #22543d;
      color: #68d391;
    }

    /* PRO/FREE Status Badge */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid;
      position: relative;
      overflow: hidden;
    }

    .status-badge::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .status-badge:hover::before {
      left: 100%;
    }

    .status-badge.pro {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border-color: #10b981;
      color: #fff;
      box-shadow: 0 2px 6px rgba(16, 185, 129, 0.3);
    }

    .status-badge.pro:hover {
      background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }

    .status-badge.free {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      border-color: #f59e0b;
      color: #fff;
      box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3);
    }

    .status-badge.free:hover {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }

    .status-badge.warning {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      border-color: #ef4444;
      color: #fff;
      box-shadow: 0 2px 6px rgba(239, 68, 68, 0.3);
      animation: pulse-warning 2s infinite;
    }

    .status-badge.warning:hover {
      background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }

    @keyframes pulse-warning {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.8;
      }
    }

    .status-icon {
      width: 12px;
      height: 12px;
      flex-shrink: 0;
    }

    /* Dark theme for status badge */
    html[data-theme='dark'] .status-badge.pro {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      border-color: #059669;
    }

    html[data-theme='dark'] .status-badge.free {
      background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
      border-color: #d97706;
    }

    html[data-theme='dark'] .status-badge.warning {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
      border-color: #dc2626;
    }

    /* Dark theme for recovery button */
    html[data-theme='dark'] .button-recovery {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: #fff;
    }

    html[data-theme='dark'] .button-recovery:hover {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    }
  </style>
</head>

<body>
  <div class="toolbar">
    <h2 id="title" class="title-rainbow">Color Target</h2>
    <div style="display:flex; align-items:center; gap:8px;">
      <!-- Exit fullscreen button (visible only in FS mode) -->
      <button type="button" class="button-secondary" id="fsExitBtn" style="padding:6px 12px;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
          style="margin-right:4px;">
          <path
            d="M4 8V5C4 4.44772 4.44772 4 5 4H8M16 4H19C19.5523 4 20 4.44772 20 5V8M20 16V19C20 19.5523 19.5523 20 19 20H16M8 20H5C4.44772 20 4 19.5523 4 19V16"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
        <span id="fsExitBtnText">–°–≤–µ—Ä–Ω—É—Ç—å</span>
      </button>

      <!-- PRO/FREE Status Badge -->
      <button type="button" class="status-badge free" id="statusBadge" title="Click to view subscription details">
        <svg class="status-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2L15.09 8.26L22 9L17 14L18.18 21L12 17.77L5.82 21L7 14L2 9L8.91 8.26L12 2Z"
            fill="currentColor" />
        </svg>
        <span id="statusText">FREE</span>
      </button>

      <button type="button" class="theme-toggle" id="themeToggle" aria-label="Toggle theme">üåô</button>
      <div class="language-switcher" id="languageSwitcher">
        <button type="button" class="language-selected" id="languageSelected"><span
            class="language-code">RU</span></button>
        <div class="language-dropdown hidden" id="languageDropdown"></div>
      </div>
    </div>

    <!-- Fullscreen side panels -->
    <div id="fsLeft" class="fs-side fs-left hidden">
      <div class="fs-panel tool-group">
        <div class="tool-title">–í—ã–¥–µ–ª–µ–Ω–∏–µ</div>
        <button id="fsRect" class="icon-btn" title="–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫" aria-label="–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫">
          <svg width="16" height="16" viewBox="0 0 408 408" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M397.9,83c5.5,0,10-4.5,10.1-10V10.1C408,4.5,403.5,0,397.9,0H335c-5.5,0-10,4.5-10,10.1V32H83V10.1c0-5.5-4.5-10-10-10.1 H10.1C4.6,0,0.1,4.5,0,10.1V73c0,5.5,4.5,10,10.1,10H32v242H10.1c-5.5,0-10,4.5-10.1,10v62.9c0,5.5,4.5,10,10.1,10.1H73 c5.5,0,10-4.5,10-10.1V376h242v21.9c0,5.5,4.5,10,10,10.1h62.9c5.5,0,10-4.5,10.1-10.1V335c0-5.5-4.5-10-10.1-10H376V83H397.9z M20,63V20h43v43H20z M63,388H20v-43h43V388z M325,335v21H83v-21c0-5.5-4.5-10-10-10H52V83h21c5.5,0,10-4.5,10-10V52h242v21 c0,5.5,4.5,10,10,10h21v242h-21C329.5,325,325,329.5,325,335z M388,345v43h-43v-43H388z M345,63V20h43v43H345z"
              fill="currentColor" />
          </svg>
        </button>
        <button id="fsPen" class="icon-btn" title="–ü–µ—Ä–æ" aria-label="–ü–µ—Ä–æ">
          <svg width="16" height="16" viewBox="0 0 511 511.99899" xmlns="http://www.w3.org/2000/svg">
            <path
              d="m499.226562 13.261719c-19.519531-19.527344-122.300781 51.597656-212.113281 141.410156-52.699219 52.695313-113.722656 124.609375-137.8125 165.597656l42.917969 42.917969c40.988281-24.089844 112.902344-85.113281 165.597656-137.8125 89.8125-89.8125 160.9375-192.59375 141.410156-212.113281zm0 0"
              fill="#ba7456" />
            <path
              d="m186.199219 397.003906c-11.683594 11.664063-30.660157 11.746094-42.425781 0l-28.289063-28.289062c-11.707031-11.707032-11.707031-30.707032 0-42.425782 11.722656-11.703124 30.71875-11.710937 42.425781 0l28.289063 28.289063c11.707031 11.703125 11.71875 30.695313 0 42.425781zm0 0"
              fill="#fff" />
            <path
              d="m10.503906 501.988281 34.277344-119.132812 61.425781-23.417969 44.636719 44.636719-21.210938 63.636719zm0 0"
              fill="#f6d465" />
            <path
              d="m287.113281 211.238281c-3.910156 3.898438-3.910156 10.238281 0 14.136719 3.898438 3.910156 10.238281 3.910156 14.136719 0 3.910156-3.898438 3.910156-10.238281 0-14.136719-3.898438-3.910156-10.238281-3.910156-14.136719 0zm0 0"
              fill="currentColor" />
            <path
              d="m466.878906 5.160156c-14.292968 5.523438-32.105468 15.453125-52.941406 29.515625-40.996094 27.667969-89.796875 68.828125-133.894531 112.925781-46.832031 46.832032-106.691407 115.46875-135.179688 160.761719-13.074219-2.710937-26.691406 1.117188-36.449219 10.859375-9 9.003906-12.792968 21.261719-11.402343 33.019532l-55.792969 21.269531c-2.9375 1.121093-5.179688 3.558593-6.046875 6.578125l-34.25 119.027344c-.003906.019531-.007813.035156-.015625.054687l-.011719.050781c-.007812.023438-.011719.050782-.019531.078125-2.101562 7.5625 4.949219 14.53125 12.503906 12.261719l119.019532-34.246094c3.167968-.910156 5.679687-3.320312 6.722656-6.445312l18.582031-55.757813c12.875 2.359375 26.074219-1.5625 35.570313-11.042969 9.625-9.632812 13.542968-23.453124 10.863281-36.449218 45.292969-28.492188 113.925781-88.347656 160.75-135.171875 44.097656-44.101563 85.257812-92.902344 112.925781-133.898438 14.0625-20.835937 23.996094-38.644531 29.515625-52.9375 2.644531-6.851562 10.699219-27.699219-1.027344-39.421875-11.726562-11.730468-32.574219-3.675781-39.421875-1.03125zm-345.066406 454.394532-76.847656 22.113281 49.3125-49.3125c3.90625-3.9""0.238281 0-1425 0l-49.3125 49.3125 22.183593-77.105469 50.707032-19.328125c302344 36.398437-.875-.875 35.6875 35.6875zm57.324219-69.625c-7.808594 7.792968-20.445313 7.832031-28.292969.003906l-28.289062-28.289063c-7.796876-7.792969-7.792969-20.484375-.003907-28.277343 6.160157-6.152344 15.246094-7.398438 22.535157-4.03125 5.605468 2.605468 5.554687 4.347656 34.042968 32.3125 7.933594 7.933593 7.65625 20.621093.007813 28.28125zm280.027343-299.515626c-26.925781 39.300782-66.441406 85.917969-108.417968 127.890626-51.742188 51.746093-116.40625 106.183593-155.539063 131.292968-1.890625-2.175781-.441406-.535156-30.226562-30.378906-.671875-.675781-1.375-1.316406-2.089844-1.9375 25.113281-39.132812 79.546875-103.796875 131.292969-155.539062 41.972656-41.976563 88.589844-81.492188 127.890625-108.417969 47.347656-32.4375 66.769531-34.75 70.066406-32.976563 1.777344 3.296875-.542969 22.722656-32.976563 70.066406zm0 0"
              fill="currentColor" />
            <path
              d="m386.105469 112.242188-70.714844 70.714843c-3.90625 3.90625-3.90625 10.238281 0 14.144531 3.902344 3.902344 10.234375 3.902344 14.140625 0l70.714844-70.714843c3.90625-3.90625 3.90625-10.238281 0-14.144531-3.90625-3.902344-10.238282-3.902344-14.140625 0zm0 0"
              fill="currentColor" />
          </svg>
        </button>
        <button id="fsLasso" class="icon-btn" title="–õ–∞—Å—Å–æ" aria-label="–õ–∞—Å—Å–æ">
          <svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M508.517,132.993c-10.806-40.332-45.494-71.333-97.674-87.291c-50.598-15.474-112.04-15.003-172.994,1.329 c-60.956,16.333-114.4,46.643-150.483,85.347c-37.211,39.91-51.75,84.101-40.942,124.433 c10.806,40.332,45.494,71.333,97.674,87.291c24.586,7.519,51.722,11.273,80.127,11.273c11.348,0,22.898-0.604,34.568-1.802 c-17.458,34.138-47.436,32.647-81.223,30.918c-33.163-1.688-70.762-3.611-90.449,35.762 c-11.362,22.726-24.247,35.438-38.295,37.785c-17.517,2.916-32.374-11.452-32.493-11.567c-3.733-3.735-9.797-3.735-13.53,0 c-3.737,3.737-3.737,9.794,0,13.532c0.79,0.79,17.865,17.57,41.215,17.568c2.511,0,5.097-0.194,7.741-0.624 c20.516-3.329,38.171-19.524,52.479-48.135c13.408-26.818,36.221-27.055,72.355-25.209c37.319,1.903,82.906,4.224,104.38-53.018 c12.002-1.988,24.071-4.584,36.119-7.812c60.956-16.333,114.4-46.643,150.483-85.347 C504.787,217.516,519.326,173.325,508.517,132.993z M153.338,326.831c-1.212-0.348-2.446-0.662-3.644-1.028 c-19.211-5.875-35.629-13.953-48.923-23.827c16.773-10.104,45.39-23.189,62.717-14.35c6.028,3.075,10.577,8.84,13.634,17.223 c-9.625,7.311-17.09,13.616-20.733,16.773C154.761,323.033,153.759,324.877,153.338,326.831z M174.052,331.717 c2.429-2.039,4.84-4.018,7.228-5.931c0.194,2.322,0.343,4.723,0.423,7.24C179.132,332.625,176.581,332.192,174.052,331.717z M268.148,326.702c-0.537,2.33-1.115,4.539-1.712,6.691c-22.497,2.967-44.562,3.592-65.564,1.888 c-0.141-8.294-0.836-15.872-2.088-22.717c33.086-23.45,59.349-33.14,67.75-28.092 C268.872,285.879,275.906,293.088,268.148,326.702z M453.578,244.378c-33.67,36.114-83.902,64.494-141.438,79.911 c-8.389,2.248-16.778,4.141-25.141,5.755c7.435-32.907,3.977-53.196-10.602-61.969c-20.196-12.156-55.777,6.419-83.404,25.314 c-4.794-10.532-11.735-18.186-20.841-22.823c-29.97-15.266-71.16,8.251-86.293,18.159c-10.161-10.868-17.304-23.245-20.955-36.867 c-9.038-33.726,3.91-71.525,36.457-106.433c33.67-36.114,83.902-64.494,141.438-79.911c29.76-7.974,59.555-11.967,87.924-11.967 c26.482,0,51.727,3.482,74.523,10.453c45.639,13.957,75.75,40.218,84.787,73.944S486.125,209.47,453.578,244.378z"
              fill="currentColor" />
          </svg>
        </button>
        <button id="fsWand" class="icon-btn" title="–í–æ–ª—à–µ–±–Ω–∞—è –ø–∞–ª–æ—á–∫–∞" aria-label="–í–æ–ª—à–µ–±–Ω–∞—è –ø–∞–ª–æ—á–∫–∞">
          <svg width="16" height="16" viewBox="0 0 467.374 467.374" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M459.657,82.222c0-5.136-1.704-9.419-5.133-12.843l-56.531-56.531c-3.425-3.427-7.706-5.14-12.847-5.14 c-5.144,0-9.421,1.713-12.847,5.14L5.14,380.005C1.709,383.434,0,387.719,0,392.858c0,5.141,1.709,9.418,5.14,12.847 l56.529,56.527c3.431,3.429,7.708,5.141,12.85,5.141c5.137,0,9.419-1.704,12.847-5.141l367.162-367.16 C457.953,91.642,459.657,87.364,459.657,82.222z M332.038,165.877l-30.546-30.55l83.651-83.654l30.546,30.549L332.038,165.877z"
              fill="currentColor" />
            <polygon
              points="65.384,73.087 73.948,45.109 101.925,36.545 73.948,27.979 65.384,0.001 56.818,27.979 28.84,36.545 56.818,45.109"
              fill="currentColor" />
            <polygon
              points="139.61,108.494 156.743,164.455 173.876,108.494 229.835,91.361 173.876,74.23 156.743,18.269 139.61,74.23 83.651,91.361"
              fill="currentColor" />
            <polygon
              points="439.392,210.7 430.829,182.723 422.267,210.7 394.287,219.265 422.267,227.83 430.829,255.805 439.392,227.83 467.374,219.265"
              fill="currentColor" />
            <polygon
              points="248.106,73.087 256.672,45.109 284.648,36.545 256.672,27.979 248.106,0.001 239.544,27.979 211.564,36.545 239.544,45.109"
              fill="currentColor" />
          </svg>
        </button>
        <button id="fsUndoPt" class="icon-btn" title="–û—Ç–º–µ–Ω–∏—Ç—å —Ç–æ—á–∫—É" aria-label="–û—Ç–º–µ–Ω–∏—Ç—å —Ç–æ—á–∫—É">
          <svg width="16" height="16" viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg">
            <path
              d="m64 24.759h-36.24l21.93-17.615c1.723-1.383 1.997-3.901.613-5.624-1.383-1.723-3.901-1.997-5.623-.614l-30.792 24.735c-.945.759-1.495 1.906-1.495 3.119s.55 2.359 1.495 3.119l30.793 24.734c.738.593 1.623.881 2.502.881 1.171 0 2.331-.511 3.121-1.495 1.384-1.722 1.109-4.24-.613-5.624l-21.931-17.616h36.24c24.045 0 43.607 19.562 43.607 43.607s-19.562 43.608-43.607 43.608h-47.607c-2.209 0-4 1.791-4 4s1.791 4 4 4h47.607c28.456 0 51.607-23.151 51.607-51.607s-23.151-51.608-51.607-51.608z"
              fill="currentColor" />
          </svg>
        </button>
        <button id="fsDeletePath" class="icon-btn" title="–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç—É—Ä" aria-label="–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç—É—Ä">
          <svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
            <path
              d="m255.624 0v225.019c24.267 6.607 42.168 28.826 42.168 55.157 0 31.522-25.646 57.168-57.168 57.168s-57.168-25.646-57.168-57.168c0-26.332 17.901-48.55 42.168-55.157v-225.019h-32.414l-162.472 318.223c31.621 27.162 51.577 65.778 55.491 107.191h308.789c3.914-41.413 23.871-80.029 55.492-107.191l-162.472-318.223z"
              fill="currentColor" />
            <path d="m86.951 455.414h307.345v56.586h-307.345z" fill="currentColor" />
            <circle cx="240.624" cy="280.176" r="27.168" fill="currentColor" />
            <path d="m380.059 35.602h101.203v30h-101.203z" fill="currentColor" />
          </svg>
        </button>
        <button type="button" id="fsClearSelection" class="icon-btn clear-btn" title="–û—á–∏—Å—Ç–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ"
          aria-label="–û—á–∏—Å—Ç–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ">üóëÔ∏è</button>
      </div>

      <div class="fs-panel tool-group">
        <div class="tool-title">–ó—É–º</div>
        <button id="fsZoomIn" class="button-secondary" style="padding:6px 8px;" title="–£–≤–µ–ª–∏—á–∏—Ç—å">
          <svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
            <path
              d="m232 220h60v60c0 11.046 8.954 20 20 20s20-8.954 20-20v-60h60c11.046 0 20-8.954 20-20s-8.954-20-20-20h-60v-60c0-11.046-8.954-20-20-20s-20 8.954-20 20v60h-60c-11.046 0-20 8.954-20 20s8.954 20 20 20z"
              fill="currentColor" />
            <path
              d="m312 400c110.28 0 200-89.719 200-200 0-110.28-89.72-200-200-200s-200 89.72-200 200c0 110.281 89.72 200 200 200zm0-360c88.225 0 160 71.776 160 160s-71.775 160-160 160-160-71.776-160-160 71.775-160 160-160z"
              fill="currentColor" />
            <path
              d="m34.142 506.142 108.24-108.24c7.81-7.81 7.81-20.474 0-28.284-7.811-7.811-20.475-7.811-28.285 0l-108.24 108.24c-7.81 7.81-7.81 20.474 0 28.284 7.811 7.811 20.475 7.811 28.285 0z"
              fill="currentColor" />
          </svg>
        </button>
        <button id="fsZoomOut" class="button-secondary" style="padding:6px 8px;" title="–£–º–µ–Ω—å—à–∏—Ç—å">
          <svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
            <path d="m232 220h160c11.046 0 20-8.954 20-20s-8.954-20-20-20h-160c-11.046 0-20 8.954-20 20s8.954 20 20 20z"
              fill="currentColor" />
            <path
              d="m312 400c110.28 0 200-89.719 200-200 0-110.28-89.72-200-200-200s-200 89.72-200 200c0 110.281 89.72 200 200 200zm0-360c88.225 0 160 71.776 160 160s-71.775 160-160 160-160-71.776-160-160 71.775-160 160-160z"
              fill="currentColor" />
            <path
              d="m34.142 506.142 108.24-108.24c7.81-7.81 7.81-20.474 0-28.284-7.811-7.811-20.475-7.811-28.285 0l-108.24 108.24c-7.81 7.81-7.81 20.474 0 28.284 7.811 7.811 20.475 7.811 28.285 0z"
              fill="currentColor" />
          </svg>
        </button>
        <button id="fsZoomFit" class="button-secondary" style="padding:6px 8px;">Fit</button>
        <button id="fsZoom100" class="button-secondary" style="padding:6px 8px;">100%</button>
      </div>
    </div>

    <div id="fsRight" class="fs-side fs-right hidden">
      <!-- –¶–≤–µ—Ç–∞ -->
      <div class="fs-panel tool-group">
        <div class="tool-title">–¶–≤–µ—Ç–∞</div>
        <div style="margin-bottom:4px;">
          <div id="fsSourceLabel" style="font-size:9px; margin-bottom:2px; color:#666;">üìç Step 1 - Source:</div>
          <div style="display:flex; gap:3px; align-items:center;">
            <input type="text" id="fsSrcColorInput" placeholder="#RRGGBB"
              style="flex:1; font-size:10px; padding:4px 6px;">
            <button id="fsPipetteSource" class="icon-btn" title="–í—ã–±—Ä–∞—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π —Ü–≤–µ—Ç"
              style="width:20px; height:20px; background:#10b981; color:#fff; border:none;">
              <svg width="12" height="12" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="m249.094 108.056 32.839-32.839c3.913-3.913 10.257-3.913 14.17 0l23.935 23.935 8.095-8.095 61.815-61.815c25.629-25.629 67.182-25.629 92.811 0 25.629 25.629 25.629 67.182 0 92.811l-60.414 60.414-9.496 9.496 23.935 23.935c3.913 3.913 3.913 10.257 0 14.17l-32.839 32.839c-3.913 3.913-10.257 3.913-14.17 0l-140.68-140.68c-3.914-3.914-3.914-10.258-.001-14.171z"
                  fill="currentColor" opacity="0.9" />
                <path
                  d="m17.342 459.301 19.556-19.556c-9.905-23.811-5.185-52.269 14.183-71.637l74.004-74.004 63.519-63.519 84.424-84.425 92.811 92.811-221.947 221.947c-19.368 19.368-47.826 24.088-71.637 14.183l-19.556 19.556c-9.763 9.763-25.593 9.763-35.357 0-9.763-9.762-9.763-25.592 0-35.356z"
                  fill="currentColor" opacity="0.7" />
                <path
                  d="m318.138 359.318-34.705 72.373c-15.62 32.574 8.121 70.289 44.247 70.289 36.125 0 59.867-37.715 44.247-70.289l-34.705-72.373c-3.842-8.008-15.244-8.008-19.084 0z"
                  fill="currentColor" opacity="0.7" />
              </svg>
            </button>
          </div>
        </div>
        <div style="margin-bottom:4px;">
          <div id="fsTargetLabel" style="font-size:9px; margin-bottom:2px; color:#666;">üéØ Step 2 - Target:</div>
          <div style="display:flex; gap:3px; align-items:center;">
            <input type="text" id="fsColorInput" placeholder="#AABBCC" style="flex:1; font-size:10px; padding:4px 6px;">
            <button id="fsPipetteTarget" class="icon-btn" title="–í—ã–±—Ä–∞—Ç—å —Ü–µ–ª–µ–≤–æ–π —Ü–≤–µ—Ç"
              style="width:20px; height:20px; background:#0ea5e9; color:#fff; border:none;">
              <svg width="12" height="12" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="m249.094 108.056 32.839-32.839c3.913-3.913 10.257-3.913 14.17 0l23.935 23.935 8.095-8.095 61.815-61.815c25.629-25.629 67.182-25.629 92.811 0 25.629 25.629 25.629 67.182 0 92.811l-60.414 60.414-9.496 9.496 23.935 23.935c3.913 3.913 3.913 10.257 0 14.17l-32.839 32.839c-3.913 3.913-10.257 3.913-14.17 0l-140.68-140.68c-3.914-3.914-3.914-10.258-.001-14.171z"
                  fill="currentColor" opacity="0.9" />
                <path
                  d="m17.342 459.301 19.556-19.556c-9.905-23.811-5.185-52.269 14.183-71.637l74.004-74.004 63.519-63.519 84.424-84.425 92.811 92.811-221.947 221.947c-19.368 19.368-47.826 24.088-71.637 14.183l-19.556 19.556c-9.763 9.763-25.593 9.763-35.357 0-9.763-9.762-9.763-25.592 0-35.356z"
                  fill="currentColor" opacity="0.7" />
                <path
                  d="m318.138 359.318-34.705 72.373c-15.62 32.574 8.121 70.289 44.247 70.289 36.125 0 59.867-37.715 44.247-70.289l-34.705-72.373c-3.842-8.008-15.244-8.008-19.084 0z"
                  fill="currentColor" opacity="0.7" />
              </svg>
            </button>
          </div>
        </div>
        <div style="display:flex; align-items:flex-start; gap:4px;">
          <canvas id="cpSquareFs" width="140" height="80"
            style="width:140px; height:80px; border:1px solid #d6ddeb; border-radius:6px; background:#fff; cursor:crosshair;"></canvas>
          <canvas id="cpHueFs" width="12" height="80"
            style="width:12px; height:80px; border:1px solid #d6ddeb; border-radius:6px; cursor:ns-resize;"></canvas>
        </div>
      </div>

      <!-- –ü–æ—Ä–æ–≥–∏ -->
      <div class="fs-panel tool-group" style="margin-top:4px;">
        <div class="tool-title">–ü–æ—Ä–æ–≥–∏</div>
        <div id="fsThresholdsStepHint" style="font-size:8px; color:#888; margin-bottom:2px;">‚öôÔ∏è –®–∞–≥ 3: –ù–∞—Å—Ç—Ä–æ–π—Ç–µ
          –ø–æ—Ö–æ–∂–µ—Å—Ç—å</div>

        <div style="display:grid; grid-template-columns: 1fr auto; gap:3px; align-items:center; margin-bottom:2px;">
          <label id="fsHueLabel" style="font-size:9px;">–û—Ç—Ç–µ–Ω–æ–∫</label>
          <span id="fsHueTolVal" style="font-size:9px; color:#666; min-width:24px; text-align:right;">25¬∞</span>
          <input type="range" id="fsHueTol" min="0" max="60" step="1" value="25"
            style="grid-column:1 / span 2; margin:0; height:3px;">
        </div>

        <div style="display:grid; grid-template-columns: 1fr auto; gap:3px; align-items:center; margin-bottom: 2px;">
          <label id="fsSatLabel" style="font-size:9px;">–ù–∞—Å—ã—â.</label>
          <span id="fsSatTolVal" style="font-size:9px; color:#666; min-width:24px; text-align:right;">0.25</span>
          <input type="range" id="fsSatTol" min="0" max="100" step="1" value="25"
            style="grid-column:1 / span 2; margin:0; height:3px;">
        </div>

        <div style="display:grid; grid-template-columns: 1fr auto; gap:3px; align-items:center; margin-bottom: 2px;">
          <label id="fsLightLabel" style="font-size:9px;">–Ø—Ä–∫–æ—Å—Ç—å</label>
          <span id="fsLightTolVal" style="font-size:9px; color:#666; min-width:24px; text-align:right;">0.25</span>
          <input type="range" id="fsLightTol" min="0" max="100" step="1" value="25"
            style="grid-column:1 / span 2; margin:0; height:3px;">
        </div>

        <div style="display:grid; grid-template-columns: 1fr auto; gap:3px; align-items:center;">
          <label id="fsIntensLabel" style="font-size:9px;">–ò–Ω—Ç–µ–Ω—Å.</label>
          <span id="fsIntensityVal" style="font-size:9px; color:#666; min-width:24px; text-align:right;">100%</span>
          <input type="range" id="fsIntensity" min="0" max="100" step="1" value="100"
            style="grid-column:1 / span 2; margin:0; height:3px;">
        </div>
      </div>

      <!-- –†–µ–∂–∏–º—ã -->
      <div class="fs-panel tool-group" style="margin-top:4px;">
        <div class="tool-title" id="fsModesTitle">Modes</div>

        <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
          <label style="font-size:9px; display:flex; align-items:center; gap:3px;">
            <input type="radio" name="fs-replace-mode" value="target" style="margin:0; transform:scale(0.8);">
            <span id="fsRgbLabel">RGB</span>
          </label>
          <label style="font-size:9px; display:flex; align-items:center; gap:3px;">
            <input type="radio" name="fs-replace-mode" value="hsl" checked style="margin:0; transform:scale(0.8);">
            <span id="fsHslLabel">HSL</span>
          </label>
        </div>

        <div class="tool-title" id="fsApplyToTitle" style="margin-top:8px;">Apply to</div>

        <div style="display:flex; justify-content:space-between;">
          <label style="font-size:9px; display:flex; align-items:center; gap:3px;">
            <input type="radio" name="fs-apply-mode" value="original" checked style="margin:0; transform:scale(0.8);">
            <span id="fsOriginalLabel">Original</span>
          </label>
          <label style="font-size:9px; display:flex; align-items:center; gap:3px;">
            <input type="radio" name="fs-apply-mode" value="copy" style="margin:0; transform:scale(0.8);">
            <span id="fsCopyLabel">Copy</span>
          </label>
        </div>
      </div>

      <!-- –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã–µ —Ü–≤–µ—Ç–∞ -->
      <div class="fs-panel tool-group" style="margin-top:4px;">
        <div class="tool-title">–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å</div>
        <div style="display:flex; gap:3px; margin-bottom: 2px;">
          <input type="text" id="fsIgnoreHex" placeholder="#RRGGBB" style="flex:1; font-size:9px; padding:3px 4px;">
          <button id="fsPipetteIgnore" class="icon-btn" title="–í—ã–±—Ä–∞—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã–π —Ü–≤–µ—Ç"
            style="width:20px; height:20px; background:#f59e0b; color:#fff; border:none;">
            <svg width="12" height="12" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
              <path
                d="m249.094 108.056 32.839-32.839c3.913-3.913 10.257-3.913 14.17 0l23.935 23.935 8.095-8.095 61.815-61.815c25.629-25.629 67.182-25.629 92.811 0 25.629 25.629 25.629 67.182 0 92.811l-60.414 60.414-9.496 9.496 23.935 23.935c3.913 3.913 3.913 10.257 0 14.17l-32.839 32.839c-3.913 3.913-10.257 3.913-14.17 0l-140.68-140.68c-3.914-3.914-3.914-10.258-.001-14.171z"
                fill="currentColor" opacity="0.9" />
              <path
                d="m17.342 459.301 19.556-19.556c-9.905-23.811-5.185-52.269 14.183-71.637l74.004-74.004 63.519-63.519 84.424-84.425 92.811 92.811-221.947 221.947c-19.368 19.368-47.826 24.088-71.637 14.183l-19.556 19.556c-9.763 9.763-25.593 9.763-35.357 0-9.763-9.762-9.763-25.592 0-35.356z"
                fill="currentColor" opacity="0.7" />
              <path
                d="m318.138 359.318-34.705 72.373c-15.62 32.574 8.121 70.289 44.247 70.289 36.125 0 59.867-37.715 44.247-70.289l-34.705-72.373c-3.842-8.008-15.244-8.008-19.084 0z"
                fill="currentColor" opacity="0.7" />
            </svg>
          </button>
          <button id="fsIgnoreAdd" class="icon-btn" title="–î–æ–±–∞–≤–∏—Ç—å"
            style="width:20px; height:20px; font-size:12px;">+</button>
        </div>
        <div id="fsIgnoreList" style="display:flex; flex-wrap:wrap; gap:2px; min-height:16px;"></div>
      </div>

      <!-- –°–æ–∑–¥–∞—Ç—å -->
      <div class="fs-panel" style="margin-top:6px;">
        <button id="fsCreate" class="primary-button">–°–æ–∑–¥–∞—Ç—å</button>
      </div>
    </div>
  </div>

  <!-- Sticky –ø—Ä–µ–≤—å—é –≤–Ω–µ –∫–∞—Ä—Ç–æ—á–∫–∏ -->
  <div class="preview-sticky-wrapper">
    <div id="image-preview">–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</div>
    <!-- Fullscreen button overlay -->
    <div class="preview-overlay-controls">
      <button type="button" class="preview-overlay-btn" id="expandBtn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M8 3H5C3.89543 3 3 3.89543 3 5V8M21 8V5C21 3.89543 20.1046 3 19 3H16M16 21H19C20.1046 21 21 20.1046 21 19V16M3 16V19C3 20.1046 3.89543 21 5 21H8"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
        <span id="expandBtnText">Fullscreen</span>
      </button>
    </div>
  </div>

  <div class="card preview-controls">
    <div id="zoom-controls" class="row-grid" style="margin:4px 0 12px;">
      <label for="zoom" id="zoomLabel">–ó—É–º –ø—Ä–µ–≤—å—é</label>
      <span id="zoomVal" class="hint">100%</span>
      <input type="range" id="zoom" min="50" max="400" step="5" value="100" style="grid-column:1 / span 2;">
      <div id="zoomHint" class="hint" style="grid-column:1 / span 2;">–ó—É–º –≤–ª–∏—è–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ —Ç–æ—á–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞, –Ω–µ –Ω–∞
        –∏—Ç–æ–≥–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</div>
      <label for="areaToggle" id="areaToggleLabel">–û–≥—Ä–∞–Ω–∏—á–∏—Ç—å –æ–±–ª–∞—Å—Ç—å</label>
      <div class="row" style="justify-content:flex-start; gap:8px; flex-wrap:wrap;">
        <input type="checkbox" id="areaToggle" style="margin:0;" checked>
        <div class="tool-selector">
          <button type="button" class="tool-selector-button" id="toolSelectorBtn">
            <svg width="16" height="16" viewBox="0 0 408 408" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M397.9,83c5.5,0,10-4.5,10.1-10V10.1C408,4.5,403.5,0,397.9,0H335c-5.5,0-10,4.5-10,10.1V32H83V10.1c0-5.5-4.5-10-10-10.1 H10.1C4.6,0,0.1,4.5,0,10.1V73c0,5.5,4.5,10,10.1,10H32v242H10.1c-5.5,0-10,4.5-10.1,10v62.9c0,5.5,4.5,10,10.1,10.1H73 c5.5,0,10-4.5,10-10.1V376h242v21.9c0,5.5,4.5,10,10,10.1h62.9c5.5,0,10-4.5,10.1-10.1V335c0-5.5-4.5-10-10.1-10H376V83H397.9z M20,63V20h43v43H20z M63,388H20v-43h43V388z M325,335v21H83v-21c0-5.5-4.5-10-10-10H52V83h21c5.5,0,10-4.5,10-10V52h242v21 c0,5.5,4.5,10,10,10h21v242h-21C329.5,325,325,329.5,325,335z M388,345v43h-43v-43H388z M345,63V20h43v43H345z"
                fill="currentColor" />
            </svg>
          </button>
          <div class="tool-selector-dropdown" id="toolSelectorDropdown">
            <button type="button" id="toolRectOpt" class="tool-selector-option selected" data-tool="rect">
              <svg width="16" height="16" viewBox="0 0 408 408" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M397.9,83c5.5,0,10-4.5,10.1-10V10.1C408,4.5,403.5,0,397.9,0H335c-5.5,0-10,4.5-10,10.1V32H83V10.1c0-5.5-4.5-10-10-10.1 H10.1C4.6,0,0.1,4.5,0,10.1V73c0,5.5,4.5,10,10.1,10H32v242H10.1c-5.5,0-10,4.5-10.1,10v62.9c0,5.5,4.5,10,10.1,10.1H73 c5.5,0,10-4.5,10-10.1V376h242v21.9c0,5.5,4.5,10,10,10.1h62.9c5.5,0,10-4.5,10.1-10.1V335c0-5.5-4.5-10-10.1-10H376V83H397.9z M20,63V20h43v43H20z M63,388H20v-43h43V388z M325,335v21H83v-21c0-5.5-4.5-10-10-10H52V83h21c5.5,0,10-4.5,10-10V52h242v21 c0,5.5,4.5,10,10,10h21v242h-21C329.5,325,325,329.5,325,335z M388,345v43h-43v-43H388z M345,63V20h43v43H345z"
                  fill="currentColor" />
              </svg>
              <span id="toolRectOptText">Rectangle</span>
            </button>
            <button type="button" id="toolPenOpt" class="tool-selector-option" data-tool="pen">
              <svg width="16" height="16" viewBox="0 0 511 511.99899" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="m499.226562 13.261719c-19.519531-19.527344-122.300781 51.597656-212.113281 141.410156-52.699219 52.695313-113.722656 124.609375-137.8125 165.597656l42.917969 42.917969c40.988281-24.089844 112.902344-85.113281 165.597656-137.8125 89.8125-89.8125 160.9375-192.59375 141.410156-212.113281zm0 0"
                  fill="currentColor" />
              </svg>
              <span id="toolPenOptText">Pen</span>
            </button>
            <button type="button" id="toolLassoOpt" class="tool-selector-option" data-tool="lasso">
              <svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M508.517,132.993c-10.806-40.332-45.494-71.333-97.674-87.291c-50.598-15.474-112.04-15.003-172.994,1.329 c-60.956,16.333-114.4,46.643-150.483,85.347c-37.211,39.91-51.75,84.101-40.942,124.433 c10.806,40.332,45.494,71.333,97.674,87.291c24.586,7.519,51.722,11.273,80.127,11.273c11.348,0,22.898-0.604,34.568-1.802 c-17.458,34.138-47.436,32.647-81.223,30.918c-33.163-1.688-70.762-3.611-90.449,35.762 c-11.362,22.726-24.247,35.438-38.295,37.785c-17.517,2.916-32.374-11.452-32.493-11.567c-3.733-3.735-9.797-3.735-13.53,0 c-3.737,3.737-3.737,9.794,0,13.532c0.79,0.79,17.865,17.57,41.215,17.568c2.511,0,5.097-0.194,7.741-0.624 c20.516-3.329,38.171-19.524,52.479-48.135c13.408-26.818,36.221-27.055,72.355-25.209c37.319,1.903,82.906,4.224,104.38-53.018 c12.002-1.988,24.071-4.584,36.119-7.812c60.956-16.333,114.4-46.643,150.483-85.347 C504.787,217.516,519.326,173.325,508.517,132.993z"
                  fill="currentColor" />
              </svg>
              <span id="toolLassoOptText">Lasso</span>
            </button>
            <button type="button" id="toolWandOpt" class="tool-selector-option" data-tool="wand">
              <svg width="16" height="16" viewBox="0 0 467.374 467.374" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M459.657,82.222c0-5.136-1.704-9.419-5.133-12.843l-56.531-56.531c-3.425-3.427-7.706-5.14-12.847-5.14 c-5.144,0-9.421,1.713-12.847,5.14L5.14,380.005C1.709,383.434,0,387.719,0,392.858c0,5.141,1.709,9.418,5.14,12.847 l56.529,56.527c3.431,3.429,7.708,5.141,12.85,5.141c5.137,0,9.419-1.704,12.847-5.141l367.162-367.16 C457.953,91.642,459.657,87.364,459.657,82.222z M332.038,165.877l-30.546-30.55l83.651-83.654l30.546,30.549L332.038,165.877z"
                  fill="currentColor" />
                <polygon
                  points="65.384,73.087 73.948,45.109 101.925,36.545 73.948,27.979 65.384,0.001 56.818,27.979 28.84,36.545 56.818,45.109"
                  fill="currentColor" />
                <polygon
                  points="139.61,108.494 156.743,164.455 173.876,108.494 229.835,91.361 173.876,74.23 156.743,18.269 139.61,74.23 83.651,91.361"
                  fill="currentColor" />
              </svg>
              <span id="toolWandOptText">Wand</span>
            </button>
          </div>
        </div>
        <input type="hidden" id="areaTool" value="rect">
        <button type="button" id="areaUndo" class="icon-btn" title="–û—Ç–º–µ–Ω–∏—Ç—å —Ç–æ—á–∫—É" aria-label="–û—Ç–º–µ–Ω–∏—Ç—å —Ç–æ—á–∫—É">
          <svg width="14" height="14" viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg">
            <path
              d="m64 24.759h-36.24l21.93-17.615c1.723-1.383 1.997-3.901.613-5.624-1.383-1.723-3.901-1.997-5.623-.614l-30.792 24.735c-.945.759-1.495 1.906-1.495 3.119s.55 2.359 1.495 3.119l30.793 24.734c.738.593 1.623.881 2.502.881 1.171 0 2.331-.511 3.121-1.495 1.384-1.722 1.109-4.24-.613-5.624l-21.931-17.616h36.24c24.045 0 43.607 19.562 43.607 43.607s-19.562 43.608-43.607 43.608h-47.607c-2.209 0-4 1.791-4 4s1.791 4 4 4h47.607c28.456 0 51.607-23.151 51.607-51.607s-23.151-51.608-51.607-51.608z"
              fill="currentColor" />
          </svg>
        </button>
        <button type="button" id="areaDelete" class="icon-btn" title="–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç—É—Ä" aria-label="–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç—É—Ä">
          <svg width="14" height="14" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
            <path
              d="m255.624 0v225.019c24.267 6.607 42.168 28.826 42.168 55.157 0 31.522-25.646 57.168-57.168 57.168s-57.168-25.646-57.168-57.168c0-26.332 17.901-48.55 42.168-55.157v-225.019h-32.414l-162.472 318.223c31.621 27.162 51.577 65.778 55.491 107.191h308.789c3.914-41.413 23.871-80.029 55.492-107.191l-162.472-318.223z"
              fill="currentColor" />
            <path d="m86.951 455.414h307.345v56.586h-307.345z" fill="currentColor" />
            <circle cx="240.624" cy="280.176" r="27.168" fill="currentColor" />
            <path d="m380.059 35.602h101.203v30h-101.203z" fill="currentColor" />
          </svg>
        </button>
        <button type="button" id="areaClear" class="icon-btn clear-btn" title="–û—á–∏—Å—Ç–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ"
          aria-label="–û—á–∏—Å—Ç–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ">üóëÔ∏è</button>
        <span id="areaHelp"
          title="–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤—ã–¥–µ–ª–µ–Ω–∏—è:\n- –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫: –ø–æ—Ç—è–Ω–∏—Ç–µ –õ–ö–ú.\n- –ü–µ—Ä–æ: –∫–ª–∏–∫–∏ —Å—Ç–∞–≤—è—Ç —Ç–æ—á–∫–∏, –ø–µ—Ä–µ—Ç—è–≥–∏–≤–∞–Ω–∏–µ –ø—Ä–∏ –∫–ª–∏–∫–µ –∑–∞–¥–∞—ë—Ç —Ä—É—á–∫—É. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –∏–ª–∏ –∫–ª–∏–∫ –ø–æ –ø–µ—Ä–≤–æ–π —Ç–æ—á–∫–µ ‚Äî –∑–∞–º–∫–Ω—É—Ç—å. Esc ‚Äî –æ—Ç–º–µ–Ω–∞, Backspace ‚Äî —É–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫—É.\n- –õ–∞—Å—Å–æ: –∑–∞–∂–º–∏—Ç–µ –õ–ö–ú –∏ –≤–µ–¥–∏—Ç–µ –º—ã—à—å—é, –æ—Ç–ø—É—Å—Ç–∏—Ç–µ –¥–ª—è –∑–∞–º—ã–∫–∞–Ω–∏—è.\n–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç—É—Ä—ã –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è. –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∏ –∏—Ç–æ–≥ —É—á–∏—Ç—ã–≤–∞—é—Ç –º–∞—Å–∫—É."
          style="cursor:help; font-weight:700; user-select:none;">?</span>
      </div>
    </div>

    <div style="margin-top: 12px;">
      <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
        <input type="checkbox" id="ignoreEffects" style="margin:0;" checked>
        <span id="ignoreEffectsLabel">–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —ç—Ñ—Ñ–µ–∫—Ç—ã (—Ç–µ–Ω–∏, —Ä–∞–∑–º—ã—Ç–∏–µ)</span>
      </label>
      <div class="hint" id="ignoreEffectsHint" style="margin-top: 4px; margin-left: 26px;">
        –û—Ç–∫–ª—é—á–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç—ã —Å–ª–æ—è –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
      </div>
    </div>
  </div>

  <div class="card">
    <div class="group-title" id="sourceColorGroup">Source Color</div>
    <div class="hint" id="sourceStepHint" style="color: #64748b; font-weight: 500; margin-bottom: 8px;">
      üìç Step 1: Enter or pick the color you want to replace
    </div>
    <label for="src-color-input" id="srcColorLabel">Color to replace (HEX, optional)</label>
    <input type="text" id="src-color-input" placeholder="#RRGGBB (if not specified ‚Äî taken from marker point)">
    <div class="row" style="margin:6px 0 10px;">
      <button id="pipette-src-btn" type="button" class="icon-btn pipette-source" title="Source pipette"
        aria-label="Source pipette">
        <svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
          <path
            d="m249.094 108.056 32.839-32.839c3.913-3.913 10.257-3.913 14.17 0l23.935 23.935 8.095-8.095 61.815-61.815c25.629-25.629 67.182-25.629 92.811 0 25.629 25.629 25.629 67.182 0 92.811l-60.414 60.414-9.496 9.496 23.935 23.935c3.913 3.913 3.913 10.257 0 14.17l-32.839 32.839c-3.913 3.913-10.257 3.913-14.17 0l-140.68-140.68c-3.914-3.914-3.914-10.258-.001-14.171z"
            fill="currentColor" opacity="0.9" />
          <path
            d="m17.342 459.301 19.556-19.556c-9.905-23.811-5.185-52.269 14.183-71.637l74.004-74.004 63.519-63.519 84.424-84.425 92.811 92.811-221.947 221.947c-19.368 19.368-47.826 24.088-71.637 14.183l-19.556 19.556c-9.763 9.763-25.593 9.763-35.357 0-9.763-9.762-9.763-25.592 0-35.356z"
            fill="currentColor" opacity="0.7" />
          <path
            d="m318.138 359.318-34.705 72.373c-15.62 32.574 8.121 70.289 44.247 70.289 36.125 0 59.867-37.715 44.247-70.289l-34.705-72.373c-3.842-8.008-15.244-8.008-19.084 0z"
            fill="currentColor" opacity="0.7" />
        </svg>
      </button>
      <span id="srcPipetteHint" class="hint">Click on preview to pick source color</span>
    </div>
    <div class="hint" id="sourceTip" style="color: #f59e0b; font-weight: 600; margin-top: 4px;">
      üí° Tip: Use the green eyedropper to precisely pick the source color from the image
    </div>
  </div>

  <div class="card">
    <div class="group-title" id="targetColorGroup">Target Color</div>
    <div class="hint" id="targetStepHint" style="color: #64748b; font-weight: 500; margin-bottom: 8px;">
      üéØ Step 2: Enter or pick the new color for replacement
    </div>
    <label for="color-input" id="targetColorLabel">Desired color (HEX)</label>
    <input type="text" id="color-input" placeholder="#AABBCC">
    <div class="row" style="margin:6px 0 10px;">
      <button id="pipette-btn" type="button" class="icon-btn pipette-target" title="Pipette" aria-label="Pipette">
        <svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
          <path
            d="m249.094 108.056 32.839-32.839c3.913-3.913 10.257-3.913 14.17 0l23.935 23.935 8.095-8.095 61.815-61.815c25.629-25.629 67.182-25.629 92.811 0 25.629 25.629 25.629 67.182 0 92.811l-60.414 60.414-9.496 9.496 23.935 23.935c3.913 3.913 3.913 10.257 0 14.17l-32.839 32.839c-3.913 3.913-10.257 3.913-14.17 0l-140.68-140.68c-3.914-3.914-3.914-10.258-.001-14.171z"
            fill="currentColor" opacity="0.9" />
          <path
            d="m17.342 459.301 19.556-19.556c-9.905-23.811-5.185-52.269 14.183-71.637l74.004-74.004 63.519-63.519 84.424-84.425 92.811 92.811-221.947 221.947c-19.368 19.368-47.826 24.088-71.637 14.183l-19.556 19.556c-9.763 9.763-25.593 9.763-35.357 0-9.763-9.762-9.763-25.592 0-35.356z"
            fill="currentColor" opacity="0.7" />
          <path
            d="m318.138 359.318-34.705 72.373c-15.62 32.574 8.121 70.289 44.247 70.289 36.125 0 59.867-37.715 44.247-70.289l-34.705-72.373c-3.842-8.008-15.244-8.008-19.084 0z"
            fill="currentColor" opacity="0.7" />
        </svg>
      </button>
      <span id="pipette-hint" class="hint">Click on image to set target color</span>
      <span id="picked-swatch"
        style="width:16px; height:16px; border-radius:3px; border:1px solid #ccc; display:inline-block;"></span>
      <span id="picked-hex" style="font-size:12px; color:inherit;"></span>
    </div>
    <div id="colorPicker" style="display:flex; align-items:flex-start; gap:8px;">
      <canvas id="cpSquare" width="200" height="140"
        style="width:200px; height:140px; border:1px solid #d6ddeb; border-radius:8px; background:#fff; cursor:crosshair;"></canvas>
      <canvas id="cpHue" width="20" height="140"
        style="width:20px; height:140px; border:1px solid #d6ddeb; border-radius:8px; cursor:ns-resize;"></canvas>
    </div>
  </div>

  <div class="card">
    <div class="row" style="margin-bottom:4px;">
      <strong style="font-size:13px;" id="ignoreGroupTitle">–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ü–≤–µ—Ç–∞</strong>
      <span class="hint" id="ignoreGroupHint">(–Ω–µ –∏–∑–º–µ–Ω—è—Ç—å)</span>
    </div>
    <div class="row" style="margin-bottom:4px;">
      <input type="text" id="ignore-hex" placeholder="#RRGGBB" style="flex:1;">
      <button id="ignore-add" type="button" class="icon-btn" title="–î–æ–±–∞–≤–∏—Ç—å" aria-label="–î–æ–±–∞–≤–∏—Ç—å">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 5V19M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
        </svg>
      </button>
      <button id="pipette-ignore-btn" type="button" class="icon-btn pipette-ignore" title="–ü–∏–ø–µ—Ç–∫–∞ –∏–≥–Ω–æ—Ä–∞"
        aria-label="–ü–∏–ø–µ—Ç–∫–∞ –∏–≥–Ω–æ—Ä–∞">
        <svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
          <path
            d="m249.094 108.056 32.839-32.839c3.913-3.913 10.257-3.913 14.17 0l23.935 23.935 8.095-8.095 61.815-61.815c25.629-25.629 67.182-25.629 92.811 0 25.629 25.629 25.629 67.182 0 92.811l-60.414 60.414-9.496 9.496 23.935 23.935c3.913 3.913 3.913 10.257 0 14.17l-32.839 32.839c-3.913 3.913-10.257 3.913-14.17 0l-140.68-140.68c-3.914-3.914-3.914-10.258-.001-14.171z"
            fill="currentColor" opacity="0.9" />
          <path
            d="m17.342 459.301 19.556-19.556c-9.905-23.811-5.185-52.269 14.183-71.637l74.004-74.004 63.519-63.519 84.424-84.425 92.811 92.811-221.947 221.947c-19.368 19.368-47.826 24.088-71.637 14.183l-19.556 19.556c-9.763 9.763-25.593 9.763-35.357 0-9.763-9.762-9.763-25.592 0-35.356z"
            fill="currentColor" opacity="0.7" />
          <path
            d="m318.138 359.318-34.705 72.373c-15.62 32.574 8.121 70.289 44.247 70.289 36.125 0 59.867-37.715 44.247-70.289l-34.705-72.373c-3.842-8.008-15.244-8.008-19.084 0z"
            fill="currentColor" opacity="0.7" />
        </svg>
      </button>
    </div>
    <div id="ignore-list" style="display:flex; flex-wrap:wrap; gap:6px;"></div>
    <div class="hint" id="ignoreNote" style="margin-top:4px;">–î–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–µ –∂–µ –ø–æ—Ä–æ–≥–∏, —á—Ç–æ –≤—ã—à–µ</div>
  </div>

  <div class="card">
    <div class="group-title" id="thresholdsTitle">Thresholds</div>
    <div class="hint" id="thresholdsStepHint" style="color: #64748b; font-weight: 500; margin-bottom: 8px;">
      ‚öôÔ∏è Step 3: Adjust how similar colors should be to get replaced
    </div>
    <div class="row-grid" style="margin:8px 0 0;">
      <label for="hueTol" id="hueTolLabel">Hue threshold (¬∞)</label>
      <span id="hueTolVal" class="hint">12</span>
      <input type="range" id="hueTol" min="0" max="60" step="1" value="25" style="grid-column:1 / span 2;">

      <label for="satTol" id="satTolLabel">Saturation threshold</label>
      <span id="satTolVal" class="hint">0.15</span>
      <input type="range" id="satTol" min="0" max="100" step="1" value="25" style="grid-column:1 / span 2;">

      <label for="lightTol" id="lightTolLabel">Lightness threshold</label>
      <span id="lightTolVal" class="hint">0.15</span>
      <input type="range" id="lightTol" min="0" max="100" step="1" value="25" style="grid-column:1 / span 2;">

      <label for="intensity" id="intensityLabel">Hardness/Intensity (%)</label>
      <span id="intensityVal" class="hint">100%</span>
      <input type="range" id="intensity" min="0" max="100" step="1" value="100" style="grid-column:1 / span 2;">
    </div>
  </div>

  <div class="card">
    <div class="group-title" id="modesTitle">Modes</div>
    <div class="options" id="replaceMode">
      <label><input type="radio" name="replace-mode" value="target"> <span id="modeTarget">To Target
          (RGB)</span></label>
      <label><input type="radio" name="replace-mode" value="hsl" checked> <span id="modeHsl">HSL Shift</span></label>
    </div>
    <div class="group-title" id="applyToTitle" style="margin-top:12px;">Apply to</div>
    <div class="options" id="applyMode">
      <label><input type="radio" name="apply-mode" value="original" checked> <span
          id="applyOriginal">Original</span></label>
      <label><input type="radio" name="apply-mode" value="copy"> <span id="applyCopy">Copy</span></label>
    </div>
  </div>

  <!-- License info block -->
  <div id="licenseInfo" class="card" style="display:none; margin-top:8px;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
      <div style="flex:1;">
        <div id="licenseStatusText" style="font-size:13px; font-weight:600; margin-bottom:2px;"></div>
        <div id="licenseDetailsText" style="font-size:11px; color:#666;"></div>
      </div>
      <button id="upgradeBtn" class="button-secondary"
        style="display:none; padding:6px 12px; font-size:12px; font-weight:600;">
        <span id="upgradeBtnText">Get Pro</span>
      </button>
    </div>
  </div>

  <button id="create-btn" class="primary-button" disabled>–°–æ–∑–¥–∞—Ç—å</button>

  <!-- License Modal -->
  <div id="licenseModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modalTitle">–õ–∏–º–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç–∏–≥–Ω—É—Ç</h3>
        <button id="modalClose" class="modal-close">√ó</button>
      </div>
      <div class="modal-body">
        <p id="modalMessage">–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ 5 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫. –ü–æ–ª—É—á–∏—Ç–µ Pro –≤–µ—Ä—Å–∏—é –¥–ª—è –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞.
        </p>
        <div class="modal-features">
          <div class="feature" id="modalFeature">‚ú® –ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–±–æ—Ç–æ–∫</div>
        </div>
        <div class="modal-price">
          <div class="price" id="modalPrice">$4.99 / month</div>
          <div class="price-note" id="modalPriceNote">or $39.99 / year (33% savings)</div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="buyProBtn" class="primary-button">–ö—É–ø–∏—Ç—å —á–µ—Ä–µ–∑ Telegram</button>
        <button id="getCodeBtn" class="button-secondary" style="margin-top: 8px;">
          <span id="getCodeBtnText">–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥ (–µ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∞)</span>
        </button>

        <!-- Activation key section -->
        <div id="activationSection" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
          <div style="text-align: center; margin-bottom: 12px;">
            <span id="activationLabel" style="font-size: 14px; color: #6b7280;">–£–∂–µ –µ—Å—Ç—å –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏?</span>
          </div>
          <div style="display: flex; gap: 8px;">
            <input type="text" id="activationKey" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (CT-...)"
              style="flex: 1; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 8px; font-size: 14px;">
            <button id="activateBtn" class="button-secondary" style="padding: 8px 16px; font-size: 14px;">
              <span id="activateBtnText">–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å</span>
            </button>
          </div>

          <!-- Test button for simulating different device -->


          <div id="activationError"
            style="display: none; margin-top: 8px; padding: 8px; background: #fef2f2; border: 1px solid #fecaca; border-radius: 6px; color: #dc2626; font-size: 12px; text-align: center;">
          </div>
          <div id="activationSuccess"
            style="display: none; margin-top: 8px; padding: 8px; background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 6px; color: #15803d; font-size: 12px; text-align: center;">
          </div>
          <div id="activationInfo"
            style="display: none; margin-top: 8px; padding: 8px; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 6px; color: #0369a1; font-size: 12px; text-align: center;">
          </div>
        </div>

        <button id="modalCancel" class="button-secondary" style="margin-top: 12px;">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </div>
  </div>

  <!-- Subscription Info Modal -->
  <div id="subscriptionModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="subModalTitle">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ</h3>
        <button id="subModalClose" class="modal-close">√ó</button>
      </div>
      <div class="modal-body">
        <!-- Subscription Status -->
        <div id="subStatusSection" style="margin-bottom: 20px;">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
            <div class="status-badge pro" id="subStatusBadge">
              <svg class="status-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2L15.09 8.26L22 9L17 14L18.18 21L12 17.77L5.82 21L7 14L2 9L8.91 8.26L12 2Z"
                  fill="currentColor" />
              </svg>
              <span id="subStatusText">PRO</span>
            </div>
            <div style="flex: 1;">
              <div id="subStatusDescription" style="font-weight: 600; color: #374151;">–ê–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞</div>
              <div id="subStatusDetails" style="font-size: 12px; color: #6b7280;">–ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º
              </div>
            </div>
          </div>
        </div>

        <!-- Subscription Details -->
        <div id="subDetailsSection"
          style="background: #f9fafb; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
            <div>
              <div id="subTypeLabel" style="color: #6b7280; margin-bottom: 4px;">–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏</div>
              <div id="subType" style="font-weight: 600; color: #374151;">–ú–µ—Å—è—á–Ω–∞—è</div>
            </div>
            <div>
              <div id="subPurchaseDateLabel" style="color: #6b7280; margin-bottom: 4px;">–î–∞—Ç–∞ –ø–æ–∫—É–ø–∫–∏</div>
              <div id="subPurchaseDate" style="font-weight: 600; color: #374151;">24.10.2025</div>
            </div>
            <div>
              <div id="subExpiryDateLabel" style="color: #6b7280; margin-bottom: 4px;">–ò—Å—Ç–µ–∫–∞–µ—Ç</div>
              <div id="subExpiryDate" style="font-weight: 600; color: #374151;">24.11.2025</div>
            </div>
            <div>
              <div id="subDaysLeftLabel" style="color: #6b7280; margin-bottom: 4px;">–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π</div>
              <div id="subDaysLeft" style="font-weight: 600; color: #374151;">31</div>
            </div>
          </div>
        </div>

        <!-- Usage Stats (for FREE users) -->
        <div id="subUsageSection" class="hidden"
          style="background: #fef3c7; border-radius: 8px; padding: 16px; margin-bottom: 20px; border: 1px solid #f59e0b;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M12 9V13M12 17H12.01M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z"
                stroke="#d97706" stroke-width="2" stroke-linecap="round" />
            </svg>
            <span id="subFreeVersionTitle" style="font-weight: 600; color: #92400e;">–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≤–µ—Ä—Å–∏—è</span>
          </div>
          <div id="subUsageText" style="font-size: 14px; color: #92400e;">
            –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: <span id="subUsageCount">0</span> –∏–∑ 5 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
          </div>
          <div style="background: #fbbf24; height: 4px; border-radius: 2px; margin-top: 8px; overflow: hidden;">
            <div id="subUsageBar" style="background: #d97706; height: 100%; width: 0%; transition: width 0.3s ease;">
            </div>
          </div>
        </div>

        <!-- Expiry Warning -->
        <div id="subWarningSection" class="hidden"
          style="background: #fef2f2; border-radius: 8px; padding: 16px; margin-bottom: 20px; border: 1px solid #ef4444;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M12 9V13M12 17H12.01M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z"
                stroke="#dc2626" stroke-width="2" stroke-linecap="round" />
            </svg>
            <span id="subWarningTitle" style="font-weight: 600; color: #dc2626;">–ü–æ–¥–ø–∏—Å–∫–∞ —Å–∫–æ—Ä–æ –∏—Å—Ç–µ–∫–∞–µ—Ç!</span>
          </div>
          <div id="subWarningText" style="font-size: 14px; color: #dc2626;">
            –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ 3 –¥–Ω—è. –ü—Ä–æ–¥–ª–∏—Ç–µ –µ—ë, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø –∫ Pro —Ñ—É–Ω–∫—Ü–∏—è–º.
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <!-- Action buttons based on subscription status -->
        <div id="subActionsSection">
          <!-- For PRO users -->
          <div id="subProActions" class="hidden">
            <button id="subRenewBtn" class="primary-button" style="margin-bottom: 8px;">
              <span id="subRenewBtnText">–ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É</span>
            </button>
            <button id="subManageBtn" class="button-secondary" style="margin-bottom: 8px;">
              <span id="subManageBtnText">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–æ–π</span>
            </button>
          </div>

          <!-- For FREE users -->
          <div id="subFreeActions" class="hidden">
            <button id="subUpgradeBtn" class="primary-button" style="margin-bottom: 8px;">
              <span id="subUpgradeBtnText">–ü–æ–ª—É—á–∏—Ç—å PRO</span>
            </button>
            <button id="subRecoverBtn" class="button-recovery" style="margin-bottom: 8px;">
              <span id="subRecoverBtnText">–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É</span>
            </button>
          </div>
        </div>

        <button id="subModalCancel" class="button-secondary">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
  </div>

  <div class="footer">
    <a href="https://t.me/senseyko666" target="_blank" rel="noopener" class="footer-link" id="footerLink">by Sensey</a>
  </div>

  <script>
    // Predeclare to avoid TDZ errors before translations are assigned
    var translations = {};
    // Predeclare state early to avoid TDZ when theme renders before language init
    var state = { language: 'ru' };
    // ----- Theme -----
    function getStoredTheme() { try { return localStorage.getItem('sensey-theme'); } catch (e) { return null; } }
    function storeTheme(v) { try { localStorage.setItem('sensey-theme', v); } catch (e) { } }
    function setTheme(theme) { var t = (theme === 'dark') ? 'dark' : 'light'; document.documentElement.setAttribute('data-theme', t); storeTheme(t); renderThemeToggle(); }
    function toggleTheme() { setTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'); }
    function renderThemeToggle() { var btn = document.getElementById('themeToggle'); if (!btn) return; var dark = document.documentElement.getAttribute('data-theme') === 'dark'; var pack = (translations && translations[state.language]) || (translations && translations.en) || { theme_light: 'Light theme', theme_dark: 'Dark theme' }; btn.textContent = dark ? '‚òÄÔ∏è' : 'üåô'; btn.title = dark ? pack.theme_light : pack.theme_dark; }
    function initTheme() { var s = getStoredTheme(); if (s) { setTheme(s); } else { var prefers = false; try { prefers = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch (e) { } setTheme(prefers ? 'dark' : 'light'); } var btn = document.getElementById('themeToggle'); if (btn && !btn.__w) { btn.__w = true; btn.addEventListener('click', () => setTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark')); } }
    initTheme();

    // ----- Languages -----
    function getStoredLanguage() {
      // In Figma plugins, we rely on figma.clientStorage only
      // localStorage is not available, so we return default and wait for Figma storage response
      console.log('Using default language, waiting for Figma storage response');
      return 'ru';
    }
    function storeLanguage(code) {
      // Store only in Figma clientStorage (localStorage is not available in Figma plugins)
      if (typeof parent !== 'undefined' && parent.postMessage) {
        parent.postMessage({ pluginMessage: { type: 'store-language', language: code } }, '*');
        console.log('Sent language to Figma storage:', code);
      } else {
        console.log('Cannot store language: parent not available');
      }
    }
    const languages = [
      { code: 'en', name: 'English', flag: createFlag(['#ffffff', '#cf142b', '#00247d']) },
      { code: 'ru', name: '–†—É—Å—Å–∫–∏–π', flag: createFlag(['#ffffff', '#0039a6', '#d52b1e']) },
      { code: 'uk', name: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞', flag: createFlag(['#0057b8', '#ffd700']) },
      { code: 'kk', name: '“ö–∞–∑–∞“õ', flag: createFlag(['#00afca', '#f8d64e', '#00afca']) },
      { code: 'ko', name: 'ÌïúÍµ≠Ïñ¥', flag: createFlag(['#ffffff', '#ffffff', '#ffffff']) },
      { code: 'es', name: 'Espa√±ol', flag: createFlag(['#aa151b', '#f1bf00', '#aa151b']) },
      { code: 'de', name: 'Deutsch', flag: createFlag(['#000000', '#dd0000', '#ffce00']) },
      { code: 'ja', name: 'Êó•Êú¨Ë™û', flag: createFlag(['#ffffff', '#ffffff', '#ffffff']) },
    ];
    function createFlag(stripes) { const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'>${stripes.map((c, i) => `<rect x='0' y='${i * (40 / stripes.length)}' width='40' height='${40 / stripes.length}' fill='${c}' />`).join('')}</svg>`; return `data:image/svg+xml,${encodeURIComponent(svg)}`; }
    function renderFlag(container, lang) {
      container.textContent = '';
      const img = document.createElement('img');
      img.alt = lang.name;
      if (lang.code === 'ja') {
        const s = `<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'><rect width='40' height='40' fill='#ffffff'/><circle cx='20' cy='20' r='10' fill='#bc002d'/></svg>`;
        img.src = `data:image/svg+xml,${encodeURIComponent(s)}`;
      } else if (lang.code === 'ko') {
        // Taegeuk (simplified): top red half, bottom blue half clipped to circle
        const s = `<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'>
      <defs><clipPath id='cp'><circle cx='20' cy='20' r='10'/></clipPath></defs>
      <rect width='40' height='40' fill='#ffffff'/>
      <rect x='10' y='10' width='20' height='10' fill='#CD2E3A' clip-path='url(#cp)'/>
      <rect x='10' y='20' width='20' height='10' fill='#0047A0' clip-path='url(#cp)'/>
    </svg>`;
        img.src = `data:image/svg+xml,${encodeURIComponent(s)}`;
      } else if (lang.code === 'en') {
        // GB (simplified Union Jack)
        const s = `<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'>
      <rect width='40' height='40' fill='#00247D'/>
      <rect x='0' y='17' width='40' height='6' fill='#FFFFFF'/>
      <rect x='17' y='0' width='6' height='40' fill='#FFFFFF'/>
      <rect x='0' y='18' width='40' height='4' fill='#CF142B'/>
      <rect x='18' y='0' width='4' height='40' fill='#CF142B'/>
    </svg>`;
        img.src = `data:image/svg+xml,${encodeURIComponent(s)}`;
      } else {
        img.src = lang.flag;
      }
      container.appendChild(img);
    }

    translations = {
      en: {
        title: 'Color Target',
        theme_light: 'Light theme',
        theme_dark: 'Dark theme',

        preview_placeholder: 'Select an image',
        zoom_label: 'Preview zoom',
        zoom_hint: 'Zoom affects only picking precision, not the final image',
        target_group: 'Target color',
        target_label: 'Desired color (HEX)',
        target_step_hint: 'üéØ Step 2: Enter or pick the new color for replacement',
        pipette: 'Eyedropper',
        pipette_hint: 'Click preview to set target color',
        source_group: 'Source color',
        source_label: 'Color to replace (optional HEX)',
        source_step_hint: 'üìç Step 1: Enter or pick the color you want to replace',
        src_placeholder: '#RRGGBB (if omitted ‚Äî taken from marker point)',
        source_hint: 'Click preview to set source color',
        ignore_title: 'Ignore colors',
        ignore_hint: '(will not be replaced)',
        ignore_note: 'Same thresholds as below are used for comparison',
        pipette_src: 'Source eyedropper',
        pipette_ignore: 'Ignore eyedropper',
        apply_original: 'Apply to original',
        apply_copy: 'Apply to copy',
        thresholds_title: 'Thresholds',
        thresholds_step_hint: '‚öôÔ∏è Step 3: Adjust how similar colors should be to get replaced',
        hue_label: 'Hue threshold (¬∞)',
        sat_label: 'Saturation threshold',
        light_label: 'Lightness threshold',
        intensity_label: 'Hardness/Intensity (%)',
        create: 'Create',
        alert_pick_point_or_hex: 'Pick a point on the image or specify a source HEX!',
        alert_enter_hex: 'Enter a valid HEX color!',
        alert_processing_error: 'Image processing error',
        footer: 'by Sensey',
        preview_toggle: 'Result preview',
        preview_opacity: 'Result opacity',
        area_toggle: 'Limit area',
        area_clear: 'Clear',
        ignore_effects: 'Ignore effects (shadows, blur)',
        ignore_effects_hint: 'Disables layer effects on export for accurate positioning',
        expand_full: 'Fullscreen',
        restore_full: 'Restore size',
        // Fullscreen mode
        fs_selection: 'Selection',
        fs_zoom: 'Zoom',
        fs_colors: 'Colors',
        fs_thresholds: 'Thresholds',
        fs_thresholds_step: '‚öôÔ∏è Step 3: Adjust similarity',
        fs_modes: 'Modes',
        fs_ignore: 'Ignore',
        fs_target_color: 'üéØ Step 2 - Target:',
        fs_source_color: 'üìç Step 1 - Source:',
        fs_hue: 'Hue',
        fs_saturation: 'Saturation',
        fs_lightness: 'Lightness',
        fs_intensity: 'Intensity',
        fs_modes_title: 'Modes',
        fs_apply_to_title: 'Apply to',
        fs_original: 'Original',
        fs_copy: 'Copy',
        fs_hsl: 'HSL',
        fs_rgb: 'RGB',
        // Tool tooltips
        tool_rectangle: 'Rectangle',
        tool_pen: 'Pen',
        tool_lasso: 'Lasso',
        tool_wand: 'Magic Wand',
        tool_new_path: 'New Path',
        tool_undo_point: 'Undo Point',
        tool_delete_path: 'Delete Path',
        tool_add: 'Add',
        // Buttons
        btn_zoom_out: 'Zoom Out',
        btn_zoom_in: 'Zoom In',
        btn_zoom_fit: 'Fit',
        btn_zoom_100: '100%',
        btn_create: 'Create',
        // Pipette tooltips
        pipette_target_tooltip: 'Pick target color',
        pipette_source_tooltip: 'Pick source color',
        pipette_ignore_tooltip: 'Pick ignore color',
        // Replace modes
        mode_hsl: 'HSL shift',
        mode_target: 'To target (RGB)',
        // Additional hints and tooltips
        source_tip: 'üí° Tip: Use the green eyedropper to precisely pick the source color from the image',
        tools_help: 'Selection tools:\n- Rectangle: drag LMB.\n- Pen: clicks place points, dragging while clicking sets handle. Double click or click first point to close. Esc to cancel, Backspace to delete point.\n- Lasso: hold LMB and drag mouse, release to close.\nMultiple contours are supported. Preview and result take mask into account.',
        // License system
        license_free_uses: 'Free uses',
        license_remaining: 'remaining',
        license_unlimited: 'Unlimited',
        license_get_pro: 'Get Pro',
        license_limit_reached: 'Usage limit reached',
        license_limit_message: 'You have used all 5 free attempts. Get Pro version for unlimited access.',
        license_buy_telegram: 'Buy via Telegram',
        license_pro_active: 'Pro Active',
        license_expires_soon: 'Expires soon!',
        license_days_remaining: 'days remaining',
        license_renew: 'Renew',
        license_feature_unlimited: 'Unlimited processing',
        activation_label: 'Already have an activation key?',
        activation_placeholder: 'Enter activation key (CT-...)',
        activation_button: 'Activate',
        activation_processing: 'Processing...',
        activation_success: 'Pro version activated successfully!',
        activation_error: 'Invalid activation key. Please try again.',
        activation_error_network: 'Network error. Please try again later.',
        activation_error_format: 'Invalid key format. Key should start with CT-',
        activation_error_expired: 'This activation key has expired.',
        activation_error_user: 'This key belongs to a different user.',
        activation_error_device: 'This key is bound to a different device.',
        activation_error_parse: 'Unable to read activation key. Please check the key.',
        activation_error_validation: 'Key validation failed. Please contact support.',
        subscription_reset: 'Subscription has been reset successfully!',
        challenge_error: 'Failed to generate challenge. Please try again.',
        get_code_button: 'Get Code (Have Subscription)',

        // Status badge and subscription modal
        status_pro_tooltip: 'Pro subscription active. Click for details.',
        subscription_info_title: 'Subscription Information',
        subscription_active: 'Active Subscription',
        subscription_unlimited: 'Unlimited access to all features',
        subscription_expiring: 'Subscription Expiring',
        subscription_expiring_desc: 'Your subscription will expire soon',
        subscription_free: 'Free Version',
        subscription_limited: 'Limited to 5 uses',
        subscription_monthly: 'Monthly',
        subscription_yearly: 'Yearly',
        subscription_lifetime: 'Lifetime',
        subscription_promo: 'Promotional',
        subscription_expires_today: 'Your subscription expires today!',
        subscription_expires_soon_days: 'Your subscription expires in {days} days.',
        subscription_expires_week: 'Your subscription expires in {days} days. Consider renewing.',
        subscription_renew: 'Renew Subscription',
        subscription_manage: 'Manage Subscription',
        subscription_upgrade: 'Get PRO',
        subscription_recover: 'Recover Subscription',
        subscription_expiring: 'Subscription Expiring',
        subscription_expiring_desc: 'Your subscription will expire soon',
        subscription_type_label: 'Subscription Type',

        // Pricing
        price_monthly: '$4.99 / month',
        price_yearly_note: 'or $39.99 / year (33% savings)',
        subscription_purchase_date_label: 'Purchase Date',
        subscription_expires_label: 'Expires',
        subscription_days_left_label: 'Days Left',
        subscription_expires_warning: 'Subscription expires soon!',
        subscription_expires_warning_desc: 'Your subscription expires in {days} days. Renew it to keep access to Pro features.',
        subscription_usage_text: 'Used: {used} of 5 free attempts',
        modal_close: 'Close',
        unknown: 'Unknown',
        never: 'Never'
      },
      ru: {
        title: 'Color Target',
        theme_light: '–°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞',
        theme_dark: '–¢—ë–º–Ω–∞—è —Ç–µ–º–∞',

        preview_placeholder: '–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ',
        zoom_label: '–ó—É–º –ø—Ä–µ–≤—å—é',
        zoom_hint: '–ó—É–º –≤–ª–∏—è–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ —Ç–æ—á–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞, –Ω–µ –Ω–∞ –∏—Ç–æ–≥–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ',
        target_group: '–¶–µ–ª–µ–≤–æ–π —Ü–≤–µ—Ç',
        target_label: '–ù—É–∂–Ω—ã–π —Ü–≤–µ—Ç (HEX)',
        target_step_hint: 'üéØ –®–∞–≥ 2: –í–≤–µ–¥–∏—Ç–µ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—ã–π —Ü–≤–µ—Ç –¥–ª—è –∑–∞–º–µ–Ω—ã',
        pipette: '–ü–∏–ø–µ—Ç–∫–∞',
        pipette_hint: '–ö–ª–∏–∫ –ø–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é –∑–∞–¥–∞—Å—Ç —Ü–µ–ª–µ–≤–æ–π —Ü–≤–µ—Ç',
        source_group: '–ò—Å—Ö–æ–¥–Ω—ã–π —Ü–≤–µ—Ç',
        source_label: '–¶–≤–µ—Ç –¥–ª—è –∑–∞–º–µ–Ω—ã (HEX, –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)',
        source_step_hint: 'üìç –®–∞–≥ 1: –í–≤–µ–¥–∏—Ç–µ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –∑–∞–º–µ–Ω–∏—Ç—å',
        src_placeholder: '#RRGGBB (–µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑—ã–≤–∞—Ç—å ‚Äî –±–µ—Ä—ë–º –∏–∑ —Ç–æ—á–∫–∏ —Å –º–∞—Ä–∫–µ—Ä–æ–º)',
        source_hint: '–ö–ª–∏–∫ –ø–æ –ø—Ä–µ–≤—å—é –∑–∞–ø–∏—à–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π —Ü–≤–µ—Ç',
        ignore_title: '–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ü–≤–µ—Ç–∞',
        ignore_hint: '(–Ω–µ –±—É–¥—É—Ç –∑–∞–º–µ–Ω–µ–Ω—ã)',
        ignore_note: '–î–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–µ –∂–µ –ø–æ—Ä–æ–≥–∏, —á—Ç–æ –Ω–∏–∂–µ',
        pipette_src: '–ü–∏–ø–µ—Ç–∫–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞',
        pipette_ignore: '–ü–∏–ø–µ—Ç–∫–∞ –∏–≥–Ω–æ—Ä–∞',
        apply_original: '–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—É',
        apply_copy: '–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫ –∫–æ–ø–∏–∏',
        thresholds_title: '–ü–æ—Ä–æ–≥–∏',
        thresholds_step_hint: '‚öôÔ∏è –®–∞–≥ 3: –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –Ω–∞—Å–∫–æ–ª—å–∫–æ –ø–æ—Ö–æ–∂–∏–º–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ü–≤–µ—Ç–∞ –¥–ª—è –∑–∞–º–µ–Ω—ã',
        hue_label: '–ü–æ—Ä–æ–≥ –æ—Ç—Ç–µ–Ω–∫–∞ (¬∞)',
        sat_label: '–ü–æ—Ä–æ–≥ –Ω–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç–∏',
        light_label: '–ü–æ—Ä–æ–≥ —è—Ä–∫–æ—Å—Ç–∏',
        intensity_label: '–ñ–µ—Å—Ç–∫–æ—Å—Ç—å/–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å (%)',
        create: '–°–æ–∑–¥–∞—Ç—å',
        alert_pick_point_or_hex: '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ—á–∫—É –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –∏—Å—Ö–æ–¥–Ω—ã–π HEX!',
        alert_enter_hex: '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π HEX —Ü–≤–µ—Ç!',
        alert_processing_error: '–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è',
        footer: 'by Sensey',
        preview_toggle: '–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞',
        preview_opacity: '–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞',
        area_toggle: '–û–≥—Ä–∞–Ω–∏—á–∏—Ç—å –æ–±–ª–∞—Å—Ç—å',
        area_clear: '–û—á–∏—Å—Ç–∏—Ç—å',
        ignore_effects: '–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —ç—Ñ—Ñ–µ–∫—Ç—ã (—Ç–µ–Ω–∏, —Ä–∞–∑–º—ã—Ç–∏–µ)',
        ignore_effects_hint: '–û—Ç–∫–ª—é—á–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç—ã —Å–ª–æ—è –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è',
        expand_full: '–ù–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω',
        restore_full: '–°–≤–µ—Ä–Ω—É—Ç—å',
        // Fullscreen mode
        fs_selection: '–í—ã–¥–µ–ª–µ–Ω–∏–µ',
        fs_zoom: '–ó—É–º',
        fs_colors: '–¶–≤–µ—Ç–∞',
        fs_thresholds: '–ü–æ—Ä–æ–≥–∏',
        fs_thresholds_step: '‚öôÔ∏è –®–∞–≥ 3: –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–æ—Ö–æ–∂–µ—Å—Ç—å',
        fs_modes: '–†–µ–∂–∏–º—ã',
        fs_ignore: '–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å',
        fs_target_color: 'üéØ –®–∞–≥ 2 - –¶–µ–ª–µ–≤–æ–π:',
        fs_source_color: 'üìç –®–∞–≥ 1 - –ò—Å—Ö–æ–¥–Ω—ã–π:',
        fs_hue: '–û—Ç—Ç–µ–Ω–æ–∫',
        fs_saturation: '–ù–∞—Å—ã—â.',
        fs_lightness: '–Ø—Ä–∫–æ—Å—Ç—å',
        fs_intensity: '–ò–Ω—Ç–µ–Ω—Å.',
        fs_modes_title: '–†–µ–∂–∏–º—ã',
        fs_apply_to_title: '–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫',
        fs_original: '–û—Ä–∏–≥–∏–Ω–∞–ª',
        fs_copy: '–ö–æ–ø–∏—è',
        fs_hsl: 'HSL',
        fs_rgb: 'RGB',
        // Tool tooltips
        tool_rectangle: '–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫',
        tool_pen: '–ü–µ—Ä–æ',
        tool_lasso: '–õ–∞—Å—Å–æ',
        tool_wand: '–í–æ–ª—à–µ–±–Ω–∞—è –ø–∞–ª–æ—á–∫–∞',
        tool_new_path: '–ù–æ–≤—ã–π –∫–æ–Ω—Ç—É—Ä',
        tool_undo_point: '–û—Ç–º–µ–Ω–∏—Ç—å —Ç–æ—á–∫—É',
        tool_delete_path: '–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç—É—Ä',
        tool_add: '–î–æ–±–∞–≤–∏—Ç—å',
        // Buttons
        btn_zoom_out: '–£–º–µ–Ω—å—à–∏—Ç—å',
        btn_zoom_in: '–£–≤–µ–ª–∏—á–∏—Ç—å',
        btn_zoom_fit: '–ü–æ —Ä–∞–∑–º–µ—Ä—É',
        btn_zoom_100: '100%',
        btn_create: '–°–æ–∑–¥–∞—Ç—å',
        // Pipette tooltips
        pipette_target_tooltip: '–í—ã–±—Ä–∞—Ç—å —Ü–µ–ª–µ–≤–æ–π —Ü–≤–µ—Ç',
        pipette_source_tooltip: '–í—ã–±—Ä–∞—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π —Ü–≤–µ—Ç',
        pipette_ignore_tooltip: '–í—ã–±—Ä–∞—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã–π —Ü–≤–µ—Ç',
        // Replace modes
        mode_hsl: 'HSL‚Äë—Å–º–µ—â–µ–Ω–∏–µ',
        mode_target: '–ö —Ü–µ–ª–µ–≤–æ–º—É (RGB)',
        // Additional hints and tooltips
        source_tip: 'üí° –°–æ–≤–µ—Ç: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–µ–ª–µ–Ω—É—é –ø–∏–ø–µ—Ç–∫—É —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –≤—ã–±—Ä–∞—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π —Ü–≤–µ—Ç —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è',
        tools_help: '–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤—ã–¥–µ–ª–µ–Ω–∏—è:\n- –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫: –ø–æ—Ç—è–Ω–∏—Ç–µ –õ–ö–ú.\n- –ü–µ—Ä–æ: –∫–ª–∏–∫–∏ —Å—Ç–∞–≤—è—Ç —Ç–æ—á–∫–∏, –ø–µ—Ä–µ—Ç—è–≥–∏–≤–∞–Ω–∏–µ –ø—Ä–∏ –∫–ª–∏–∫–µ –∑–∞–¥–∞—ë—Ç —Ä—É—á–∫—É. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –∏–ª–∏ –∫–ª–∏–∫ –ø–æ –ø–µ—Ä–≤–æ–π —Ç–æ—á–∫–µ ‚Äî –∑–∞–º–∫–Ω—É—Ç—å. Esc ‚Äî –æ—Ç–º–µ–Ω–∞, Backspace ‚Äî —É–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫—É.\n- –õ–∞—Å—Å–æ: –∑–∞–∂–º–∏—Ç–µ –õ–ö–ú –∏ –≤–µ–¥–∏—Ç–µ –º—ã—à—å—é, –æ—Ç–ø—É—Å—Ç–∏—Ç–µ –¥–ª—è –∑–∞–º—ã–∫–∞–Ω–∏—è.\n–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç—É—Ä—ã –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è. –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∏ –∏—Ç–æ–≥ —É—á–∏—Ç—ã–≤–∞—é—Ç –º–∞—Å–∫—É.',
        // License system
        license_free_uses: '–ë–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π',
        license_remaining: '–æ—Å—Ç–∞–ª–æ—Å—å',
        license_unlimited: '–ë–µ–∑–ª–∏–º–∏—Ç–Ω–æ',
        license_get_pro: '–ü–æ–ª—É—á–∏—Ç—å Pro',
        license_limit_reached: '–õ–∏–º–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç–∏–≥–Ω—É—Ç',
        license_limit_message: '–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ 5 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫. –ü–æ–ª—É—á–∏—Ç–µ Pro –≤–µ—Ä—Å–∏—é –¥–ª—è –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞.',
        license_buy_telegram: '–ö—É–ø–∏—Ç—å —á–µ—Ä–µ–∑ Telegram',
        license_pro_active: 'Pro –∞–∫—Ç–∏–≤–Ω–∞',
        license_expires_soon: '–°–∫–æ—Ä–æ –∏—Å—Ç–µ–∫–∞–µ—Ç!',
        license_days_remaining: '–¥–Ω–µ–π –æ—Å—Ç–∞–ª–æ—Å—å',
        license_renew: '–ü—Ä–æ–¥–ª–∏—Ç—å',
        license_feature_unlimited: '–ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–±–æ—Ç–æ–∫',
        activation_label: '–£–∂–µ –µ—Å—Ç—å –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏?',
        activation_placeholder: '–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (CT-...)',
        activation_button: '–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å',
        activation_processing: '–û–±—Ä–∞–±–æ—Ç–∫–∞...',
        activation_success: 'Pro –≤–µ—Ä—Å–∏—è —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!',
        activation_error: '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.',
        activation_error_network: '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.',
        activation_error_format: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–ª—é—á–∞. –ö–ª—é—á –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å CT-',
        activation_error_expired: '–°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–ª—é—á–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∏—Å—Ç–µ–∫.',
        activation_error_user: '–≠—Ç–æ—Ç –∫–ª—é—á –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –¥—Ä—É–≥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.',
        activation_error_device: '–≠—Ç–æ—Ç –∫–ª—é—á –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –¥—Ä—É–≥–æ–º—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É.',
        activation_error_parse: '–ù–µ —É–¥–∞–µ—Ç—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü–∏–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–ª—é—á.',
        activation_error_validation: '–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–ª—é—á–∞. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.',
        subscription_reset: '–ü–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–±—Ä–æ—à–µ–Ω–∞!',
        challenge_error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤—ã–∑–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.',
        get_code_button: '–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥ (–µ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∞)',

        // Status badge and subscription modal
        status_pro_tooltip: 'Pro –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ù–∞–∂–º–∏—Ç–µ –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π.',
        subscription_info_title: '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ',
        subscription_active: '–ê–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞',
        subscription_unlimited: '–ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º',
        subscription_expiring: '–ü–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç',
        subscription_expiring_desc: '–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ —Å–∫–æ—Ä–æ –∏—Å—Ç–µ—á–µ—Ç',
        subscription_free: '–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –≤–µ—Ä—Å–∏—è',
        subscription_limited: '–û–≥—Ä–∞–Ω–∏—á–µ–Ω–æ 5 –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è–º–∏',
        subscription_monthly: '–ú–µ—Å—è—á–Ω–∞—è',
        subscription_yearly: '–ì–æ–¥–æ–≤–∞—è',
        subscription_lifetime: '–ü–æ–∂–∏–∑–Ω–µ–Ω–Ω–∞—è',
        subscription_promo: '–ü—Ä–æ–º–æ',
        subscription_expires_today: '–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —Å–µ–≥–æ–¥–Ω—è!',
        subscription_expires_soon_days: '–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ {days} –¥–Ω–µ–π.',
        subscription_expires_week: '–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ {days} –¥–Ω–µ–π. –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –ø—Ä–æ–¥–ª–µ–Ω–∏–µ.',
        subscription_renew: '–ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É',
        subscription_manage: '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–æ–π',
        subscription_upgrade: '–ü–æ–ª—É—á–∏—Ç—å PRO',
        subscription_recover: '–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É',
        subscription_expiring: '–ü–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç',
        subscription_expiring_desc: '–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ —Å–∫–æ—Ä–æ –∏—Å—Ç–µ—á–µ—Ç',
        subscription_type_label: '–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏',

        // Pricing
        price_monthly: '$4.99 / –º–µ—Å—è—Ü',
        price_yearly_note: '–∏–ª–∏ $39.99 / –≥–æ–¥ (—ç–∫–æ–Ω–æ–º–∏—è 33%)',
        subscription_purchase_date_label: '–î–∞—Ç–∞ –ø–æ–∫—É–ø–∫–∏',
        subscription_expires_label: '–ò—Å—Ç–µ–∫–∞–µ—Ç',
        subscription_days_left_label: '–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π',
        subscription_expires_warning: '–ü–æ–¥–ø–∏—Å–∫–∞ —Å–∫–æ—Ä–æ –∏—Å—Ç–µ–∫–∞–µ—Ç!',
        subscription_expires_warning_desc: '–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ {days} –¥–Ω—è. –ü—Ä–æ–¥–ª–∏—Ç–µ –µ—ë, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø –∫ Pro —Ñ—É–Ω–∫—Ü–∏—è–º.',
        subscription_usage_text: '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: {used} –∏–∑ 5 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫',
        modal_close: '–ó–∞–∫—Ä—ã—Ç—å',
        unknown: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
        never: '–ù–∏–∫–æ–≥–¥–∞'
      },
      uk: {
        title: 'Color Target',
        theme_light: '–°–≤—ñ—Ç–ª–∞ —Ç–µ–º–∞',
        theme_dark: '–¢–µ–º–Ω–∞ —Ç–µ–º–∞',

        preview_placeholder: '–û–±–µ—Ä—ñ—Ç—å –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è',
        zoom_label: '–ó—É–º –ø—Ä–µ–≤‚Äô—é',
        zoom_hint: '–ó—É–º –≤–ø–ª–∏–≤–∞—î –ª–∏—à–µ –Ω–∞ —Ç–æ—á–Ω—ñ—Å—Ç—å –≤–∏–±–æ—Ä—É, –Ω–µ –Ω–∞ —Ñ—ñ–Ω–∞–ª—å–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è',
        target_group: '–¶—ñ–ª—å–æ–≤–∏–π –∫–æ–ª—ñ—Ä',
        target_label: '–ü–æ—Ç—Ä—ñ–±–Ω–∏–π –∫–æ–ª—ñ—Ä (HEX)',
        source_step_hint: 'üìç –ö—Ä–æ–∫ 1: –í–≤–µ–¥—ñ—Ç—å –∞–±–æ –≤–∏–±–µ—Ä—ñ—Ç—å –∫–æ–ª—ñ—Ä, —è–∫–∏–π —Ö–æ—á–µ—Ç–µ –∑–∞–º—ñ–Ω–∏—Ç–∏',
        target_step_hint: 'üéØ –ö—Ä–æ–∫ 2: –í–≤–µ–¥—ñ—Ç—å –∞–±–æ –≤–∏–±–µ—Ä—ñ—Ç—å –Ω–æ–≤–∏–π –∫–æ–ª—ñ—Ä –¥–ª—è –∑–∞–º—ñ–Ω–∏',
        pipette: '–ü—ñ–ø–µ—Ç–∫–∞',
        pipette_hint: '–ö–ª—ñ–∫ –ø–æ –ø—Ä–µ–≤‚Äô—é –∑–∞–¥–∞—Å—Ç—å —Ü—ñ–ª—å–æ–≤–∏–π –∫–æ–ª—ñ—Ä',
        source_group: '–ü–æ—á–∞—Ç–∫–æ–≤–∏–π –∫–æ–ª—ñ—Ä',
        source_label: '–ö–æ–ª—ñ—Ä –¥–ª—è –∑–∞–º—ñ–Ω–∏ (–Ω–µ–æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–∏–π HEX)',
        src_placeholder: '#RRGGBB (—è–∫—â–æ –Ω–µ –≤–∫–∞–∑—É–≤–∞—Ç–∏ ‚Äî –±–µ—Ä–µ–º–æ –∑ —Ç–æ—á–∫–∏ –∑ –º–∞—Ä–∫–µ—Ä–æ–º)',
        source_hint: '–ö–ª—ñ–∫ –ø–æ –ø—Ä–µ–≤‚Äô—é –∑–∞–ø–∏—à–µ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π –∫–æ–ª—ñ—Ä',
        ignore_title: '–Ü–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ –∫–æ–ª—å–æ—Ä–∏',
        ignore_hint: '(–Ω–µ –±—É–¥—É—Ç—å –∑–∞–º—ñ–Ω–µ–Ω—ñ)',
        ignore_note: '–î–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å—Å—è —Ç—ñ —Å–∞–º—ñ –ø–æ—Ä–æ–≥–∏, —â–æ –Ω–∏–∂—á–µ',
        pipette_src: '–ü—ñ–ø–µ—Ç–∫–∞ –¥–∂–µ—Ä–µ–ª–∞',
        pipette_ignore: '–ü—ñ–ø–µ—Ç–∫–∞ —ñ–≥–Ω–æ—Ä—É',
        apply_original: '–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –¥–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—É',
        apply_copy: '–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –¥–æ –∫–æ–ø—ñ—ó',
        thresholds_title: '–ü–æ—Ä–æ–≥–∏',
        thresholds_step_hint: '‚öôÔ∏è –ö—Ä–æ–∫ 3: –ù–∞–ª–∞—à—Ç—É–π—Ç–µ –Ω–∞—Å–∫—ñ–ª—å–∫–∏ —Å—Ö–æ–∂–∏–º–∏ –º–∞—é—Ç—å –±—É—Ç–∏ –∫–æ–ª—å–æ—Ä–∏ –¥–ª—è –∑–∞–º—ñ–Ω–∏',
        hue_label: '–ü–æ—Ä—ñ–≥ –≤—ñ–¥—Ç—ñ–Ω–∫—É (¬∞)',
        sat_label: '–ü–æ—Ä—ñ–≥ –Ω–∞—Å–∏—á–µ–Ω–æ—Å—Ç—ñ',
        light_label: '–ü–æ—Ä—ñ–≥ —è—Å–∫—Ä–∞–≤–æ—Å—Ç—ñ',
        intensity_label: '–ñ–æ—Ä—Å—Ç–∫—ñ—Å—Ç—å/—ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å (%)',
        create: '–°—Ç–≤–æ—Ä–∏—Ç–∏',
        alert_pick_point_or_hex: '–û–±–µ—Ä—ñ—Ç—å —Ç–æ—á–∫—É –Ω–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—ñ –∞–±–æ –≤–∫–∞–∂—ñ—Ç—å HEX –¥–∂–µ—Ä–µ–ª–∞!',
        alert_enter_hex: '–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–∏–π HEX!',
        alert_processing_error: '–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è',
        footer: 'by Sensey',
        area_toggle: '–û–±–º–µ–∂–∏—Ç–∏ –æ–±–ª–∞—Å—Ç—å',
        area_clear: '–û—á–∏—Å—Ç–∏—Ç–∏',
        ignore_effects: '–Ü–≥–Ω–æ—Ä—É–≤–∞—Ç–∏ –µ—Ñ–µ–∫—Ç–∏ (—Ç—ñ–Ω—ñ, —Ä–æ–∑–º–∏—Ç—Ç—è)',
        ignore_effects_hint: '–í–∏–º–∏–∫–∞—î –µ—Ñ–µ–∫—Ç–∏ —à–∞—Ä—É –ø—Ä–∏ –µ–∫—Å–ø–æ—Ä—Ç—ñ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–Ω–Ω—è',
        expand_full: '–ù–∞ –≤–µ—Å—å –µ–∫—Ä–∞–Ω',
        restore_full: '–ó–≥–æ—Ä–Ω—É—Ç–∏',
        // Fullscreen mode
        fs_selection: '–í–∏–¥—ñ–ª–µ–Ω–Ω—è',
        fs_zoom: '–ó—É–º',
        fs_colors: '–ö–æ–ª—å–æ—Ä–∏',
        fs_thresholds: '–ü–æ—Ä–æ–≥–∏',
        fs_thresholds_step: '‚öôÔ∏è –ö—Ä–æ–∫ 3: –ù–∞–ª–∞—à—Ç—É–π—Ç–µ —Å—Ö–æ–∂—ñ—Å—Ç—å',
        fs_modes: '–†–µ–∂–∏–º–∏',
        fs_ignore: '–Ü–≥–Ω–æ—Ä—É–≤–∞—Ç–∏',
        fs_target_color: 'üéØ –ö—Ä–æ–∫ 2 - –¶—ñ–ª—å–æ–≤–∏–π:',
        fs_source_color: 'üìç –ö—Ä–æ–∫ 1 - –ü–æ—á–∞—Ç–∫–æ–≤–∏–π:',
        fs_hue: '–í—ñ–¥—Ç—ñ–Ω–æ–∫',
        fs_saturation: '–ù–∞—Å–∏—á.',
        fs_lightness: '–Ø—Å–∫—Ä–∞–≤—ñ—Å—Ç—å',
        fs_intensity: '–Ü–Ω—Ç–µ–Ω—Å.',
        fs_modes_title: '–†–µ–∂–∏–º–∏',
        fs_apply_to_title: '–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –¥–æ',
        fs_original: '–û—Ä–∏–≥—ñ–Ω–∞–ª',
        fs_copy: '–ö–æ–ø—ñ—è',
        fs_hsl: 'HSL',
        fs_rgb: 'RGB',
        // Tool tooltips
        tool_rectangle: '–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫',
        tool_pen: '–ü–µ—Ä–æ',
        tool_lasso: '–õ–∞—Å–æ',
        tool_wand: '–ß–∞—Ä—ñ–≤–Ω–∞ –ø–∞–ª–∏—á–∫–∞',
        tool_new_path: '–ù–æ–≤–∏–π –∫–æ–Ω—Ç—É—Ä',
        tool_undo_point: '–°–∫–∞—Å—É–≤–∞—Ç–∏ —Ç–æ—á–∫—É',
        tool_delete_path: '–í–∏–¥–∞–ª–∏—Ç–∏ –∫–æ–Ω—Ç—É—Ä',
        tool_add: '–î–æ–¥–∞—Ç–∏',
        // Buttons
        btn_zoom_out: '–ó–º–µ–Ω—à–∏—Ç–∏',
        btn_zoom_in: '–ó–±—ñ–ª—å—à–∏—Ç–∏',
        btn_zoom_fit: '–ó–∞ —Ä–æ–∑–º—ñ—Ä–æ–º',
        btn_zoom_100: '100%',
        btn_create: '–°—Ç–≤–æ—Ä–∏—Ç–∏',
        // Pipette tooltips
        pipette_target_tooltip: '–í–∏–±—Ä–∞—Ç–∏ —Ü—ñ–ª—å–æ–≤–∏–π –∫–æ–ª—ñ—Ä',
        pipette_source_tooltip: '–í–∏–±—Ä–∞—Ç–∏ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π –∫–æ–ª—ñ—Ä',
        pipette_ignore_tooltip: '–í–∏–±—Ä–∞—Ç–∏ –∫–æ–ª—ñ—Ä –¥–ª—è —ñ–≥–Ω–æ—Ä—É–≤–∞–Ω–Ω—è',
        // Replace modes
        mode_hsl: 'HSL‚Äë–∑–º—ñ—â–µ–Ω–Ω—è',
        mode_target: '–î–æ —Ü—ñ–ª—å–æ–≤–æ–≥–æ (RGB)',
        // Additional hints and tooltips
        source_tip: 'üí° –ü–æ—Ä–∞–¥–∞: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∑–µ–ª–µ–Ω—É –ø—ñ–ø–µ—Ç–∫—É —â–æ–± —Ç–æ—á–Ω–æ –≤–∏–±—Ä–∞—Ç–∏ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π –∫–æ–ª—ñ—Ä —ñ–∑ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è',
        tools_help: '–Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è:\n- –ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫: –ø–æ—Ç—è–≥–Ω—ñ—Ç—å –õ–ö–ú.\n- –ü–µ—Ä–æ: –∫–ª—ñ–∫–∏ —Å—Ç–∞–≤–ª—è—Ç—å —Ç–æ—á–∫–∏, –ø–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è –ø—Ä–∏ –∫–ª—ñ—Ü—ñ –∑–∞–¥–∞—î —Ä—É—á–∫—É. –ü–æ–¥–≤—ñ–π–Ω–∏–π –∫–ª—ñ–∫ –∞–±–æ –∫–ª—ñ–∫ –ø–æ –ø–µ—Ä—à—ñ–π —Ç–æ—á—Ü—ñ ‚Äî –∑–∞–º–∫–Ω—É—Ç–∏. Esc ‚Äî —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è, Backspace ‚Äî –≤–∏–¥–∞–ª–∏—Ç–∏ —Ç–æ—á–∫—É.\n- –õ–∞—Å–æ: –∑–∞—Ç–∏—Å–Ω—ñ—Ç—å –õ–ö–ú —ñ –≤–µ–¥—ñ—Ç—å –º–∏—à–µ—é, –≤—ñ–¥–ø—É—Å—Ç—ñ—Ç—å –¥–ª—è –∑–∞–º–∏–∫–∞–Ω–Ω—è.\n–ë–∞–≥–∞—Ç–æ—á–∏—Å–µ–ª—å–Ω—ñ –∫–æ–Ω—Ç—É—Ä–∏ –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å—Å—è. –ü—Ä–µ–≤\'—é —Ç–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—Ä–∞—Ö–æ–≤—É—é—Ç—å –º–∞—Å–∫—É.',
        // License system
        license_free_uses: '–ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏—Ö –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—å',
        license_remaining: '–∑–∞–ª–∏—à–∏–ª–æ—Å—å',
        license_unlimited: '–ë–µ–∑–ª—ñ–º—ñ—Ç–Ω–æ',
        license_get_pro: '–û—Ç—Ä–∏–º–∞—Ç–∏ Pro',
        license_limit_reached: '–õ—ñ–º—ñ—Ç –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—å –¥–æ—Å—è–≥–Ω—É—Ç–æ',
        license_limit_message: '–í–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–ª–∏ –≤—Å—ñ 5 –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏—Ö —Å–ø—Ä–æ–±. –û—Ç—Ä–∏–º–∞–π—Ç–µ Pro –≤–µ—Ä—Å—ñ—é –¥–ª—è –Ω–µ–æ–±–º–µ–∂–µ–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø—É.',
        license_buy_telegram: '–ö—É–ø–∏—Ç–∏ —á–µ—Ä–µ–∑ Telegram',
        license_pro_active: 'Pro –∞–∫—Ç–∏–≤–Ω–∞',
        license_expires_soon: '–°–∫–æ—Ä–æ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è!',
        license_days_remaining: '–¥–Ω—ñ–≤ –∑–∞–ª–∏—à–∏–ª–æ—Å—å',
        license_renew: '–ü–æ–Ω–æ–≤–∏—Ç–∏',
        license_feature_unlimited: '–ù–µ–æ–±–º–µ–∂–µ–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –æ–±—Ä–æ–±–æ–∫',
        activation_label: '–í–∂–µ —î –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó?',
        activation_placeholder: '–í–≤–µ–¥—ñ—Ç—å –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó',
        activation_button: '–ê–∫—Ç–∏–≤—É–≤–∞—Ç–∏',
        activation_success: 'Pro –≤–µ—Ä—Å—ñ—é —É—Å–ø—ñ—à–Ω–æ –∞–∫—Ç–∏–≤–æ–≤–∞–Ω–æ!',
        activation_error: '–ù–µ–≤—ñ—Ä–Ω–∏–π –∫–ª—é—á –∞–∫—Ç–∏–≤–∞—Ü—ñ—ó. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.',
        activation_error_network: '–ü–æ–º–∏–ª–∫–∞ –º–µ—Ä–µ–∂—ñ. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.',
        get_code_button: '–û—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–¥ (—î –ø—ñ–¥–ø–∏—Å–∫–∞)',

        // Status badge and subscription modal
        status_pro_tooltip: 'Pro –ø—ñ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –¥–ª—è –¥–µ—Ç–∞–ª–µ–π.',
        subscription_info_title: '–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –ø—ñ–¥–ø–∏—Å–∫—É',
        subscription_active: '–ê–∫—Ç–∏–≤–Ω–∞ –ø—ñ–¥–ø–∏—Å–∫–∞',
        subscription_unlimited: '–ù–µ–æ–±–º–µ–∂–µ–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ –≤—Å—ñ—Ö —Ñ—É–Ω–∫—Ü—ñ–π',
        subscription_expiring: '–ü—ñ–¥–ø–∏—Å–∫–∞ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è',
        subscription_expiring_desc: '–í–∞—à–∞ –ø—ñ–¥–ø–∏—Å–∫–∞ —Å–∫–æ—Ä–æ –∑–∞–∫—ñ–Ω—á–∏—Ç—å—Å—è',
        subscription_free: '–ë–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∞ –≤–µ—Ä—Å—ñ—è',
        subscription_limited: '–û–±–º–µ–∂–µ–Ω–æ 5 –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º–∏',
        subscription_monthly: '–ú—ñ—Å—è—á–Ω–∞',
        subscription_yearly: '–†—ñ—á–Ω–∞',
        subscription_lifetime: '–î–æ–≤—ñ—á–Ω–∞',
        subscription_promo: '–ü—Ä–æ–º–æ',
        subscription_expires_today: '–í–∞—à–∞ –ø—ñ–¥–ø–∏—Å–∫–∞ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è —Å—å–æ–≥–æ–¥–Ω—ñ!',
        subscription_expires_soon_days: '–í–∞—à–∞ –ø—ñ–¥–ø–∏—Å–∫–∞ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è —á–µ—Ä–µ–∑ {days} –¥–Ω—ñ–≤.',
        subscription_expires_week: '–í–∞—à–∞ –ø—ñ–¥–ø–∏—Å–∫–∞ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è —á–µ—Ä–µ–∑ {days} –¥–Ω—ñ–≤. –†–æ–∑–≥–ª—è–Ω—å—Ç–µ –ø–æ–Ω–æ–≤–ª–µ–Ω–Ω—è.',
        subscription_renew: '–ü–æ–Ω–æ–≤–∏—Ç–∏ –ø—ñ–¥–ø–∏—Å–∫—É',
        subscription_manage: '–£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –ø—ñ–¥–ø–∏—Å–∫–æ—é',
        subscription_upgrade: '–û—Ç—Ä–∏–º–∞—Ç–∏ PRO',
        subscription_recover: '–í—ñ–¥–Ω–æ–≤–∏—Ç–∏ –ø—ñ–¥–ø–∏—Å–∫—É',
        subscription_reset: '–ü—ñ–¥–ø–∏—Å–∫—É —É—Å–ø—ñ—à–Ω–æ —Å–∫–∏–Ω—É—Ç–æ!',
        subscription_type_label: '–¢–∏–ø –ø—ñ–¥–ø–∏—Å–∫–∏',

        // Pricing
        price_monthly: '$4.99 / –º—ñ—Å—è—Ü—å',
        price_yearly_note: '–∞–±–æ $39.99 / —Ä—ñ–∫ (–µ–∫–æ–Ω–æ–º—ñ—è 33%)',
        subscription_purchase_date_label: '–î–∞—Ç–∞ –ø–æ–∫—É–ø–∫–∏',
        subscription_expires_label: '–ó–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è',
        subscription_days_left_label: '–î–Ω—ñ–≤ –∑–∞–ª–∏—à–∏–ª–æ—Å—å',
        subscription_expires_warning: '–ü—ñ–¥–ø–∏—Å–∫–∞ —Å–∫–æ—Ä–æ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è!',
        subscription_expires_warning_desc: '–í–∞—à–∞ –ø—ñ–¥–ø–∏—Å–∫–∞ –∑–∞–∫—ñ–Ω—á—É—î—Ç—å—Å—è —á–µ—Ä–µ–∑ {days} –¥–Ω—ñ–≤. –ü–æ–Ω–æ–≤—ñ—Ç—å —ó—ó, —â–æ–± –Ω–µ –≤—Ç—Ä–∞—Ç–∏—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ Pro —Ñ—É–Ω–∫—Ü—ñ–π.',
        subscription_usage_text: '–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ: {used} –∑ 5 –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏—Ö —Å–ø—Ä–æ–±',
        modal_close: '–ó–∞–∫—Ä–∏—Ç–∏',
        unknown: '–ù–µ–≤—ñ–¥–æ–º–æ',
        never: '–ù—ñ–∫–æ–ª–∏'
      },
      kk: {
        title: 'Color Target',
        theme_light: '–ñ–∞—Ä—ã“õ —Ç–∞“õ—ã—Ä—ã–ø',
        theme_dark: '“ö–∞—Ä–∞“£“ì—ã —Ç–∞“õ—ã—Ä—ã–ø',

        preview_placeholder: '–°—É—Ä–µ—Ç—Ç—ñ —Ç–∞“£–¥–∞“£—ã–∑',
        zoom_label: '–ü—Ä–µ–≤—å—é “Ø–ª–∫–µ–π—Ç—É—ñ',
        zoom_hint: '–ó—É–º —Ç–µ–∫ —Ç–∞“£–¥–∞—É–¥—ã“£ –¥”ô–ª–¥—ñ–≥—ñ–Ω–µ ”ô—Å–µ—Ä –µ—Ç–µ–¥—ñ, —Å–æ“£“ì—ã —Å—É—Ä–µ—Ç–∫–µ –µ–º–µ—Å',
        target_group: '–ú–∞“õ—Å–∞—Ç—Ç—ã —Ç“Ø—Å',
        target_label: '“ö–∞–∂–µ—Ç—Ç—ñ —Ç“Ø—Å (HEX)',
        target_step_hint: 'üéØ 2-“õ–∞–¥–∞–º: –ê—É—ã—Å—Ç—ã—Ä—É “Ø—à—ñ–Ω –∂–∞“£–∞ —Ç“Ø—Å—Ç—ñ –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑ –Ω–µ–º–µ—Å–µ —Ç–∞“£–¥–∞“£—ã–∑',
        pipette: '–ü–∏–ø–µ—Ç–∫–∞',
        pipette_hint: '–ü—Ä–µ–≤—å—é–≥–µ –±–∞—Å—ã“£—ã–∑ ‚Äî –º–∞“õ—Å–∞—Ç—Ç—ã —Ç“Ø—Å “õ–æ–π—ã–ª–∞–¥—ã',
        source_group: '–ë–∞—Å—Ç–∞–ø“õ—ã —Ç“Ø—Å',
        source_label: '–ê—É—ã—Å—Ç—ã—Ä—É —Ç“Ø—Å—ñ (–º—ñ–Ω–¥–µ—Ç—Ç—ñ –µ–º–µ—Å HEX)',
        source_step_hint: 'üìç 1-“õ–∞–¥–∞–º: –ê—É—ã—Å—Ç—ã—Ä“ì—ã“£—ã–∑ –∫–µ–ª–µ—Ç—ñ–Ω —Ç“Ø—Å—Ç—ñ –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑ –Ω–µ–º–µ—Å–µ —Ç–∞“£–¥–∞“£—ã–∑',
        src_placeholder: '#RRGGBB (–∫”©—Ä—Å–µ—Ç—ñ–ª–º–µ—Å–µ ‚Äî –º–∞—Ä–∫–µ—Ä –Ω“Ø–∫—Ç–µ—Å—ñ–Ω–µ–Ω –∞–ª—ã–Ω–∞–¥—ã)',
        source_hint: '–ü—Ä–µ–≤—å—é–≥–µ –±–∞—Å—ã“£—ã–∑ ‚Äî –±–∞—Å—Ç–∞–ø“õ—ã —Ç“Ø—Å –∂–∞–∑—ã–ª–∞–¥—ã',
        ignore_title: '–ï–ª–µ–º–µ–π—Ç—ñ–Ω —Ç“Ø—Å—Ç–µ—Ä',
        ignore_hint: '(–∞—É—ã—Å—Ç—ã—Ä—ã–ª–º–∞–π–¥—ã)',
        ignore_note: '–°–∞–ª—ã—Å—Ç—ã—Ä—É “Ø—à—ñ–Ω —Ç”©–º–µ–Ω–¥–µ–≥—ñ–¥–µ–π —à–µ–∫—Ç–µ—Ä “õ–æ–ª–¥–∞–Ω—ã–ª–∞–¥—ã',
        pipette_src: '–î–µ—Ä–µ–∫–∫”©–∑ –ø–∏–ø–µ—Ç–∫–∞—Å—ã',
        pipette_ignore: '–ï–ª–µ–º–µ—É –ø–∏–ø–µ—Ç–∫–∞—Å—ã',
        apply_original: '–¢“Ø–ø–Ω“±—Å“õ–∞“ì–∞ “õ–æ–ª–¥–∞–Ω—É',
        apply_copy: '–ö”©—à—ñ—Ä–º–µ–≥–µ “õ–æ–ª–¥–∞–Ω—É',
        thresholds_title: '–®–µ–∫—Ç–µ—Ä',
        thresholds_step_hint: '‚öôÔ∏è 3-“õ–∞–¥–∞–º: –ê—É—ã—Å—Ç—ã—Ä—É “Ø—à—ñ–Ω —Ç“Ø—Å—Ç–µ—Ä “õ–∞–Ω—à–∞–ª—ã“õ—Ç—ã “±“õ—Å–∞—Å –±–æ–ª—É—ã –∫–µ—Ä–µ–∫—Ç—ñ–≥—ñ–Ω —Ä–µ—Ç—Ç–µ“£—ñ–∑',
        hue_label: '–†–µ“£–∫ —Ç–∞–±–∞–ª–¥—ã—Ä—ã“ì—ã (¬∞)',
        sat_label: '“ö–∞–Ω—ã“õ—Ç—ã–ª—ã“õ —Ç–∞–±–∞–ª–¥—ã—Ä—ã“ì—ã',
        light_label: '–ñ–∞—Ä—ã“õ—Ç—ã“õ —Ç–∞–±–∞–ª–¥—ã—Ä—ã“ì—ã',
        intensity_label: '“ö–∞—Ç—Ç—ã–ª—ã“õ/–∏–Ω—Ç–µ–Ω—Å–∏–≤—Ç—ñ–ª—ñ–∫ (%)',
        create: '“ö“±—Ä—É',
        alert_pick_point_or_hex: '–°—É—Ä–µ—Ç—Ç–µ–Ω –Ω“Ø–∫—Ç–µ —Ç–∞“£–¥–∞“£—ã–∑ –Ω–µ–º–µ—Å–µ –±–∞—Å—Ç–∞–ø“õ—ã HEX –∫”©—Ä—Å–µ—Ç—ñ“£—ñ–∑!',
        alert_enter_hex: '–î“±—Ä—ã—Å HEX –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑!',
        alert_processing_error: '–°—É—Ä–µ—Ç—Ç—ñ ”©“£–¥–µ—É “õ–∞—Ç–µ—Å—ñ',
        footer: 'by Sensey',
        area_toggle: '–ê–π–º–∞“õ—Ç—ã —à–µ–∫—Ç–µ—É',
        area_clear: '–¢–∞–∑–∞–ª–∞—É',
        ignore_effects: '–≠—Ñ—Ñ–µ–∫—Ç—Ç–µ—Ä–¥—ñ –µ–ª–µ–º–µ—É (–∫”©–ª–µ“£–∫–µ–ª–µ—Ä, –±“±–ª–¥—ã—Ä–ª–∞—É)',
        ignore_effects_hint: '–î”ô–ª –æ—Ä–Ω–∞–ª–∞—Å—Ç—ã—Ä—É “Ø—à—ñ–Ω —ç–∫—Å–ø–æ—Ä—Ç –∫–µ–∑—ñ–Ω–¥–µ “õ–∞–±–∞—Ç —ç—Ñ—Ñ–µ–∫—Ç—Ç–µ—Ä—ñ–Ω ”©—à—ñ—Ä–µ–¥—ñ',
        expand_full: '–¢–æ–ª—ã“õ —ç–∫—Ä–∞–Ω',
        restore_full: '“ö–∞–ª–ø—ã–Ω–∞ –∫–µ–ª—Ç—ñ—Ä—É',
        // Fullscreen mode
        fs_selection: '–¢–∞“£–¥–∞—É',
        fs_zoom: '–ó—É–º',
        fs_colors: '–¢“Ø—Å—Ç–µ—Ä',
        fs_thresholds: '–®–µ–∫—Ç–µ—Ä',
        fs_thresholds_step: '‚öôÔ∏è 3-“õ–∞–¥–∞–º: “∞“õ—Å–∞—Å—Ç—ã“õ—Ç—ã —Ä–µ—Ç—Ç–µ—É',
        fs_modes: '–†–µ–∂–∏–º–¥–µ—Ä',
        fs_ignore: '–ï–ª–µ–º–µ—É',
        fs_target_color: 'üéØ 2-“õ–∞–¥–∞–º - –ú–∞“õ—Å–∞—Ç—Ç—ã:',
        fs_source_color: 'üìç 1-“õ–∞–¥–∞–º - –ë–∞—Å—Ç–∞–ø“õ—ã:',
        fs_hue: '–†–µ“£–∫',
        fs_saturation: '“ö–∞–Ω—ã“õ.',
        fs_lightness: '–ñ–∞—Ä—ã“õ.',
        fs_intensity: '–ò–Ω—Ç–µ–Ω—Å.',
        fs_modes_title: '–†–µ–∂–∏–º–¥–µ—Ä',
        fs_apply_to_title: '“ö–æ–ª–¥–∞–Ω—É',
        fs_original: '–¢“Ø–ø–Ω“±—Å“õ–∞',
        fs_copy: '–ö”©—à—ñ—Ä–º–µ',
        fs_hsl: 'HSL',
        fs_rgb: 'RGB',
        // Tool tooltips
        tool_rectangle: '–¢—ñ–∫—Ç”©—Ä—Ç–±“±—Ä—ã—à',
        tool_pen: '“ö–∞–ª–∞–º',
        tool_lasso: '–õ–∞—Å—Å–æ',
        tool_wand: '–°–∏“õ—ã—Ä–ª—ã —Ç–∞—è“õ—à–∞',
        tool_new_path: '–ñ–∞“£–∞ –∂–æ–ª',
        tool_undo_point: '–ù“Ø–∫—Ç–µ–Ω—ñ –±–æ–ª–¥—ã—Ä–º–∞—É',
        tool_delete_path: '–ñ–æ–ª–¥—ã –∂–æ—é',
        tool_add: '“ö–æ—Å—É',
        // Buttons
        btn_zoom_out: '–ö—ñ—à—ñ—Ä–µ–π—Ç—É',
        btn_zoom_in: '“Æ–ª–∫–µ–π—Ç—É',
        btn_zoom_fit: '”®–ª—à–µ–º–≥–µ —Å–∞–π',
        btn_zoom_100: '100%',
        btn_create: '“ö“±—Ä—É',
        // Pipette tooltips
        pipette_target_tooltip: '–ú–∞“õ—Å–∞—Ç—Ç—ã —Ç“Ø—Å—Ç—ñ —Ç–∞“£–¥–∞—É',
        pipette_source_tooltip: '–ë–∞—Å—Ç–∞–ø“õ—ã —Ç“Ø—Å—Ç—ñ —Ç–∞“£–¥–∞—É',
        pipette_ignore_tooltip: '–ï–ª–µ–º–µ–π—Ç—ñ–Ω —Ç“Ø—Å—Ç—ñ —Ç–∞“£–¥–∞—É',
        // Replace modes
        mode_hsl: 'HSL –∞—É—ã—Å—É—ã',
        mode_target: '–ú–∞“õ—Å–∞—Ç—Ç—ã“ì–∞ (RGB)',
        // Additional hints and tooltips
        source_tip: 'üí° –ö–µ“£–µ—Å: –°—É—Ä–µ—Ç—Ç–µ–Ω –±–∞—Å—Ç–∞–ø“õ—ã —Ç“Ø—Å—Ç—ñ –¥”ô–ª —Ç–∞“£–¥–∞—É “Ø—à—ñ–Ω –∂–∞—Å—ã–ª –ø–∏–ø–µ—Ç–∫–∞–Ω—ã –ø–∞–π–¥–∞–ª–∞–Ω—ã“£—ã–∑',
        tools_help: '–¢–∞“£–¥–∞—É “õ“±—Ä–∞–ª–¥–∞—Ä—ã:\n- –¢—ñ–∫—Ç”©—Ä—Ç–±“±—Ä—ã—à: –õ–ö–ú —Ç–∞—Ä—Ç—ã“£—ã–∑.\n- “ö–∞–ª–∞–º: –±–∞—Å—É –Ω“Ø–∫—Ç–µ–ª–µ—Ä–¥—ñ “õ–æ—è–¥—ã, –±–∞—Å—É –∫–µ–∑—ñ–Ω–¥–µ —Å“Ø–π—Ä–µ—É —Ç“±—Ç“õ–∞–Ω—ã –æ—Ä–Ω–∞—Ç–∞–¥—ã. “ö–æ—Å –±–∞—Å—É –Ω–µ–º–µ—Å–µ –±—ñ—Ä—ñ–Ω—à—ñ –Ω“Ø–∫—Ç–µ–≥–µ –±–∞—Å—É ‚Äî –∂–∞–±—É. Esc ‚Äî –±–æ–ª–¥—ã—Ä–º–∞—É, Backspace ‚Äî –Ω“Ø–∫—Ç–µ–Ω—ñ –∂–æ—é.\n- –õ–∞—Å—Å–æ: –õ–ö–ú “±—Å—Ç–∞–ø —Ç—ã—à“õ–∞–Ω–¥—ã –∂“Ø—Ä–≥—ñ–∑—ñ“£—ñ–∑, –∂–∞–±—É “Ø—à—ñ–Ω –±–æ—Å–∞—Ç—ã“£—ã–∑.\n–ë—ñ—Ä–Ω–µ—à–µ –∫–æ–Ω—Ç—É—Ä “õ–æ–ª–¥–∞—É –∫”©—Ä—Å–µ—Ç—ñ–ª–µ–¥—ñ. –ê–ª–¥—ã–Ω –∞–ª–∞ “õ–∞—Ä–∞—É –∂”ô–Ω–µ –Ω”ô—Ç–∏–∂–µ –º–∞—Å–∫–∞—Ç—ã –µ—Å–∫–µ—Ä–µ–¥—ñ.',
        // License system
        license_free_uses: '–¢–µ–≥—ñ–Ω –ø–∞–π–¥–∞–ª–∞–Ω—É',
        license_remaining: '“õ–∞–ª–¥—ã',
        license_unlimited: '–®–µ–∫—Å—ñ–∑',
        license_get_pro: 'Pro –∞–ª—É',
        license_limit_reached: '–ü–∞–π–¥–∞–ª–∞–Ω—É —à–µ–≥—ñ –∂–µ—Ç—Ç—ñ',
        license_limit_message: '–°—ñ–∑ –±–∞—Ä–ª—ã“õ 5 —Ç–µ–≥—ñ–Ω ”ô—Ä–µ–∫–µ—Ç—Ç—ñ –ø–∞–π–¥–∞–ª–∞–Ω–¥—ã“£—ã–∑. –®–µ–∫—Å—ñ–∑ “õ–æ–ª –∂–µ—Ç–∫—ñ–∑—É “Ø—à—ñ–Ω Pro –Ω“±—Å“õ–∞—Å—ã–Ω –∞–ª—ã“£—ã–∑.',
        license_buy_telegram: 'Telegram –∞—Ä“õ—ã–ª—ã —Å–∞—Ç—ã–ø –∞–ª—É',
        license_pro_active: 'Pro –±–µ–ª—Å–µ–Ω–¥—ñ',
        license_feature_unlimited: '–®–µ–∫—Å—ñ–∑ ”©“£–¥–µ—É',
        activation_label: '–ë–µ–ª—Å–µ–Ω–¥—ñ—Ä—É –∫—ñ–ª—Ç—ñ –±–∞—Ä –º–∞?',
        activation_placeholder: '–ë–µ–ª—Å–µ–Ω–¥—ñ—Ä—É –∫—ñ–ª—Ç—ñ–Ω –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑',
        activation_button: '–ë–µ–ª—Å–µ–Ω–¥—ñ—Ä—É',
        activation_success: 'Pro –Ω“±—Å“õ–∞—Å—ã —Å”ô—Ç—Ç—ñ –±–µ–ª—Å–µ–Ω–¥—ñ—Ä—ñ–ª–¥—ñ!',
        activation_error: '–ë–µ–ª—Å–µ–Ω–¥—ñ—Ä—É –∫—ñ–ª—Ç—ñ –¥“±—Ä—ã—Å –µ–º–µ—Å. “ö–∞–π—Ç–∞–ª–∞–ø –∫”©—Ä—ñ“£—ñ–∑.',
        activation_error_network: '–ñ–µ–ª—ñ “õ–∞—Ç–µ—Å—ñ. –ö–µ–π—ñ–Ω—ñ—Ä–µ–∫ “õ–∞–π—Ç–∞–ª–∞–ø –∫”©—Ä—ñ“£—ñ–∑.',
        get_code_button: '–ö–æ–¥ –∞–ª—É (–∂–∞–∑—ã–ª—ã–º –±–∞—Ä)'
      },
      ko: {
        title: 'Color Target',
        theme_light: 'ÎùºÏù¥Ìä∏ ÌÖåÎßà',
        theme_dark: 'Îã§ÌÅ¨ ÌÖåÎßà',

        preview_placeholder: 'Ïù¥ÎØ∏ÏßÄÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',
        zoom_label: 'ÎØ∏Î¶¨Î≥¥Í∏∞ Ï§å',
        zoom_hint: 'Ï§åÏùÄ ÏÑ†ÌÉù Ï†ïÎ∞ÄÎèÑÏóêÎßå ÏòÅÌñ•ÏùÑ Ï£ºÎ©∞ ÏµúÏ¢Ö Ïù¥ÎØ∏ÏßÄÏóêÎäî ÏòÅÌñ•Ïù¥ ÏóÜÏäµÎãàÎã§',
        target_group: 'ÎåÄÏÉÅ ÏÉâÏÉÅ',
        target_label: 'ÏõêÌïòÎäî ÏÉâ (HEX)',
        target_step_hint: 'üéØ 2Îã®Í≥Ñ: ÍµêÏ≤¥Ìï† ÏÉà ÏÉâÏÉÅÏùÑ ÏûÖÎ†•ÌïòÍ±∞ÎÇò ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',
        pipette: 'Ïä§Ìè¨Ïù¥Îìú',
        pipette_hint: 'ÎØ∏Î¶¨Î≥¥Í∏∞Î•º ÌÅ¥Î¶≠ÌïòÏó¨ ÎåÄÏÉÅ ÏÉâÏÉÅ ÏÑ§Ï†ï',
        source_group: 'ÏÜåÏä§ ÏÉâÏÉÅ',
        source_label: 'ÎåÄÏ≤¥Ìï† ÏÉâÏÉÅ (ÏÑ†ÌÉù ÏÇ¨Ìï≠ HEX)',
        source_step_hint: 'üìç 1Îã®Í≥Ñ: ÍµêÏ≤¥ÌïòÎ†§Îäî ÏÉâÏÉÅÏùÑ ÏûÖÎ†•ÌïòÍ±∞ÎÇò ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',
        src_placeholder: '#RRGGBB (ÏûÖÎ†•ÌïòÏßÄ ÏïäÏúºÎ©¥ ÎßàÏª§ ÏßÄÏ†êÏóêÏÑú Í∞ÄÏ†∏ÏòµÎãàÎã§)',
        source_hint: 'ÎØ∏Î¶¨Î≥¥Í∏∞Î•º ÌÅ¥Î¶≠ÌïòÏó¨ ÏÜåÏä§ ÏÉâÏÉÅ ÏÑ§Ï†ï',
        ignore_title: 'Î¨¥ÏãúÌï† ÏÉâÏÉÅ',
        ignore_hint: '(ÍµêÏ≤¥ÎêòÏßÄ ÏïäÏùå)',
        ignore_note: 'ÎπÑÍµêÏóêÎäî ÏïÑÎûòÏôÄ ÎèôÏùºÌïú ÏûÑÍ≥ÑÍ∞í ÏÇ¨Ïö©',
        pipette_src: 'ÏÜåÏä§ Ïä§Ìè¨Ïù¥Îìú',
        pipette_ignore: 'Î¨¥Ïãú Ïä§Ìè¨Ïù¥Îìú',
        apply_original: 'ÏõêÎ≥∏Ïóê Ï†ÅÏö©',
        apply_copy: 'Î≥µÏÇ¨Î≥∏Ïóê Ï†ÅÏö©',
        thresholds_title: 'ÏûÑÍ≥ÑÍ∞í',
        thresholds_step_hint: '‚öôÔ∏è 3Îã®Í≥Ñ: ÍµêÏ≤¥Ìï† ÏÉâÏÉÅÏù¥ ÏñºÎßàÎÇò Ïú†ÏÇ¨Ìï¥Ïïº ÌïòÎäîÏßÄ Ï°∞Ï†ï',
        hue_label: 'ÏÉâÏÉÅ ÏûÑÍ≥ÑÍ∞í (¬∞)',
        sat_label: 'Ï±ÑÎèÑ ÏûÑÍ≥ÑÍ∞í',
        light_label: 'Î™ÖÎèÑ ÏûÑÍ≥ÑÍ∞í',
        intensity_label: 'Í≤ΩÎèÑ/Í∞ïÎèÑ (%)',
        create: 'ÏÉùÏÑ±',
        alert_pick_point_or_hex: 'Ïù¥ÎØ∏ÏßÄÏùò ÏßÄÏ†êÏùÑ ÏÑ†ÌÉùÌïòÍ±∞ÎÇò ÏÜåÏä§ HEXÎ•º ÏßÄÏ†ïÌïòÏÑ∏Ïöî!',
        alert_enter_hex: 'Ïò¨Î∞îÎ•∏ HEX ÏÉâÏÉÅÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî!',
        alert_processing_error: 'Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Ïò§Î•ò',
        footer: 'by Sensey',
        area_toggle: 'ÏòÅÏó≠ Ï†úÌïú',
        area_clear: 'ÏßÄÏö∞Í∏∞',
        ignore_effects: 'Ìö®Í≥º Î¨¥Ïãú (Í∑∏Î¶ºÏûê, ÌùêÎ¶º)',
        ignore_effects_hint: 'Ï†ïÌôïÌïú ÏúÑÏπò ÏßÄÏ†ïÏùÑ ÏúÑÌï¥ ÎÇ¥Î≥¥ÎÇº Îïå Î†àÏù¥Ïñ¥ Ìö®Í≥ºÎ•º ÎπÑÌôúÏÑ±ÌôîÌï©ÎãàÎã§',
        expand_full: 'Ï†ÑÏ≤¥ ÌôîÎ©¥',
        restore_full: 'ÏõêÎûò ÌÅ¨Í∏∞',
        // Fullscreen mode
        fs_selection: 'ÏÑ†ÌÉù',
        fs_zoom: 'Ï§å',
        fs_colors: 'ÏÉâÏÉÅ',
        fs_thresholds: 'ÏûÑÍ≥ÑÍ∞í',
        fs_thresholds_step: '‚öôÔ∏è 3Îã®Í≥Ñ: Ïú†ÏÇ¨ÎèÑ Ï°∞Ï†ï',
        fs_modes: 'Î™®Îìú',
        fs_ignore: 'Î¨¥Ïãú',
        fs_target_color: 'üéØ 2Îã®Í≥Ñ - ÎåÄÏÉÅ:',
        fs_source_color: 'üìç 1Îã®Í≥Ñ - ÏÜåÏä§:',
        fs_hue: 'ÏÉâÏÉÅ',
        fs_saturation: 'Ï±ÑÎèÑ',
        fs_lightness: 'Î™ÖÎèÑ',
        fs_intensity: 'Í∞ïÎèÑ',
        fs_modes_title: 'Î™®Îìú',
        fs_apply_to_title: 'Ï†ÅÏö© ÎåÄÏÉÅ',
        fs_original: 'ÏõêÎ≥∏',
        fs_copy: 'Î≥µÏÇ¨',
        fs_hsl: 'HSL',
        fs_rgb: 'RGB',
        // Tool tooltips
        tool_rectangle: 'ÏÇ¨Í∞ÅÌòï',
        tool_pen: 'Ìéú',
        tool_lasso: 'Ïò¨Í∞ÄÎØ∏',
        tool_wand: 'ÎßàÎ≤ï ÏßÄÌå°Ïù¥',
        tool_new_path: 'ÏÉà Í≤ΩÎ°ú',
        tool_undo_point: 'Ï†ê Ï∑®ÏÜå',
        tool_delete_path: 'Í≤ΩÎ°ú ÏÇ≠Ï†ú',
        tool_add: 'Ï∂îÍ∞Ä',
        // Buttons
        btn_zoom_out: 'Ï∂ïÏÜå',
        btn_zoom_in: 'ÌôïÎåÄ',
        btn_zoom_fit: 'ÎßûÏ∂§',
        btn_zoom_100: '100%',
        btn_create: 'ÏÉùÏÑ±',
        // Pipette tooltips
        pipette_target_tooltip: 'ÎåÄÏÉÅ ÏÉâÏÉÅ ÏÑ†ÌÉù',
        pipette_source_tooltip: 'ÏÜåÏä§ ÏÉâÏÉÅ ÏÑ†ÌÉù',
        pipette_ignore_tooltip: 'Î¨¥ÏãúÌï† ÏÉâÏÉÅ ÏÑ†ÌÉù',
        // Replace modes
        mode_hsl: 'HSL Ïù¥Îèô',
        mode_target: 'ÎåÄÏÉÅÏúºÎ°ú (RGB)',
        // Additional hints and tooltips
        source_tip: 'üí° ÌåÅ: Ïù¥ÎØ∏ÏßÄÏóêÏÑú ÏÜåÏä§ ÏÉâÏÉÅÏùÑ Ï†ïÌôïÌûà ÏÑ†ÌÉùÌïòÎ†§Î©¥ ÎÖπÏÉâ Ïä§Ìè¨Ïù¥ÎìúÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî',
        tools_help: 'ÏÑ†ÌÉù ÎèÑÍµ¨:\n- ÏÇ¨Í∞ÅÌòï: Ï¢åÌÅ¥Î¶≠ÏúºÎ°ú ÎìúÎûòÍ∑∏.\n- Ìéú: ÌÅ¥Î¶≠ÏúºÎ°ú Ï†ê Î∞∞Ïπò, ÌÅ¥Î¶≠ÌïòÎ©¥ÏÑú ÎìúÎûòÍ∑∏ÌïòÎ©¥ Ìï∏Îì§ ÏÑ§Ï†ï. ÎçîÎ∏îÌÅ¥Î¶≠Ïù¥ÎÇò Ï≤´ Ï†ê ÌÅ¥Î¶≠ÏúºÎ°ú Îã´Í∏∞. EscÎ°ú Ï∑®ÏÜå, BackspaceÎ°ú Ï†ê ÏÇ≠Ï†ú.\n- Ïò¨Í∞ÄÎØ∏: Ï¢åÌÅ¥Î¶≠ Ïú†ÏßÄÌïòÍ≥† ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏, ÎÜìÏúºÎ©¥ Îã´Ìûò.\nÏó¨Îü¨ Ïú§Í≥ΩÏÑ†Ïù¥ ÏßÄÏõêÎê©ÎãàÎã§. ÎØ∏Î¶¨Î≥¥Í∏∞ÏôÄ Í≤∞Í≥ºÎäî ÎßàÏä§ÌÅ¨Î•º Í≥†Î†§Ìï©ÎãàÎã§.',
        // License system
        license_free_uses: 'Î¨¥Î£å ÏÇ¨Ïö©',
        license_remaining: 'ÎÇ®Ïùå',
        license_unlimited: 'Î¨¥Ï†úÌïú',
        license_get_pro: 'Pro Íµ¨Îß§',
        license_limit_reached: 'ÏÇ¨Ïö© ÌïúÎèÑ ÎèÑÎã¨',
        license_limit_message: '5Î≤àÏùò Î¨¥Î£å ÏãúÎèÑÎ•º Î™®Îëê ÏÇ¨Ïö©ÌñàÏäµÎãàÎã§. Î¨¥Ï†úÌïú Ïï°ÏÑ∏Ïä§Î•º ÏúÑÌï¥ Pro Î≤ÑÏ†ÑÏùÑ Íµ¨Îß§ÌïòÏÑ∏Ïöî.',
        license_buy_telegram: 'TelegramÏúºÎ°ú Íµ¨Îß§',
        license_pro_active: 'Pro ÌôúÏÑ±',
        license_feature_unlimited: 'Î¨¥Ï†úÌïú Ï≤òÎ¶¨',
        activation_label: 'Ïù¥ÎØ∏ ÌôúÏÑ±Ìôî ÌÇ§Í∞Ä ÏûàÎÇòÏöî?',
        activation_placeholder: 'ÌôúÏÑ±Ìôî ÌÇ§ ÏûÖÎ†•',
        activation_button: 'ÌôúÏÑ±Ìôî',
        activation_success: 'Pro Î≤ÑÏ†ÑÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§!',
        activation_error: 'ÏûòÎ™ªÎêú ÌôúÏÑ±Ìôî ÌÇ§ÏûÖÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.',
        activation_error_network: 'ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÏûÖÎãàÎã§. ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.',
        get_code_button: 'ÏΩîÎìú Î∞õÍ∏∞ (Íµ¨ÎèÖ ÏûàÏùå)',

        // Status badge and subscription modal
        status_pro_tooltip: 'Pro Íµ¨ÎèÖÏù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§. ÏûêÏÑ∏Ìïú ÎÇ¥Ïö©ÏùÑ Î≥¥Î†§Î©¥ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî.',
        subscription_info_title: 'Íµ¨ÎèÖ Ï†ïÎ≥¥',
        subscription_active: 'ÌôúÏÑ± Íµ¨ÎèÖ',
        subscription_unlimited: 'Î™®Îì† Í∏∞Îä•Ïóê Î¨¥Ï†úÌïú Ïï°ÏÑ∏Ïä§',
        subscription_expiring: 'Íµ¨ÎèÖ ÎßåÎ£å ÏòàÏ†ï',
        subscription_expiring_desc: 'Íµ¨ÎèÖÏù¥ Í≥ß ÎßåÎ£åÎê©ÎãàÎã§',
        subscription_free: 'Î¨¥Î£å Î≤ÑÏ†Ñ',
        subscription_limited: '5Ìöå ÏÇ¨Ïö©ÏúºÎ°ú Ï†úÌïú',
        subscription_monthly: 'ÏõîÍ∞Ñ',
        subscription_yearly: 'Ïó∞Í∞Ñ',
        subscription_lifetime: 'ÌèâÏÉù',
        subscription_promo: 'ÌîÑÎ°úÎ™®ÏÖò',
        subscription_expires_today: 'Íµ¨ÎèÖÏù¥ Ïò§Îäò ÎßåÎ£åÎê©ÎãàÎã§!',
        subscription_expires_soon_days: 'Íµ¨ÎèÖÏù¥ {days}Ïùº ÌõÑÏóê ÎßåÎ£åÎê©ÎãàÎã§.',
        subscription_expires_week: 'Íµ¨ÎèÖÏù¥ {days}Ïùº ÌõÑÏóê ÎßåÎ£åÎê©ÎãàÎã§. Í∞±Ïã†ÏùÑ Í≥†Î†§Ìï¥Î≥¥ÏÑ∏Ïöî.',
        subscription_renew: 'Íµ¨ÎèÖ Í∞±Ïã†',
        subscription_manage: 'Íµ¨ÎèÖ Í¥ÄÎ¶¨',
        subscription_upgrade: 'PRO Íµ¨Îß§',
        subscription_recover: 'Íµ¨ÎèÖ Î≥µÍµ¨',
        subscription_reset: 'Íµ¨ÎèÖÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ïû¨ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§!',
        subscription_type_label: 'Íµ¨ÎèÖ Ïú†Ìòï',

        // Pricing
        price_monthly: '$4.99 / Ïõî',
        price_yearly_note: 'ÎòêÎäî $39.99 / ÎÖÑ (33% Ï†àÏïΩ)',
        subscription_purchase_date_label: 'Íµ¨Îß§ ÎÇ†Ïßú',
        subscription_expires_label: 'ÎßåÎ£åÏùº',
        subscription_days_left_label: 'ÎÇ®ÏùÄ ÏùºÏàò',
        subscription_expires_warning: 'Íµ¨ÎèÖÏù¥ Í≥ß ÎßåÎ£åÎê©ÎãàÎã§!',
        subscription_expires_warning_desc: 'Íµ¨ÎèÖÏù¥ {days}Ïùº ÌõÑÏóê ÎßåÎ£åÎê©ÎãàÎã§. Pro Í∏∞Îä•Ïóê ÎåÄÌïú Ïï°ÏÑ∏Ïä§Î•º Ïú†ÏßÄÌïòÎ†§Î©¥ Í∞±Ïã†ÌïòÏÑ∏Ïöî.',
        subscription_usage_text: 'ÏÇ¨Ïö©Îê®: {used} / 5Ìöå Î¨¥Î£å ÏãúÎèÑ',
        modal_close: 'Îã´Í∏∞',
        unknown: 'Ïïå Ïàò ÏóÜÏùå',
        never: 'ÏóÜÏùå'
      },
      es: {
        title: 'Color Target',
        theme_light: 'Tema claro',
        theme_dark: 'Tema oscuro',

        preview_placeholder: 'Selecciona una imagen',
        zoom_label: 'Zoom de vista previa',
        zoom_hint: 'El zoom afecta solo la precisi√≥n de selecci√≥n, no la imagen final',
        target_group: 'Color objetivo',
        target_label: 'Color deseado (HEX)',
        target_step_hint: 'üéØ Paso 2: Ingrese o seleccione el nuevo color para reemplazar',
        pipette: 'Cuentagotas',
        pipette_hint: 'Haz clic para fijar el color objetivo',
        source_group: 'Color fuente',
        source_label: 'Color a reemplazar (HEX opcional)',
        source_step_hint: 'üìç Paso 1: Ingrese o seleccione el color que desea reemplazar',
        src_placeholder: '#RRGGBB (si se omite, se toma del punto con marcador)',
        source_hint: 'Haz clic para registrar el color fuente',
        ignore_title: 'Ignorar colores',
        ignore_hint: '(no ser√°n reemplazados)',
        ignore_note: 'Se usan los mismos umbrales de abajo para comparar',
        pipette_src: 'Cuentagotas de fuente',
        pipette_ignore: 'Cuentagotas de ignorar',
        apply_original: 'Aplicar al original',
        apply_copy: 'Aplicar a la copia',
        thresholds_title: 'Umbrales',
        thresholds_step_hint: '‚öôÔ∏è Paso 3: Ajusta qu√© tan similares deben ser los colores para reemplazarse',
        hue_label: 'Umbral de tono (¬∞)',
        sat_label: 'Umbral de saturaci√≥n',
        light_label: 'Umbral de luminosidad',
        intensity_label: 'Dureza/Intensidad (%)',
        create: 'Crear',
        alert_pick_point_or_hex: '¬°Elige un punto en la imagen o indica un HEX de origen!',
        alert_enter_hex: '¬°Introduce un color HEX v√°lido!',
        alert_processing_error: 'Error al procesar la imagen',
        footer: 'by Sensey',
        area_toggle: 'Limitar √°rea',
        area_clear: 'Limpiar',
        ignore_effects: 'Ignorar efectos (sombras, desenfoque)',
        ignore_effects_hint: 'Desactiva los efectos de capa al exportar para un posicionamiento preciso',
        expand_full: 'Pantalla completa',
        restore_full: 'Restaurar tama√±o',
        // Fullscreen mode
        fs_selection: 'Selecci√≥n',
        fs_zoom: 'Zoom',
        fs_colors: 'Colores',
        fs_thresholds: 'Umbrales',
        fs_thresholds_step: '‚öôÔ∏è Paso 3: Ajustar similitud',
        fs_modes: 'Modos',
        fs_ignore: 'Ignorar',
        fs_target_color: 'üéØ Paso 2 - Objetivo:',
        fs_source_color: 'üìç Paso 1 - Fuente:',
        fs_hue: 'Tono',
        fs_saturation: 'Saturaci√≥n',
        fs_lightness: 'Luminosidad',
        fs_intensity: 'Intensidad',
        fs_modes_title: 'Modos',
        fs_apply_to_title: 'Aplicar a',
        fs_original: 'Original',
        fs_copy: 'Copia',
        fs_hsl: 'HSL',
        fs_rgb: 'RGB',
        // Tool tooltips
        tool_rectangle: 'Rect√°ngulo',
        tool_pen: 'Pluma',
        tool_lasso: 'Lazo',
        tool_wand: 'Varita m√°gica',
        tool_new_path: 'Nueva ruta',
        tool_undo_point: 'Deshacer punto',
        tool_delete_path: 'Eliminar ruta',
        tool_add: 'A√±adir',
        // Buttons
        btn_zoom_out: 'Alejar',
        btn_zoom_in: 'Acercar',
        btn_zoom_fit: 'Ajustar',
        btn_zoom_100: '100%',
        btn_create: 'Crear',
        // Pipette tooltips
        pipette_target_tooltip: 'Seleccionar color objetivo',
        pipette_source_tooltip: 'Seleccionar color fuente',
        pipette_ignore_tooltip: 'Seleccionar color a ignorar',
        // Replace modes
        mode_hsl: 'Desplazamiento HSL',
        mode_target: 'Al objetivo (RGB)',
        // Additional hints and tooltips
        source_tip: 'üí° Consejo: Use el cuentagotas verde para seleccionar con precisi√≥n el color fuente de la imagen',
        tools_help: 'Herramientas de selecci√≥n:\n- Rect√°ngulo: arrastre con clic izquierdo.\n- Pluma: los clics colocan puntos, arrastrar mientras hace clic establece el mango. Doble clic o clic en el primer punto para cerrar. Esc para cancelar, Backspace para eliminar punto.\n- Lazo: mantenga clic izquierdo y arrastre el rat√≥n, suelte para cerrar.\nSe admiten m√∫ltiples contornos. La vista previa y el resultado tienen en cuenta la m√°scara.',
        // License system
        license_free_uses: 'Usos gratuitos',
        license_remaining: 'restantes',
        license_unlimited: 'Ilimitado',
        license_get_pro: 'Obtener Pro',
        license_limit_reached: 'L√≠mite de uso alcanzado',
        license_limit_message: 'Has usado todos los 5 intentos gratuitos. Obt√©n la versi√≥n Pro para acceso ilimitado.',
        license_buy_telegram: 'Comprar v√≠a Telegram',
        license_pro_active: 'Pro Activo',
        license_feature_unlimited: 'Procesamiento ilimitado',
        activation_label: '¬øYa tienes una clave de activaci√≥n?',
        activation_placeholder: 'Ingresa la clave de activaci√≥n',
        activation_button: 'Activar',
        activation_success: '¬°Versi√≥n Pro activada exitosamente!',
        activation_error: 'Clave de activaci√≥n inv√°lida. Int√©ntalo de nuevo.',
        activation_error_network: 'Error de red. Int√©ntalo m√°s tarde.',
        get_code_button: 'Obtener c√≥digo (tengo suscripci√≥n)',

        // Status badge and subscription modal
        status_pro_tooltip: 'Suscripci√≥n Pro activa. Haz clic para ver detalles.',
        subscription_info_title: 'Informaci√≥n de Suscripci√≥n',
        subscription_active: 'Suscripci√≥n Activa',
        subscription_unlimited: 'Acceso ilimitado a todas las funciones',
        subscription_expiring: 'Suscripci√≥n Expirando',
        subscription_expiring_desc: 'Tu suscripci√≥n expirar√° pronto',
        subscription_free: 'Versi√≥n Gratuita',
        subscription_limited: 'Limitado a 5 usos',
        subscription_monthly: 'Mensual',
        subscription_yearly: 'Anual',
        subscription_lifetime: 'De por vida',
        subscription_promo: 'Promocional',
        subscription_expires_today: '¬°Tu suscripci√≥n expira hoy!',
        subscription_expires_soon_days: 'Tu suscripci√≥n expira en {days} d√≠as.',
        subscription_expires_week: 'Tu suscripci√≥n expira en {days} d√≠as. Considera renovar.',
        subscription_renew: 'Renovar Suscripci√≥n',
        subscription_manage: 'Gestionar Suscripci√≥n',
        subscription_upgrade: 'Obtener PRO',
        subscription_recover: 'Recuperar Suscripci√≥n',
        subscription_reset: '¬°Suscripci√≥n restablecida exitosamente!',
        subscription_type_label: 'Tipo de Suscripci√≥n',

        // Pricing
        price_monthly: '$4.99 / mes',
        price_yearly_note: 'o $39.99 / a√±o (33% de ahorro)',
        subscription_purchase_date_label: 'Fecha de Compra',
        subscription_expires_label: 'Expira',
        subscription_days_left_label: 'D√≠as Restantes',
        subscription_expires_warning: '¬°La suscripci√≥n expira pronto!',
        subscription_expires_warning_desc: 'Tu suscripci√≥n expira en {days} d√≠as. Renu√©vala para mantener el acceso a las funciones Pro.',
        subscription_usage_text: 'Usado: {used} de 5 intentos gratuitos',
        modal_close: 'Cerrar',
        unknown: 'Desconocido',
        never: 'Nunca'
      },
      de: {
        title: 'Color Target',
        theme_light: 'Helles Thema',
        theme_dark: 'Dunkles Thema',

        preview_placeholder: 'Bild ausw√§hlen',
        zoom_label: 'Vorschauzoomen',
        zoom_hint: 'Zoom beeinflusst nur die Auswahlgenauigkeit, nicht das Endbild',
        target_group: 'Ziel‚ÄëFarbe',
        target_label: 'Gew√ºnschte Farbe (HEX)',
        target_step_hint: 'üéØ Schritt 2: Geben Sie die neue Farbe ein oder w√§hlen Sie sie aus',
        pipette: 'Pipette',
        pipette_hint: 'Klicke, um die Zielfarbe zu setzen',
        source_group: 'Quell‚ÄëFarbe',
        source_label: 'Zu ersetzende Farbe (optional HEX)',
        source_step_hint: 'üìç Schritt 1: Geben Sie die zu ersetzende Farbe ein oder w√§hlen Sie sie aus',
        src_placeholder: '#RRGGBB (falls weggelassen ‚Äî aus Markerpunkten entnommen)',
        source_hint: 'Klicke, um die Quellfarbe zu setzen',
        ignore_title: 'Farben ignorieren',
        ignore_hint: '(werden nicht ersetzt)',
        ignore_note: 'Zum Vergleich werden dieselben Schwellwerte wie unten verwendet',
        pipette_src: 'Quell‚ÄëPipette',
        pipette_ignore: 'Ignorieren‚ÄëPipette',
        apply_original: 'Auf Original anwenden',
        apply_copy: 'Auf Kopie anwenden',
        thresholds_title: 'Schwellwerte',
        thresholds_step_hint: '‚öôÔ∏è Schritt 3: Stellen Sie ein, wie √§hnlich Farben sein m√ºssen, um ersetzt zu werden',
        hue_label: 'Farbton‚ÄëSchwelle (¬∞)',
        sat_label: 'S√§ttigungs‚ÄëSchwelle',
        light_label: 'Helligkeits‚ÄëSchwelle',
        intensity_label: 'H√§rte/Intensit√§t (%)',
        create: 'Erstellen',
        alert_pick_point_or_hex: 'W√§hle einen Punkt im Bild oder gib einen Quell‚ÄëHEX an!',
        alert_enter_hex: 'Gib eine g√ºltige HEX‚ÄëFarbe ein!',
        alert_processing_error: 'Fehler bei der Bildverarbeitung',
        footer: 'by Sensey',
        area_toggle: 'Bereich begrenzen',
        area_clear: 'L√∂schen',
        ignore_effects: 'Effekte ignorieren (Schatten, Unsch√§rfe)',
        ignore_effects_hint: 'Deaktiviert Ebeneneffekte beim Export f√ºr pr√§zise Positionierung',
        expand_full: 'Vollbild',
        restore_full: 'Gr√∂√üe wiederherstellen',
        // Fullscreen mode
        fs_selection: 'Auswahl',
        fs_zoom: 'Zoom',
        fs_colors: 'Farben',
        fs_thresholds: 'Schwellwerte',
        fs_thresholds_step: '‚öôÔ∏è Schritt 3: √Ñhnlichkeit einstellen',
        fs_modes: 'Modi',
        fs_modes_title: 'Modi',
        fs_apply_to_title: 'Anwenden auf',
        fs_ignore: 'Ignorieren',
        fs_target_color: 'üéØ Schritt 2 - Ziel:',
        fs_source_color: 'üìç Schritt 1 - Quelle:',
        fs_hue: 'Farbton',
        fs_saturation: 'S√§ttigung',
        fs_lightness: 'Helligkeit',
        fs_intensity: 'Intensit√§t',
        fs_original: 'Original',
        fs_copy: 'Kopie',
        fs_hsl: 'HSL',
        fs_rgb: 'RGB',
        // Tool tooltips
        tool_rectangle: 'Rechteck',
        tool_pen: 'Stift',
        tool_lasso: 'Lasso',
        tool_wand: 'Zauberstab',
        tool_new_path: 'Neuer Pfad',
        tool_undo_point: 'Punkt r√ºckg√§ngig',
        tool_delete_path: 'Pfad l√∂schen',
        tool_add: 'Hinzuf√ºgen',
        // Buttons
        btn_zoom_out: 'Verkleinern',
        btn_zoom_in: 'Vergr√∂√üern',
        btn_zoom_fit: 'Anpassen',
        btn_zoom_100: '100%',
        btn_create: 'Erstellen',
        // Pipette tooltips
        pipette_target_tooltip: 'Zielfarbe ausw√§hlen',
        pipette_source_tooltip: 'Quellfarbe ausw√§hlen',
        pipette_ignore_tooltip: 'Zu ignorierende Farbe ausw√§hlen',
        // Replace modes
        mode_hsl: 'HSL‚ÄëVerschiebung',
        mode_target: 'Zum Ziel (RGB)',
        // Additional hints and tooltips
        source_tip: 'üí° Tipp: Verwenden Sie die gr√ºne Pipette, um die Quellfarbe pr√§zise aus dem Bild auszuw√§hlen',
        tools_help: 'Auswahlwerkzeuge:\n- Rechteck: Linksklick ziehen.\n- Stift: Klicks setzen Punkte, Ziehen beim Klicken setzt Griff. Doppelklick oder Klick auf ersten Punkt zum Schlie√üen. Esc zum Abbrechen, Backspace zum L√∂schen von Punkten.\n- Lasso: Linksklick halten und Maus ziehen, loslassen zum Schlie√üen.\nMehrere Konturen werden unterst√ºtzt. Vorschau und Ergebnis ber√ºcksichtigen die Maske.',
        // License system
        license_free_uses: 'Kostenlose Nutzungen',
        license_remaining: 'verbleibend',
        license_unlimited: 'Unbegrenzt',
        license_get_pro: 'Pro holen',
        license_limit_reached: 'Nutzungslimit erreicht',
        license_limit_message: 'Sie haben alle 5 kostenlosen Versuche verwendet. Holen Sie sich die Pro-Version f√ºr unbegrenzten Zugang.',
        license_buy_telegram: '√úber Telegram kaufen',
        license_pro_active: 'Pro Aktiv',
        license_feature_unlimited: 'Unbegrenzte Verarbeitung',
        activation_label: 'Haben Sie bereits einen Aktivierungsschl√ºssel?',
        activation_placeholder: 'Aktivierungsschl√ºssel eingeben',
        activation_button: 'Aktivieren',
        activation_success: 'Pro-Version erfolgreich aktiviert!',
        activation_error: 'Ung√ºltiger Aktivierungsschl√ºssel. Bitte versuchen Sie es erneut.',
        activation_error_network: 'Netzwerkfehler. Bitte versuchen Sie es sp√§ter erneut.',
        get_code_button: 'Code erhalten (habe Abonnement)',

        // Status badge and subscription modal
        status_pro_tooltip: 'Pro-Abonnement aktiv. Klicken Sie f√ºr Details.',
        subscription_info_title: 'Abonnement-Informationen',
        subscription_active: 'Aktives Abonnement',
        subscription_unlimited: 'Unbegrenzter Zugang zu allen Funktionen',
        subscription_expiring: 'Abonnement l√§uft ab',
        subscription_expiring_desc: 'Ihr Abonnement l√§uft bald ab',
        subscription_free: 'Kostenlose Version',
        subscription_limited: 'Begrenzt auf 5 Nutzungen',
        subscription_monthly: 'Monatlich',
        subscription_yearly: 'J√§hrlich',
        subscription_lifetime: 'Lebenslang',
        subscription_promo: 'Werbung',
        subscription_expires_today: 'Ihr Abonnement l√§uft heute ab!',
        subscription_expires_soon_days: 'Ihr Abonnement l√§uft in {days} Tagen ab.',
        subscription_expires_week: 'Ihr Abonnement l√§uft in {days} Tagen ab. Erw√§gen Sie eine Verl√§ngerung.',
        subscription_renew: 'Abonnement verl√§ngern',
        subscription_manage: 'Abonnement verwalten',
        subscription_upgrade: 'PRO holen',
        subscription_recover: 'Abonnement wiederherstellen',
        subscription_reset: 'Abonnement erfolgreich zur√ºckgesetzt!',
        subscription_type_label: 'Abonnement-Typ',

        // Pricing
        price_monthly: '$4.99 / Monat',
        price_yearly_note: 'oder $39.99 / Jahr (33% Ersparnis)',
        subscription_purchase_date_label: 'Kaufdatum',
        subscription_expires_label: 'L√§uft ab',
        subscription_days_left_label: 'Verbleibende Tage',
        subscription_expires_warning: 'Abonnement l√§uft bald ab!',
        subscription_expires_warning_desc: 'Ihr Abonnement l√§uft in {days} Tagen ab. Verl√§ngern Sie es, um den Zugang zu Pro-Funktionen zu behalten.',
        subscription_usage_text: 'Verwendet: {used} von 5 kostenlosen Versuchen',
        modal_close: 'Schlie√üen',
        unknown: 'Unbekannt',
        never: 'Niemals'
      },
      ja: {
        title: 'Color Target',
        theme_light: '„É©„Ç§„Éà„ÉÜ„Éº„Éû',
        theme_dark: '„ÉÄ„Éº„ÇØ„ÉÜ„Éº„Éû',

        preview_placeholder: 'ÁîªÂÉè„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
        zoom_label: '„Éó„É¨„Éì„É•„Éº„ÅÆ„Ç∫„Éº„É†',
        zoom_hint: '„Ç∫„Éº„É†„ÅØÈÅ∏ÊäûÁ≤æÂ∫¶„ÅÆ„Åø„Å´ÂΩ±Èüø„Åó„ÄÅÊúÄÁµÇÁîªÂÉè„Å´„ÅØÂΩ±Èüø„Åó„Åæ„Åõ„Çì',
        target_group: 'ÁõÆÊ®ô„ÅÆËâ≤',
        target_label: 'ÂøÖË¶Å„Å™Ëâ≤ (HEX)',
        target_step_hint: 'üéØ „Çπ„ÉÜ„ÉÉ„Éó2: ÁΩÆ„ÅçÊèõ„Åà„ÇãÊñ∞„Åó„ÅÑËâ≤„ÇíÂÖ•Âäõ„Åæ„Åü„ÅØÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
        pipette: '„Çπ„Éù„Ç§„Éà',
        pipette_hint: '„Éó„É¨„Éì„É•„Éº„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÁõÆÊ®ô„ÅÆËâ≤„ÇíË®≠ÂÆö',
        source_group: 'ÂÖÉ„ÅÆËâ≤',
        source_label: 'ÁΩÆ„ÅçÊèõ„Åà„ÇãËâ≤Ôºà‰ªªÊÑè„ÅÆHEXÔºâ',
        source_step_hint: 'üìç „Çπ„ÉÜ„ÉÉ„Éó1: ÁΩÆ„ÅçÊèõ„Åà„Åü„ÅÑËâ≤„ÇíÂÖ•Âäõ„Åæ„Åü„ÅØÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
        src_placeholder: '#RRGGBBÔºàÊú™ÊåáÂÆö„ÅÆÂ†¥Âêà„ÅØ„Éû„Éº„Ç´„Éº„ÅÆÁÇπ„Åã„ÇâÂèñÂæóÔºâ',
        source_hint: '„Éó„É¨„Éì„É•„Éº„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÂÖÉ„ÅÆËâ≤„ÇíË®≠ÂÆö',
        ignore_title: 'ÁÑ°Ë¶ñ„Åô„ÇãËâ≤',
        ignore_hint: 'ÔºàÁΩÆ„ÅçÊèõ„Åà„Çâ„Çå„Åæ„Åõ„ÇìÔºâ',
        ignore_note: 'ÊØîËºÉ„Å´„ÅØ‰∏ãË®ò„Å®Âêå„Åò„Åó„Åç„ÅÑÂÄ§„Çí‰ΩøÁî®',
        pipette_src: 'ÂÖÉ„ÅÆ„Çπ„Éù„Ç§„Éà',
        pipette_ignore: 'ÁÑ°Ë¶ñ„Çπ„Éù„Ç§„Éà',
        apply_original: '„Ç™„É™„Ç∏„Éä„É´„Å´ÈÅ©Áî®',
        apply_copy: '„Ç≥„Éî„Éº„Å´ÈÅ©Áî®',
        thresholds_title: '„Åó„Åç„ÅÑÂÄ§',
        thresholds_step_hint: '‚öôÔ∏è „Çπ„ÉÜ„ÉÉ„Éó3: ÁΩÆ„ÅçÊèõ„Åà„ÇãËâ≤„Åå„Å©„Çå„Å†„Åë‰ºº„Å¶„ÅÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åã„ÇíË™øÊï¥',
        hue_label: 'Ëâ≤Áõ∏„Åó„Åç„ÅÑÂÄ§ (¬∞)',
        sat_label: 'ÂΩ©Â∫¶„Åó„Åç„ÅÑÂÄ§',
        light_label: 'ÊòéÂ∫¶„Åó„Åç„ÅÑÂÄ§',
        intensity_label: 'Á°¨„Åï/Âº∑Â∫¶ (%)',
        create: '‰ΩúÊàê',
        alert_pick_point_or_hex: 'ÁîªÂÉè‰∏ä„ÅÆÁÇπ„ÇíÈÅ∏Êäû„Åô„Çã„Åã„ÄÅÂÖÉ„ÅÆHEX„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ',
        alert_enter_hex: 'Ê≠£„Åó„ÅÑHEX„Ç´„É©„Éº„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ',
        alert_processing_error: 'ÁîªÂÉèÂá¶ÁêÜ„Ç®„É©„Éº',
        footer: 'by Sensey',
        area_toggle: '„Ç®„É™„Ç¢„ÇíÂà∂Èôê',
        area_clear: '„ÇØ„É™„Ç¢',
        ignore_effects: '„Ç®„Éï„Çß„ÇØ„Éà„ÇíÁÑ°Ë¶ñÔºàÂΩ±„ÄÅ„Åº„Åã„ÅóÔºâ',
        ignore_effects_hint: 'Ê≠£Á¢∫„Å™‰ΩçÁΩÆÊ±∫„ÇÅ„ÅÆ„Åü„ÇÅ„Å´„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊôÇ„Å´„É¨„Ç§„É§„Éº„Ç®„Éï„Çß„ÇØ„Éà„ÇíÁÑ°Âäπ„Å´„Åó„Åæ„Åô',
        expand_full: 'ÂÖ®ÁîªÈù¢',
        restore_full: 'ÂÖÉ„ÅÆ„Çµ„Ç§„Ç∫',
        // Fullscreen mode
        fs_selection: 'ÈÅ∏Êäû',
        fs_zoom: '„Ç∫„Éº„É†',
        fs_colors: 'Ëâ≤',
        fs_thresholds: '„Åó„Åç„ÅÑÂÄ§',
        fs_thresholds_step: '‚öôÔ∏è „Çπ„ÉÜ„ÉÉ„Éó3: È°û‰ººÂ∫¶„ÇíË™øÊï¥',
        fs_modes: '„É¢„Éº„Éâ',
        fs_modes_title: '„É¢„Éº„Éâ',
        fs_apply_to_title: 'ÈÅ©Áî®ÂÖà',
        fs_ignore: 'ÁÑ°Ë¶ñ',
        fs_target_color: 'üéØ „Çπ„ÉÜ„ÉÉ„Éó2 - ÁõÆÊ®ô:',
        fs_source_color: 'üìç „Çπ„ÉÜ„ÉÉ„Éó1 - ÂÖÉ:',
        fs_hue: 'Ëâ≤Áõ∏',
        fs_saturation: 'ÂΩ©Â∫¶',
        fs_lightness: 'ÊòéÂ∫¶',
        fs_intensity: 'Âº∑Â∫¶',
        fs_original: '„Ç™„É™„Ç∏„Éä„É´',
        fs_copy: '„Ç≥„Éî„Éº',
        fs_hsl: 'HSL',
        fs_rgb: 'RGB',
        // Tool tooltips
        tool_rectangle: 'Èï∑ÊñπÂΩ¢',
        tool_pen: '„Éö„É≥',
        tool_lasso: 'Êäï„ÅíÁ∏Ñ',
        tool_wand: 'È≠îÊ≥ï„ÅÆÊùñ',
        tool_new_path: 'Êñ∞„Åó„ÅÑ„Éë„Çπ',
        tool_undo_point: '„Éù„Ç§„É≥„Éà„ÇíÂÖÉ„Å´Êàª„Åô',
        tool_delete_path: '„Éë„Çπ„ÇíÂâäÈô§',
        tool_add: 'ËøΩÂä†',
        // Buttons
        btn_zoom_out: 'Á∏ÆÂ∞è',
        btn_zoom_in: 'Êã°Â§ß',
        btn_zoom_fit: '„Éï„Ç£„ÉÉ„Éà',
        btn_zoom_100: '100%',
        btn_create: '‰ΩúÊàê',
        // Pipette tooltips
        pipette_target_tooltip: 'ÁõÆÊ®ôËâ≤„ÇíÈÅ∏Êäû',
        pipette_source_tooltip: 'ÂÖÉ„ÅÆËâ≤„ÇíÈÅ∏Êäû',
        pipette_ignore_tooltip: 'ÁÑ°Ë¶ñ„Åô„ÇãËâ≤„ÇíÈÅ∏Êäû',
        // Replace modes
        mode_hsl: 'HSL„Ç∑„Éï„Éà',
        mode_target: '„Çø„Éº„Ç≤„ÉÉ„Éà„Å∏ (RGB)',
        // Additional hints and tooltips
        source_tip: 'üí° „Éí„É≥„Éà: ÁîªÂÉè„Åã„Çâ„ÇΩ„Éº„ÇπËâ≤„ÇíÊ≠£Á¢∫„Å´ÈÅ∏Êäû„Åô„Çã„Å´„ÅØÁ∑ë„ÅÆ„Çπ„Éù„Ç§„Éà„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
        tools_help: 'ÈÅ∏Êäû„ÉÑ„Éº„É´:\n- Èï∑ÊñπÂΩ¢: Â∑¶„ÇØ„É™„ÉÉ„ÇØ„Åß„Éâ„É©„ÉÉ„Ç∞„ÄÇ\n- „Éö„É≥: „ÇØ„É™„ÉÉ„ÇØ„Åß„Éù„Ç§„É≥„ÉàÈÖçÁΩÆ„ÄÅ„ÇØ„É™„ÉÉ„ÇØ‰∏≠„Å´„Éâ„É©„ÉÉ„Ç∞„Åß„Éè„É≥„Éâ„É´Ë®≠ÂÆö„ÄÇ„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Åæ„Åü„ÅØÊúÄÂàù„ÅÆ„Éù„Ç§„É≥„Éà„Çí„ÇØ„É™„ÉÉ„ÇØ„ÅßÈñâ„Åò„Çã„ÄÇEsc„Åß„Ç≠„É£„É≥„Çª„É´„ÄÅBackspace„Åß„Éù„Ç§„É≥„ÉàÂâäÈô§„ÄÇ\n- Êäï„ÅíÁ∏Ñ: Â∑¶„ÇØ„É™„ÉÉ„ÇØ‰øùÊåÅ„Åó„Å¶„Éû„Ç¶„Çπ„Éâ„É©„ÉÉ„Ç∞„ÄÅÈõ¢„Åô„Å®Èñâ„Åò„Çã„ÄÇ\nË§áÊï∞„ÅÆËº™ÈÉ≠„Åå„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Éó„É¨„Éì„É•„Éº„Å®ÁµêÊûú„ÅØ„Éû„Çπ„ÇØ„ÇíËÄÉÊÖÆ„Åó„Åæ„Åô„ÄÇ',
        // License system
        license_free_uses: 'ÁÑ°Êñô‰ΩøÁî®',
        license_remaining: 'ÊÆã„Çä',
        license_unlimited: 'ÁÑ°Âà∂Èôê',
        license_get_pro: 'Pro„ÇíÂèñÂæó',
        license_limit_reached: '‰ΩøÁî®Âà∂Èôê„Å´ÈÅî„Åó„Åæ„Åó„Åü',
        license_limit_message: '5Âõû„ÅÆÁÑ°ÊñôË©¶Ë°å„Çí„Åô„Åπ„Å¶‰ΩøÁî®„Åó„Åæ„Åó„Åü„ÄÇÁÑ°Âà∂Èôê„Ç¢„ÇØ„Çª„Çπ„ÅÆ„Åü„ÇÅ„Å´ProÁâà„ÇíÂèñÂæó„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        license_buy_telegram: 'Telegram„ÅßË≥ºÂÖ•',
        license_pro_active: 'Pro „Ç¢„ÇØ„ÉÜ„Ç£„Éñ',
        license_feature_unlimited: 'ÁÑ°Âà∂ÈôêÂá¶ÁêÜ',
        activation_label: '„Åô„Åß„Å´„Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Ç∑„Éß„É≥„Ç≠„Éº„Çí„ÅäÊåÅ„Å°„Åß„Åô„ÅãÔºü',
        activation_placeholder: '„Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Ç∑„Éß„É≥„Ç≠„Éº„ÇíÂÖ•Âäõ',
        activation_button: '„Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Éà',
        activation_success: 'ProÁâà„ÅåÊ≠£Â∏∏„Å´„Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Éà„Åï„Çå„Åæ„Åó„ÅüÔºÅ',
        activation_error: 'ÁÑ°Âäπ„Å™„Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Ç∑„Éß„É≥„Ç≠„Éº„Åß„Åô„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
        activation_error_network: '„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº„Åß„Åô„ÄÇÂæå„Åß„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
        get_code_button: '„Ç≥„Éº„ÉâÂèñÂæó („Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥Êúâ„Çä)',

        // Status badge and subscription modal
        status_pro_tooltip: 'Pro„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Åß„Åô„ÄÇË©≥Á¥∞„ÅØ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        subscription_info_title: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥ÊÉÖÂ†±',
        subscription_active: '„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥',
        subscription_unlimited: '„Åô„Åπ„Å¶„ÅÆÊ©üËÉΩ„Å∏„ÅÆÁÑ°Âà∂Èôê„Ç¢„ÇØ„Çª„Çπ',
        subscription_expiring: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥ÊúüÈôêÂàá„Çå',
        subscription_expiring_desc: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Åå„Åæ„ÇÇ„Å™„ÅèÊúüÈôêÂàá„Çå„Å´„Å™„Çä„Åæ„Åô',
        subscription_free: 'ÁÑ°ÊñôÁâà',
        subscription_limited: '5Âõû„ÅÆ‰ΩøÁî®„Å´Âà∂Èôê',
        subscription_monthly: 'ÊúàÈñì',
        subscription_yearly: 'Âπ¥Èñì',
        subscription_lifetime: 'ÁîüÊ∂Ø',
        subscription_promo: '„Éó„É≠„É¢„Éº„Ç∑„Éß„É≥',
        subscription_expires_today: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Åå‰ªäÊó•ÊúüÈôêÂàá„Çå„Å´„Å™„Çä„Åæ„ÅôÔºÅ',
        subscription_expires_soon_days: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Åå{days}Êó•Âæå„Å´ÊúüÈôêÂàá„Çå„Å´„Å™„Çä„Åæ„Åô„ÄÇ',
        subscription_expires_week: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Åå{days}Êó•Âæå„Å´ÊúüÈôêÂàá„Çå„Å´„Å™„Çä„Åæ„Åô„ÄÇÊõ¥Êñ∞„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        subscription_renew: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥Êõ¥Êñ∞',
        subscription_manage: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥ÁÆ°ÁêÜ',
        subscription_upgrade: 'PROÂèñÂæó',
        subscription_recover: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥Âæ©Êóß',
        subscription_reset: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„ÅåÊ≠£Â∏∏„Å´„É™„Çª„ÉÉ„Éà„Åï„Çå„Åæ„Åó„ÅüÔºÅ',
        subscription_type_label: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Çø„Ç§„Éó',

        // Pricing
        price_monthly: '$4.99 / Êúà',
        price_yearly_note: '„Åæ„Åü„ÅØ $39.99 / Âπ¥ (33% ÁØÄÁ¥Ñ)',
        subscription_purchase_date_label: 'Ë≥ºÂÖ•Êó•',
        subscription_expires_label: 'ÊúâÂäπÊúüÈôê',
        subscription_days_left_label: 'ÊÆã„ÇäÊó•Êï∞',
        subscription_expires_warning: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Åå„Åæ„ÇÇ„Å™„ÅèÊúüÈôêÂàá„Çå„Å´„Å™„Çä„Åæ„ÅôÔºÅ',
        subscription_expires_warning_desc: '„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥„Åå{days}Êó•Âæå„Å´ÊúüÈôêÂàá„Çå„Å´„Å™„Çä„Åæ„Åô„ÄÇProÊ©üËÉΩ„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíÁ∂≠ÊåÅ„Åô„Çã„Åü„ÇÅ„Å´Êõ¥Êñ∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        subscription_usage_text: '‰ΩøÁî®Ê∏à„Åø: {used} / 5Âõû„ÅÆÁÑ°ÊñôË©¶Ë°å',
        modal_close: 'Èñâ„Åò„Çã',
        unknown: '‰∏çÊòé',
        never: '„Å™„Åó'
      }
    };



    // Initialize language after translations are defined
    function initLanguage() {
      state.language = getStoredLanguage();
      console.log('Initialized language:', state.language);

      // Force update expand button immediately
      setTimeout(() => {
        try {
          updateExpandBtnLabel();
          updateFullscreenElements();
        } catch (e) {
          console.log('Error updating expand button in initLanguage:', e);
        }
      }, 50);
    }

    function t(key) { const pack = translations[state.language] || translations.en; const v = pack[key]; return typeof v === 'string' ? v : (translations.en[key] || key); }
    function apply() {
      console.log('Applying language:', state.language);
      document.documentElement.lang = state.language;

      // Update expand button label first to prevent layout issues
      try {
        updateExpandBtnLabel();
      } catch (e) {
        console.log('Error updating expand button label at start of apply():', e);
      }

      document.getElementById('title').textContent = t('title');
      document.getElementById('zoomLabel').textContent = t('zoom_label');
      document.getElementById('zoomHint').textContent = t('zoom_hint');
      var atL = document.getElementById('areaToggleLabel'); if (atL) atL.textContent = (translations[state.language].area_toggle || translations.en.area_toggle || 'Limit area');
      var acB = document.getElementById('areaClear'); if (acB) {
        const text = (translations[state.language].area_clear || translations.en.area_clear || '–û—á–∏—Å—Ç–∏—Ç—å');
        acB.title = text;
        acB.setAttribute('aria-label', text);
      }
      var ieL = document.getElementById('ignoreEffectsLabel'); if (ieL) ieL.textContent = t('ignore_effects');
      var ieH = document.getElementById('ignoreEffectsHint'); if (ieH) ieH.textContent = t('ignore_effects_hint');
      var ptL = document.getElementById('previewToggleLabel'); if (ptL) ptL.textContent = (translations[state.language].preview_toggle || translations.en.preview_toggle || 'Result preview');
      var poL = document.getElementById('previewOpacityLabel'); if (poL) poL.textContent = (translations[state.language].preview_opacity || translations.en.preview_opacity || 'Result opacity');
      document.getElementById('sourceColorGroup').textContent = t('source_group');
      var sourceStepHint = document.getElementById('sourceStepHint');
      if (sourceStepHint) sourceStepHint.textContent = t('source_step_hint') || 'üìç Step 1: Enter or pick the color you want to replace';
      document.getElementById('srcColorLabel').textContent = t('source_label');
      document.getElementById('targetColorGroup').textContent = t('target_group');
      var targetStepHint = document.getElementById('targetStepHint');
      if (targetStepHint) targetStepHint.textContent = t('target_step_hint') || 'üéØ Step 2: Enter or pick the new color for replacement';
      document.getElementById('targetColorLabel').textContent = t('target_label');
      // Icon-only buttons: set titles only
      var pbtn = document.getElementById('pipette-btn');
      if (pbtn) {
        pbtn.title = t('pipette');
        pbtn.setAttribute('aria-label', t('pipette'));
      }
      document.getElementById('pipette-hint').textContent = t('pipette_hint');
      var psb = document.getElementById('pipette-src-btn');
      if (psb) {
        psb.title = t('pipette_src');
        psb.setAttribute('aria-label', t('pipette_src'));
      }
      var pipetteIgnore = document.getElementById('pipette-ignore-btn');
      if (pipetteIgnore) {
        pipetteIgnore.title = t('pipette_ignore');
        pipetteIgnore.setAttribute('aria-label', t('pipette_ignore'));
      }
      document.getElementById('srcPipetteHint').textContent = t('source_hint');
      document.getElementById('ignoreGroupTitle').textContent = t('ignore_title');
      document.getElementById('ignoreGroupHint').textContent = t('ignore_hint');
      document.getElementById('ignoreNote').textContent = t('ignore_note');

      // Update thresholds section
      var thresholdsTitle = document.getElementById('thresholdsTitle');
      if (thresholdsTitle) thresholdsTitle.textContent = t('thresholds_title') || 'Thresholds';

      var thresholdsStepHint = document.getElementById('thresholdsStepHint');
      if (thresholdsStepHint) thresholdsStepHint.textContent = t('thresholds_step_hint') || '‚öôÔ∏è Step 3: Adjust how similar colors should be to get replaced';

      // Update modes section titles
      var modesTitle = document.getElementById('modesTitle');
      if (modesTitle) modesTitle.textContent = t('fs_modes_title') || 'Modes';

      var applyToTitle = document.getElementById('applyToTitle');
      if (applyToTitle) applyToTitle.textContent = t('fs_apply_to_title') || 'Apply to';

      document.getElementById('applyOriginal').textContent = t('apply_original');
      document.getElementById('applyCopy').textContent = t('apply_copy');
      document.getElementById('hueTolLabel').textContent = t('hue_label');
      document.getElementById('satTolLabel').textContent = t('sat_label');
      document.getElementById('lightTolLabel').textContent = t('light_label');
      document.getElementById('intensityLabel').textContent = t('intensity_label');
      document.getElementById('create-btn').textContent = t('create');
      document.getElementById('footerLink').textContent = translations[state.language].footer || 'by Sensey';

      // Update replace mode labels
      var modeHsl = document.getElementById('modeHsl');
      if (modeHsl) modeHsl.textContent = t('mode_hsl') || 'HSL shift';

      var modeTarget = document.getElementById('modeTarget');
      if (modeTarget) modeTarget.textContent = t('mode_target') || 'To target (RGB)';

      // Update source tip
      var sourceTip = document.getElementById('sourceTip');
      if (sourceTip) sourceTip.textContent = t('source_tip') || 'üí° Tip: Use the green eyedropper to precisely pick the source color from the image';

      // Update area help tooltip
      var areaHelp = document.getElementById('areaHelp');
      if (areaHelp) areaHelp.title = t('tools_help') || 'Selection tools help';

      // Update tool selector dropdown names
      document.querySelectorAll('.tool-selector-option .tool-name').forEach(el => {
        const i18nKey = el.getAttribute('data-i18n');
        if (i18nKey) {
          el.textContent = t(i18nKey) || el.textContent;
        }
      });

      // Update expand button label if available
      try {
        updateExpandBtnLabel();
      } catch (e) {
        console.log('Error updating expand button label in apply():', e);
      }

      // Update main interface tool buttons
      var areaNew = document.getElementById('areaNew');
      if (areaNew) {
        areaNew.title = t('tool_new_path') || 'New Path';
        areaNew.setAttribute('aria-label', t('tool_new_path') || 'New Path');
      }

      var areaUndo = document.getElementById('areaUndo');
      if (areaUndo) {
        areaUndo.title = t('tool_undo_point') || 'Undo Point';
        areaUndo.setAttribute('aria-label', t('tool_undo_point') || 'Undo Point');
      }

      var areaDelete = document.getElementById('areaDelete');
      if (areaDelete) {
        areaDelete.title = t('tool_delete_path') || 'Delete Path';
        areaDelete.setAttribute('aria-label', t('tool_delete_path') || 'Delete Path');
      }

      var ignoreAdd = document.getElementById('ignore-add');
      if (ignoreAdd) {
        ignoreAdd.title = t('tool_add') || 'Add';
        ignoreAdd.setAttribute('aria-label', t('tool_add') || 'Add');
      }

      // Update placeholders
      var colorInput = document.getElementById('color-input');
      if (colorInput) colorInput.placeholder = '#AABBCC';

      var srcColorInput = document.getElementById('src-color-input');
      if (srcColorInput) srcColorInput.placeholder = t('src_placeholder') || '#RRGGBB';

      var ignoreHex = document.getElementById('ignore-hex');
      if (ignoreHex) ignoreHex.placeholder = '#RRGGBB';

      // Update tool options text (keep icons but add tooltips)
      var toolRectOpt = document.getElementById('toolRectOpt');
      var toolRectOptText = document.getElementById('toolRectOptText');
      if (toolRectOpt) toolRectOpt.title = t('tool_rectangle') || 'Rectangle';
      if (toolRectOptText) toolRectOptText.textContent = t('tool_rectangle') || 'Rectangle';

      var toolPenOpt = document.getElementById('toolPenOpt');
      var toolPenOptText = document.getElementById('toolPenOptText');
      if (toolPenOpt) toolPenOpt.title = t('tool_pen') || 'Pen';
      if (toolPenOptText) toolPenOptText.textContent = t('tool_pen') || 'Pen';

      var toolLassoOpt = document.getElementById('toolLassoOpt');
      var toolLassoOptText = document.getElementById('toolLassoOptText');
      if (toolLassoOpt) toolLassoOpt.title = t('tool_lasso') || 'Lasso';
      if (toolLassoOptText) toolLassoOptText.textContent = t('tool_lasso') || 'Lasso';

      var toolWandOpt = document.getElementById('toolWandOpt');
      var toolWandOptText = document.getElementById('toolWandOptText');
      if (toolWandOpt) toolWandOpt.title = t('tool_wand') || 'Magic Wand';
      if (toolWandOptText) toolWandOptText.textContent = t('tool_wand') || 'Magic Wand';

      // Update fullscreen mode elements
      updateFullscreenElements();

      // Update license UI with new language
      updateLicenseUI();
      // Localize initial empty-preview texts and placeholders
      var prevNode = document.getElementById('image-preview');
      var hasImage = !!document.querySelector('#image-preview img');
      if (prevNode && !hasImage) {
        prevNode.textContent = t('preview_placeholder');
        var cb = document.getElementById('create-btn'); if (cb) cb.disabled = true;
      }
      var srcInp = document.getElementById('src-color-input');
      if (srcInp) { var p = (translations[state.language] && translations[state.language].src_placeholder) || translations.en.src_placeholder || '#RRGGBB'; srcInp.placeholder = p; }
      renderLanguageSwitcher();
    }

    function renderLanguageSwitcher() {
      const selBtn = document.getElementById('languageSelected');
      const dd = document.getElementById('languageDropdown');
      const current = languages.find(l => l.code === state.language) || languages.find(l => l.code === 'ru') || languages[0];
      const flag = document.createElement('span'); flag.className = 'language-flag'; renderFlag(flag, current);
      const name = document.createElement('span'); name.className = 'language-name'; name.textContent = current.name;
      selBtn.textContent = ''; selBtn.appendChild(flag); selBtn.appendChild(name);
      // click handler is bound once below via addEventListener; avoid duplicate handlers here
      dd.textContent = '';
      languages.filter(l => l.code !== state.language).forEach(lang => {
        const b = document.createElement('button'); b.type = 'button'; b.className = 'language-option'; b.dataset.code = lang.code;
        const f = document.createElement('span'); f.className = 'language-flag'; renderFlag(f, lang);
        const n = document.createElement('span'); n.className = 'language-name'; n.textContent = lang.name;
        b.appendChild(f); b.appendChild(n);
        b.addEventListener('click', () => { setLanguage(lang.code); toggleLanguageDropdown(false); });
        dd.appendChild(b);
      });
    }
    function setLanguage(code) {
      console.log('Setting language to:', code);
      state.language = translations[code] ? code : 'en';
      console.log('Language set to:', state.language);
      storeLanguage(state.language);
      apply();
    }
    let langOpen = false;
    function toggleLanguageDropdown(force) {
      var dd = document.getElementById('languageDropdown');
      var btn = document.getElementById('languageSelected');
      langOpen = (typeof force === 'boolean') ? force : !langOpen;
      if (langOpen) {
        btn.classList.add('active');
        dd.classList.remove('hidden');
        dd.style.display = 'flex';
      } else {
        btn.classList.remove('active');
        dd.classList.add('hidden');
        dd.style.display = '';
      }
    }
    var __langBtn = document.getElementById('languageSelected');
    if (__langBtn) {
      __langBtn.addEventListener('click', function (e) { e.stopPropagation(); toggleLanguageDropdown(); });
    }
    // Close dropdown on outside click only
    document.addEventListener('click', function (e) {
      var switcher = document.getElementById('languageSwitcher');
      if (!switcher) return;
      if (!switcher.contains(e.target)) { toggleLanguageDropdown(false); }
    });
    // Test function for debugging language storage
    function testLanguageStorage() {
      console.log('=== Language Storage Test ===');
      console.log('Current state.language:', state.language);
      console.log('Available translations:', Object.keys(translations));
      console.log('localStorage not used in Figma plugins');

      // Test storing a language
      console.log('Testing language storage...');
      storeLanguage('en');

      // Request current language from Figma
      if (typeof parent !== 'undefined' && parent.postMessage) {
        parent.postMessage({ pluginMessage: { type: 'get-language' } }, '*');
        console.log('Requested current language from Figma storage');
      }
    }

    // Make test function available globally for debugging
    window.testLanguageStorage = testLanguageStorage;

    // Language initialization will be done after DOM elements are defined
    // No extra JS rebinding here to avoid double toggles; theme is bound in initTheme(), language below
    const preview = document.getElementById('image-preview');
    const createBtn = document.getElementById('create-btn');
    const pipetteBtn = document.getElementById('pipette-btn');
    const pickedSwatch = document.getElementById('picked-swatch');
    const pickedHex = document.getElementById('picked-hex');
    const pipetteSrcBtn = document.getElementById('pipette-src-btn');
    const srcColorInput = document.getElementById('src-color-input');
    const ignoreInput = document.getElementById('ignore-hex');
    const ignoreAddBtn = document.getElementById('ignore-add');
    const ignoreListEl = document.getElementById('ignore-list');
    const pipetteIgnoreBtn = document.getElementById('pipette-ignore-btn');
    // Color picker elements
    const cpSquare = document.getElementById('cpSquare');
    const cpHue = document.getElementById('cpHue');
    const zoomEl = document.getElementById('zoom');
    const zoomVal = document.getElementById('zoomVal');
    const hueTol = document.getElementById('hueTol');
    const hueTolVal = document.getElementById('hueTolVal');
    const satTol = document.getElementById('satTol');
    const satTolVal = document.getElementById('satTolVal');
    const lightTol = document.getElementById('lightTol');
    const lightTolVal = document.getElementById('lightTolVal');
    const intensity = document.getElementById('intensity');
    const intensityVal = document.getElementById('intensityVal');
    const previewToggleEl = document.getElementById('previewToggle');
    const previewToggle = previewToggleEl || { checked: true };
    const previewOpacityEl = document.getElementById('previewOpacity');
    const previewOpacity = previewOpacityEl || { value: 100 };
    const areaToggle = document.getElementById('areaToggle');
    const areaClearBtn = document.getElementById('areaClear');
    const areaToolEl = document.getElementById('areaTool');
    const areaNewBtn = document.getElementById('areaNew');
    const areaUndoBtn = document.getElementById('areaUndo');
    const areaDeleteBtn = document.getElementById('areaDelete');
    const expandBtn = document.getElementById('expandBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const zoomBadge = document.getElementById('zoomBadge');
    const fsPalette = document.getElementById('fsPalette');
    // FS color picker elements
    const cpSquareFs = document.getElementById('cpSquareFs');
    const cpHueFs = document.getElementById('cpHueFs');
    let overlayCanvas = null;
    let selectionCanvas = null; // overlay for drawing selection shapes/handles
    let selectionInteractive = false; // when true, canvas accepts pointer events for dragging anchors/handles
    let livePreviewTimer = null; // legacy timeout id (kept for safety)
    let lastPreviewAt = 0;
    const PREVIEW_MIN_DELAY = 80; // limit preview updates frequency (ms)
    let previewRafId = null; // rAF id for coalescing live preview renders
    let previewTimeoutId = null; // timeout used to satisfy min-delay when rAF fires too soon
    let marker = null;
    let selectedCoords = null;
    let pipetteMode = null; // 'target'|'source'|'ignore'|null
    let zoom = 1;
    let previewSizer = null; // invisible sizer to reflect zoomed layout size for scrolling
    let selectionRafId = null; // rAF id for coalescing selection overlay draws
    const ignoreColors = [];
    pipetteBtn.addEventListener('click', () => { pipetteMode = pipetteMode === 'target' ? null : 'target'; updatePipetteButtons(); });
    pipetteSrcBtn.addEventListener('click', () => { pipetteMode = pipetteMode === 'source' ? null : 'source'; updatePipetteButtons(); });
    pipetteIgnoreBtn.addEventListener('click', () => { pipetteMode = pipetteMode === 'ignore' ? null : 'ignore'; updatePipetteButtons(); });
    hueTol.addEventListener('input', () => { hueTolVal.textContent = String(hueTol.value); scheduleLivePreview(); });
    satTol.addEventListener('input', () => { satTolVal.textContent = (Number(satTol.value) / 100).toFixed(2); scheduleLivePreview(); });
    lightTol.addEventListener('input', () => { lightTolVal.textContent = (Number(lightTol.value) / 100).toFixed(2); scheduleLivePreview(); });

    // –£—Å—Ç–∞–Ω–æ–≤–∏–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    hueTolVal.textContent = '25';
    satTolVal.textContent = '0.25';
    lightTolVal.textContent = '0.25';

    // Fullscreen —ç–ª–µ–º–µ–Ω—Ç—ã
    const fsColorInput = document.getElementById('fsColorInput');
    const fsSrcColorInput = document.getElementById('fsSrcColorInput');
    const fsHueTol = document.getElementById('fsHueTol');
    const fsHueTolVal = document.getElementById('fsHueTolVal');
    const fsSatTol = document.getElementById('fsSatTol');
    const fsSatTolVal = document.getElementById('fsSatTolVal');
    const fsLightTol = document.getElementById('fsLightTol');
    const fsLightTolVal = document.getElementById('fsLightTolVal');
    const fsIntensity = document.getElementById('fsIntensity');
    const fsIntensityVal = document.getElementById('fsIntensityVal');
    const fsIgnoreHex = document.getElementById('fsIgnoreHex');
    const fsIgnoreAdd = document.getElementById('fsIgnoreAdd');
    const fsIgnoreList = document.getElementById('fsIgnoreList');

    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –º–µ–∂–¥—É –æ–±—ã—á–Ω–æ–π –∏ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–π –≤–µ—Ä—Å–∏—è–º–∏
    function syncToFs() {
      if (fsColorInput && document.getElementById('color-input')) {
        fsColorInput.value = document.getElementById('color-input').value;
      }
      if (fsSrcColorInput && srcColorInput) {
        fsSrcColorInput.value = srcColorInput.value;
      }
      if (fsHueTol && hueTol) {
        fsHueTol.value = hueTol.value;
        fsHueTolVal.textContent = hueTol.value + '¬∞';
      }
      if (fsSatTol && satTol) {
        fsSatTol.value = satTol.value;
        fsSatTolVal.textContent = (Number(satTol.value) / 100).toFixed(2);
      }
      if (fsLightTol && lightTol) {
        fsLightTol.value = lightTol.value;
        fsLightTolVal.textContent = (Number(lightTol.value) / 100).toFixed(2);
      }
      if (fsIntensity && intensity) {
        fsIntensity.value = intensity.value;
        fsIntensityVal.textContent = intensity.value + '%';
      }
    }

    function syncFromFs() {
      if (fsColorInput && document.getElementById('color-input')) {
        document.getElementById('color-input').value = fsColorInput.value;
      }
      if (fsSrcColorInput && srcColorInput) {
        srcColorInput.value = fsSrcColorInput.value;
      }
      if (fsHueTol && hueTol) {
        hueTol.value = fsHueTol.value;
        hueTolVal.textContent = fsHueTol.value;
      }
      if (fsSatTol && satTol) {
        satTol.value = fsSatTol.value;
        satTolVal.textContent = (Number(fsSatTol.value) / 100).toFixed(2);
      }
      if (fsLightTol && lightTol) {
        lightTol.value = fsLightTol.value;
        lightTolVal.textContent = (Number(fsLightTol.value) / 100).toFixed(2);
      }
      if (fsIntensity && intensity) {
        intensity.value = fsIntensity.value;
        intensityVal.textContent = fsIntensity.value + '%';
      }
    }
    intensity.addEventListener('input', () => { intensityVal.textContent = intensity.value + '%'; scheduleLivePreview(); });
    ignoreAddBtn.addEventListener('click', () => { const hex = (ignoreInput.value || '').trim(); if (/^#([0-9A-Fa-f]{6})$/.test(hex)) { addIgnore(hex); ignoreInput.value = ''; scheduleLivePreview(); } });
    zoomEl.addEventListener('input', () => { zoom = Number(zoomEl.value) / 100; zoomVal.textContent = Math.round(zoom * 100) + '%'; applyZoom(); });

    // ---- Auto-# for HEX inputs ----
    function attachAutoHash(el) {
      if (!el) return;
      const normalize = () => {
        let v = (el.value || '').trim();
        if (/^[0-9A-Fa-f]{6}$/.test(v)) { el.value = ('#' + v).toUpperCase(); }
        else if (/^#[0-9A-Fa-f]{6}$/.test(v)) { el.value = v.toUpperCase(); }
      };
      el.addEventListener('blur', normalize);
      el.addEventListener('change', normalize);
      el.addEventListener('paste', () => setTimeout(normalize, 0));
    }
    attachAutoHash(document.getElementById('color-input'));
    attachAutoHash(srcColorInput);
    attachAutoHash(ignoreInput);
    // Update color picker when HEX changes manually
    const colorInputEl = document.getElementById('color-input');
    if (colorInputEl) { colorInputEl.addEventListener('input', () => { const v = (colorInputEl.value || '').trim(); if (/^#([0-9A-Fa-f]{6})$/.test(v)) { setPickerFromHex(v.toUpperCase()); } }); }
    // Live preview when source HEX is typed/edited
    if (srcColorInput) { srcColorInput.addEventListener('input', () => { const v = (srcColorInput.value || '').trim(); if (/^#([0-9A-Fa-f]{6})$/.test(v)) { scheduleLivePreview(); } }); }
    let lastPreviewBytes = null;
    let previewW = 0, previewH = 0;
    let lastFillBytes = null;
    let fillW = 0, fillH = 0; // –±—É–¥—É—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –ø–æ—Å–ª–µ decode
    let imgEl = null;
    let pendingAction = null;
    // ---- Area selection (rect) ----
    let selectionNat = null; // {x,y,w,h} –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –ø—Ä–µ–≤—å—é (–Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–µ –ø–∏–∫—Å–µ–ª–∏ previewW/H)
    let selectionDragging = false;
    let selectionStartDom = null; // {x,y} DOM-–ø–æ–∑–∏—Ü–∏–∏ –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ø—Ä–µ–≤—å—é
    let selectionStartNat = null; // {x,y} –Ω–∞—Ç.–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ø—Ä–µ–≤—å—é
    let selectionRectEl = null;
    let suppressClickOnce = false;

    // advanced selections
    let selectionTool = 'rect';
    let shapes = []; // {type:'path', points:[{x,y,cp:{x,y}|null}], closed:true} OR {type:'rect', x,y,w,h}
    let openPath = null; // current editing path (for pen/lasso)
    let lassoActive = false;

    // Finalize currently open path (if any):
    // - If it has >=3 points, close it and push to shapes
    // - Otherwise, discard it
    function finalizeOpenPath() {
      if (openPath && openPath.points && openPath.points.length >= 3) {
        openPath.closed = true;
        shapes.push(openPath);
      }
      openPath = null;
      lassoActive = false;
      try { drawSelectionOverlay(); scheduleLivePreview(); } catch (_) { }
    }

    // ----- Fullscreen toggle (no persistence) -----
    let isExpanded = false;
    const fsLeft = document.getElementById('fsLeft');
    const fsRight = document.getElementById('fsRight');
    const fsExit = document.getElementById('fsExit');
    const fsPreviewToggle = document.getElementById('fsPreviewToggle');
    const fsOpacity = document.getElementById('fsOpacity');
    const fsCreate = document.getElementById('fsCreate');
    const fsRect = document.getElementById('fsRect');
    const fsPen = document.getElementById('fsPen');
    const fsLasso = document.getElementById('fsLasso');
    const fsWand = document.getElementById('fsWand');
    const fsNewPath = document.getElementById('fsNewPath');
    const fsUndoPt = document.getElementById('fsUndoPt');
    const fsDeletePath = document.getElementById('fsDeletePath');
    // –°—Ç–∞—Ä—ã–µ –ø–∏–ø–µ—Ç–∫–∏ —É–¥–∞–ª–µ–Ω—ã, —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –≤ –ø–æ–ª—è
    const fsZoomIn = document.getElementById('fsZoomIn');
    const fsZoomOut = document.getElementById('fsZoomOut');
    const fsZoomFit = document.getElementById('fsZoomFit');
    const fsZoom100 = document.getElementById('fsZoom100');

    function updateExpandBtnLabel() {
      if (!expandBtn) {
        console.log('expandBtn not found, skipping label update');
        return;
      }
      try {
        const pack = translations[state.language] || translations.en;
        let fullText = isExpanded ? (pack.restore_full || 'Restore') : (pack.expand_full || 'Fullscreen');
        let exitText = pack.restore_full || 'Restore';

        // Update expand button text span
        const btnTextSpan = document.getElementById('expandBtnText');
        if (btnTextSpan) {
          btnTextSpan.textContent = fullText;
        }
        expandBtn.title = fullText;

        // Update exit button
        const fsExitBtnText = document.getElementById('fsExitBtnText');
        if (fsExitBtnText) {
          fsExitBtnText.textContent = exitText;
        }
        const fsExitBtn = document.getElementById('fsExitBtn');
        if (fsExitBtn) {
          fsExitBtn.title = exitText;
        }
      } catch (e) {
        console.log('Error updating expand button label:', e);
      }
    }

    function updateFullscreenElements() {
      try {
        const pack = translations[state.language] || translations.en;

        // Fullscreen tool titles
        const fsSelectionTitle = document.querySelector('#fsLeft .tool-title');
        if (fsSelectionTitle) fsSelectionTitle.textContent = pack.fs_selection || 'Selection';

        const fsZoomTitle = document.querySelector('#fsLeft .tool-group:nth-child(2) .tool-title');
        if (fsZoomTitle) fsZoomTitle.textContent = pack.fs_zoom || 'Zoom';

        const fsColorsTitle = document.querySelector('#fsRight .tool-group:nth-child(1) .tool-title');
        if (fsColorsTitle) fsColorsTitle.textContent = pack.fs_colors || 'Colors';

        const fsThresholdsTitle = document.querySelector('#fsRight .tool-group:nth-child(2) .tool-title');
        if (fsThresholdsTitle) fsThresholdsTitle.textContent = pack.fs_thresholds || 'Thresholds';

        const fsThresholdsStepHint = document.getElementById('fsThresholdsStepHint');
        if (fsThresholdsStepHint) fsThresholdsStepHint.textContent = pack.fs_thresholds_step || '‚öôÔ∏è Step 3';

        const fsModesTitle = document.getElementById('fsModesTitle');
        if (fsModesTitle) fsModesTitle.textContent = pack.fs_modes_title || 'Modes';

        const fsApplyToTitle = document.getElementById('fsApplyToTitle');
        if (fsApplyToTitle) fsApplyToTitle.textContent = pack.fs_apply_to_title || 'Apply to';

        const fsIgnoreTitle = document.querySelector('#fsRight .tool-group:nth-child(4) .tool-title');
        if (fsIgnoreTitle) fsIgnoreTitle.textContent = pack.fs_ignore || 'Ignore';

        // Tool tooltips
        const fsRect = document.getElementById('fsRect');
        if (fsRect) {
          fsRect.title = pack.tool_rectangle || 'Rectangle';
          fsRect.setAttribute('aria-label', pack.tool_rectangle || 'Rectangle');
        }

        const fsPen = document.getElementById('fsPen');
        if (fsPen) {
          fsPen.title = pack.tool_pen || 'Pen';
          fsPen.setAttribute('aria-label', pack.tool_pen || 'Pen');
        }

        const fsLasso = document.getElementById('fsLasso');
        if (fsLasso) {
          fsLasso.title = pack.tool_lasso || 'Lasso';
          fsLasso.setAttribute('aria-label', pack.tool_lasso || 'Lasso');
        }

        const fsWand = document.getElementById('fsWand');
        if (fsWand) {
          fsWand.title = pack.tool_wand || 'Magic Wand';
          fsWand.setAttribute('aria-label', pack.tool_wand || 'Magic Wand');
        }

        const fsUndoPt = document.getElementById('fsUndoPt');
        if (fsUndoPt) {
          fsUndoPt.title = pack.tool_undo_point || 'Undo Point';
          fsUndoPt.setAttribute('aria-label', pack.tool_undo_point || 'Undo Point');
        }

        const fsDeletePath = document.getElementById('fsDeletePath');
        if (fsDeletePath) {
          fsDeletePath.title = pack.tool_delete_path || 'Delete Path';
          fsDeletePath.setAttribute('aria-label', pack.tool_delete_path || 'Delete Path');
        }

        const fsClearSelection = document.getElementById('fsClearSelection');
        if (fsClearSelection) {
          const clearText = pack.area_clear || 'Clear Selection';
          fsClearSelection.title = clearText;
          fsClearSelection.setAttribute('aria-label', clearText);
        }

        // Zoom buttons (icons, no text update needed for In/Out)
        const fsZoomFit = document.getElementById('fsZoomFit');
        if (fsZoomFit) fsZoomFit.textContent = pack.btn_zoom_fit || 'Fit';

        const fsZoom100 = document.getElementById('fsZoom100');
        if (fsZoom100) fsZoom100.textContent = pack.btn_zoom_100 || '100%';

        // Pipette tooltips
        const fsPipetteTarget = document.getElementById('fsPipetteTarget');
        if (fsPipetteTarget) fsPipetteTarget.title = pack.pipette_target_tooltip || 'Pick target color';

        const fsPipetteSource = document.getElementById('fsPipetteSource');
        if (fsPipetteSource) fsPipetteSource.title = pack.pipette_source_tooltip || 'Pick source color';

        const fsPipetteIgnore = document.getElementById('fsPipetteIgnore');
        if (fsPipetteIgnore) fsPipetteIgnore.title = pack.pipette_ignore_tooltip || 'Pick ignore color';

        const fsIgnoreAdd = document.getElementById('fsIgnoreAdd');
        if (fsIgnoreAdd) fsIgnoreAdd.title = pack.tool_add || 'Add';

        // Create button
        const fsCreate = document.getElementById('fsCreate');
        if (fsCreate) fsCreate.textContent = pack.btn_create || 'Create';

        // Color labels
        const fsTargetLabel = document.getElementById('fsTargetLabel');
        if (fsTargetLabel) fsTargetLabel.textContent = pack.fs_target_color || 'Target:';

        const fsSourceLabel = document.getElementById('fsSourceLabel');
        if (fsSourceLabel) fsSourceLabel.textContent = pack.fs_source_color || 'Source:';

        // Threshold labels
        const fsHueLabel = document.getElementById('fsHueLabel');
        if (fsHueLabel) fsHueLabel.textContent = pack.fs_hue || 'Hue';

        const fsSatLabel = document.getElementById('fsSatLabel');
        if (fsSatLabel) fsSatLabel.textContent = pack.fs_saturation || 'Saturation';

        const fsLightLabel = document.getElementById('fsLightLabel');
        if (fsLightLabel) fsLightLabel.textContent = pack.fs_lightness || 'Lightness';

        const fsIntensLabel = document.getElementById('fsIntensLabel');
        if (fsIntensLabel) fsIntensLabel.textContent = pack.fs_intensity || 'Intensity';

        // Mode labels
        const fsOriginalLabel = document.getElementById('fsOriginalLabel');
        if (fsOriginalLabel) fsOriginalLabel.textContent = pack.fs_original || 'Original';

        const fsCopyLabel = document.getElementById('fsCopyLabel');
        if (fsCopyLabel) fsCopyLabel.textContent = pack.fs_copy || 'Copy';

        const fsHslLabel = document.getElementById('fsHslLabel');
        if (fsHslLabel) fsHslLabel.textContent = pack.fs_hsl || 'HSL';

        const fsRgbLabel = document.getElementById('fsRgbLabel');
        if (fsRgbLabel) fsRgbLabel.textContent = pack.fs_rgb || 'RGB';

        // Placeholders
        const fsColorInput = document.getElementById('fsColorInput');
        if (fsColorInput) fsColorInput.placeholder = '#AABBCC';

        const fsSrcColorInput = document.getElementById('fsSrcColorInput');
        if (fsSrcColorInput) fsSrcColorInput.placeholder = '#RRGGBB';

        const fsIgnoreHex = document.getElementById('fsIgnoreHex');
        if (fsIgnoreHex) fsIgnoreHex.placeholder = '#RRGGBB';

      } catch (e) {
        console.log('Error updating fullscreen elements:', e);
      }
    }
    function requestResize(expanded) { parent.postMessage({ pluginMessage: { type: 'request-resize', preset: expanded ? 'max' : 'normal' } }, '*'); }
    // –§—É–Ω–∫—Ü–∏—è applyFsLayout –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –Ω–∏–∂–µ —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π
    if (expandBtn && !expandBtn.__w) { expandBtn.__w = true; expandBtn.addEventListener('click', () => { isExpanded = !isExpanded; applyFsLayout(); requestResize(isExpanded); }); }
    const fsExitBtn = document.getElementById('fsExitBtn');
    if (fsExitBtn && !fsExitBtn.__w) { fsExitBtn.__w = true; fsExitBtn.addEventListener('click', () => { isExpanded = false; applyFsLayout(); requestResize(false); }); }
    if (fsExit && !fsExit.__w) { fsExit.__w = true; fsExit.addEventListener('click', () => { isExpanded = false; applyFsLayout(); requestResize(false); }); }
    if (fsPreviewToggle && !fsPreviewToggle.__w) { fsPreviewToggle.__w = true; fsPreviewToggle.addEventListener('change', () => { if (previewToggle) { previewToggle.checked = fsPreviewToggle.checked; } if (previewToggle.checked) { ensureOverlay(); scheduleLivePreview(); } else if (overlayCanvas) { overlayCanvas.style.display = 'none'; } }); }
    if (fsOpacity && !fsOpacity.__w) { fsOpacity.__w = true; fsOpacity.addEventListener('input', () => { if (previewOpacity) { previewOpacity.value = fsOpacity.value; } updateOverlayOpacity(); }); }
    if (fsCreate && !fsCreate.__w) { fsCreate.__w = true; fsCreate.addEventListener('click', () => { const btn = document.getElementById('create-btn'); if (btn) btn.click(); }); }

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    if (fsColorInput && !fsColorInput.__w) {
      fsColorInput.__w = true;
      fsColorInput.addEventListener('input', () => {
        syncFromFs();
        const v = fsColorInput.value.trim();
        if (/^#([0-9A-Fa-f]{6})$/.test(v)) setPickerFromHex(v.toUpperCase());
      });
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ # –¥–ª—è fullscreen
      normalizeHexInput(fsColorInput);
    }

    if (fsSrcColorInput && !fsSrcColorInput.__w) {
      fsSrcColorInput.__w = true;
      fsSrcColorInput.addEventListener('input', () => {
        syncFromFs();
        scheduleLivePreview();
      });
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ # –¥–ª—è fullscreen
      normalizeHexInput(fsSrcColorInput);
    }

    if (fsHueTol && !fsHueTol.__w) {
      fsHueTol.__w = true;
      fsHueTol.addEventListener('input', () => {
        fsHueTolVal.textContent = fsHueTol.value + '¬∞';
        syncFromFs();
        scheduleLivePreview();
      });
    }

    if (fsSatTol && !fsSatTol.__w) {
      fsSatTol.__w = true;
      fsSatTol.addEventListener('input', () => {
        fsSatTolVal.textContent = (Number(fsSatTol.value) / 100).toFixed(2);
        syncFromFs();
        scheduleLivePreview();
      });
    }

    if (fsLightTol && !fsLightTol.__w) {
      fsLightTol.__w = true;
      fsLightTol.addEventListener('input', () => {
        fsLightTolVal.textContent = (Number(fsLightTol.value) / 100).toFixed(2);
        syncFromFs();
        scheduleLivePreview();
      });
    }

    if (fsIntensity && !fsIntensity.__w) {
      fsIntensity.__w = true;
      fsIntensity.addEventListener('input', () => {
        fsIntensityVal.textContent = fsIntensity.value + '%';
        syncFromFs();
        scheduleLivePreview();
      });
    }

    if (fsIgnoreAdd && !fsIgnoreAdd.__w) {
      fsIgnoreAdd.__w = true;
      fsIgnoreAdd.addEventListener('click', () => {
        const hex = (fsIgnoreHex.value || '').trim();
        if (/^#([0-9A-Fa-f]{6})$/.test(hex)) {
          addIgnore(hex);
          fsIgnoreHex.value = '';
          scheduleLivePreview();
        }
      });
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ # –¥–ª—è fullscreen ignore
      normalizeHexInput(fsIgnoreHex);
    }

    // –ù–æ–≤—ã–µ –ø–∏–ø–µ—Ç–∫–∏ —Ä—è–¥–æ–º —Å –ø–æ–ª—è–º–∏
    const fsPipetteTarget = document.getElementById('fsPipetteTarget');
    const fsPipetteSource = document.getElementById('fsPipetteSource');
    const fsPipetteIgnore = document.getElementById('fsPipetteIgnore');

    if (fsPipetteTarget && !fsPipetteTarget.__w) {
      fsPipetteTarget.__w = true;
      fsPipetteTarget.addEventListener('click', () => {
        pipetteMode = pipetteMode === 'target' ? null : 'target';
        updatePipetteButtons();
      });
    }

    if (fsPipetteSource && !fsPipetteSource.__w) {
      fsPipetteSource.__w = true;
      fsPipetteSource.addEventListener('click', () => {
        pipetteMode = pipetteMode === 'source' ? null : 'source';
        updatePipetteButtons();
      });
    }

    if (fsPipetteIgnore && !fsPipetteIgnore.__w) {
      fsPipetteIgnore.__w = true;
      fsPipetteIgnore.addEventListener('click', () => {
        pipetteMode = pipetteMode === 'ignore' ? null : 'ignore';
        updatePipetteButtons();
      });
    }

    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Ä–µ–∂–∏–º–æ–≤
    document.querySelectorAll('input[name="fs-apply-mode"]').forEach(radio => {
      if (!radio.__w) {
        radio.__w = true;
        radio.addEventListener('change', () => {
          const mainRadio = document.querySelector(`input[name="apply-mode"][value="${radio.value}"]`);
          if (mainRadio) mainRadio.checked = true;
        });
      }
    });

    document.querySelectorAll('input[name="fs-replace-mode"]').forEach(radio => {
      if (!radio.__w) {
        radio.__w = true;
        radio.addEventListener('change', () => {
          const mainRadio = document.querySelector(`input[name="replace-mode"][value="${radio.value}"]`);
          if (mainRadio) mainRadio.checked = true;
        });
      }
    });

    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –≤ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º
    function applyFsLayout() {
      if (isExpanded) {
        document.body.classList.add('fs');
        if (fsLeft) fsLeft.classList.remove('hidden');
        if (fsRight) fsRight.classList.remove('hidden');
        syncToFs(); // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç–æ–≤–æ–π –ø–∏–∫–µ—Ä
        setTimeout(() => {
          if (typeof initColorPickerFs !== 'undefined') {
            initColorPickerFs();
          }
          updatePipetteButtons(); // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–∏–ø–µ—Ç–æ–∫
        }, 100);
      } else {
        document.body.classList.remove('fs');
        if (fsLeft) fsLeft.classList.add('hidden');
        if (fsRight) fsRight.classList.add('hidden');
      }
      updateExpandBtnLabel();
      // sync right panel controls
      if (fsPreviewToggle && previewToggle) fsPreviewToggle.checked = !!previewToggle.checked;
      if (fsOpacity && previewOpacity) fsOpacity.value = String(previewOpacity.value || 100);
    }
    function updateActiveToolButtons() {
      if (!fsRect || !fsPen || !fsLasso) return;
      fsRect.classList.remove('is-active'); fsPen.classList.remove('is-active'); fsLasso.classList.remove('is-active'); if (fsWand) fsWand.classList.remove('is-active');
      const tool = (areaToolEl && areaToolEl.value) || selectionTool;
      if (tool === 'rect') fsRect.classList.add('is-active');
      else if (tool === 'pen') fsPen.classList.add('is-active');
      else if (tool === 'lasso') fsLasso.classList.add('is-active');
      else if (tool === 'wand' && fsWand) fsWand.classList.add('is-active');
    }
    if (fsRect && !fsRect.__w) { fsRect.__w = true; fsRect.addEventListener('click', () => { finalizeOpenPath(); selectionTool = 'rect'; if (areaToggle) areaToggle.checked = true; if (areaToolEl) areaToolEl.value = 'rect'; updateActiveToolButtons(); drawSelectionOverlay(); }); }
    if (fsPen && !fsPen.__w) { fsPen.__w = true; fsPen.addEventListener('click', () => { finalizeOpenPath(); selectionTool = 'pen'; if (areaToggle) areaToggle.checked = true; if (areaToolEl) areaToolEl.value = 'pen'; updateActiveToolButtons(); drawSelectionOverlay(); }); }
    if (fsLasso && !fsLasso.__w) { fsLasso.__w = true; fsLasso.addEventListener('click', () => { finalizeOpenPath(); selectionTool = 'lasso'; if (areaToggle) areaToggle.checked = true; if (areaToolEl) areaToolEl.value = 'lasso'; updateActiveToolButtons(); drawSelectionOverlay(); }); }
    if (fsWand && !fsWand.__w) { fsWand.__w = true; fsWand.addEventListener('click', () => { finalizeOpenPath(); selectionTool = 'wand'; if (areaToggle) areaToggle.checked = true; if (areaToolEl) areaToolEl.value = 'wand'; updateActiveToolButtons(); drawSelectionOverlay(); }); }
    if (fsUndoPt && !fsUndoPt.__w) { fsUndoPt.__w = true; fsUndoPt.addEventListener('click', () => { if (openPath && openPath.points && openPath.points.length > 0) { openPath.points.pop(); drawSelectionOverlay(); } }); }
    // –°—Ç–∞—Ä—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–∏–ø–µ—Ç–æ–∫ —É–¥–∞–ª–µ–Ω—ã
    function setZoomAndUi(z) {
      zoom = Math.max(0.1, Math.min(8, z));
      if (zoomEl) { zoomEl.value = String(Math.round(zoom * 100)); zoomVal.textContent = Math.round(zoom * 100) + '%'; }
      if (zoomBadge) { zoomBadge.textContent = Math.round(zoom * 100) + '%'; }
      applyZoom();
    }
    if (fsZoomIn && !fsZoomIn.__w) { fsZoomIn.__w = true; fsZoomIn.addEventListener('click', () => setZoomAndUi(zoom + 0.1)); }
    if (fsZoomOut && !fsZoomOut.__w) { fsZoomOut.__w = true; fsZoomOut.addEventListener('click', () => setZoomAndUi(zoom - 0.1)); }
    if (fsZoom100 && !fsZoom100.__w) { fsZoom100.__w = true; fsZoom100.addEventListener('click', () => setZoomAndUi(1)); }
    if (fsZoomFit && !fsZoomFit.__w) { fsZoomFit.__w = true; fsZoomFit.addEventListener('click', () => { if (!previewW || !previewH) return; const r = preview.getBoundingClientRect(); const pad = 24; const sx = (r.width - pad) / previewW; const sy = (r.height - pad) / previewH; const z = Math.max(0.1, Math.min(8, Math.min(sx, sy))); setZoomAndUi(z); }); }

    function ensureSelectionRect() {
      if (!selectionRectEl) {
        selectionRectEl = document.createElement('div');
        selectionRectEl.className = 'selection-rect';
        selectionRectEl.style.display = 'none';
        preview.appendChild(selectionRectEl);
      }
    }
    function clearSelection() {
      selectionNat = null;
      selectionDragging = false;
      openPath = null;
      lassoActive = false;
      shapes = [];
      ensureSelectionRect();
      selectionRectEl.style.display = 'none';
      drawSelectionOverlay();
      scheduleLivePreview();
    }
    if (areaClearBtn) areaClearBtn.addEventListener('click', clearSelection);
    if (areaToggle) areaToggle.addEventListener('change', () => { if (!areaToggle.checked) clearSelection(); });

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —á–µ–∫–±–æ–∫—Å–∞ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
    const ignoreEffectsCheckbox = document.getElementById('ignoreEffects');
    if (ignoreEffectsCheckbox) {
      ignoreEffectsCheckbox.addEventListener('change', () => {
        parent.postMessage({ pluginMessage: { type: 'refresh-preview', ignoreEffects: ignoreEffectsCheckbox.checked } }, '*');
      });
    }

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ # –∫ HEX –∫–æ–¥–∞–º
    function normalizeHexInput(input) {
      if (!input) return;
      input.addEventListener('blur', () => {
        let value = input.value.trim();
        if (value && !value.startsWith('#')) {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –ø–æ—Ö–æ–∂–µ –Ω–∞ HEX (—Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã –∏ A-F)
          if (/^[0-9A-Fa-f]{3,6}$/.test(value)) {
            input.value = '#' + value.toUpperCase();
          }
        } else if (value.startsWith('#')) {
          // –ü—Ä–∏–≤–æ–¥–∏–º –∫ –≤–µ—Ä—Ö–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É
          input.value = value.toUpperCase();
        }
      });
    }

    const colorInput = document.getElementById('color-input');
    normalizeHexInput(colorInput);
    normalizeHexInput(srcColorInput);
    normalizeHexInput(ignoreInput);

    // Custom tool selector dropdown
    const toolSelectorBtn = document.getElementById('toolSelectorBtn');
    const toolSelectorDropdown = document.getElementById('toolSelectorDropdown');
    const toolSelectorOptions = document.querySelectorAll('.tool-selector-option');

    const toolIcons = {
      rect: `<svg width="16" height="16" viewBox="0 0 408 408" xmlns="http://www.w3.org/2000/svg"><path d="M397.9,83c5.5,0,10-4.5,10.1-10V10.1C408,4.5,403.5,0,397.9,0H335c-5.5,0-10,4.5-10,10.1V32H83V10.1c0-5.5-4.5-10-10-10.1 H10.1C4.6,0,0.1,4.5,0,10.1V73c0,5.5,4.5,10,10.1,10H32v242H10.1c-5.5,0-10,4.5-10.1,10v62.9c0,5.5,4.5,10,10.1,10.1H73 c5.5,0,10-4.5,10-10.1V376h242v21.9c0,5.5,4.5,10,10,10.1h62.9c5.5,0,10-4.5,10.1-10.1V335c0-5.5-4.5-10-10.1-10H376V83H397.9z M20,63V20h43v43H20z M63,388H20v-43h43V388z M325,335v21H83v-21c0-5.5-4.5-10-10-10H52V83h21c5.5,0,10-4.5,10-10V52h242v21 c0,5.5,4.5,10,10,10h21v242h-21C329.5,325,325,329.5,325,335z M388,345v43h-43v-43H388z M345,63V20h43v43H345z" fill="currentColor"/></svg>`,
      pen: `<svg width="16" height="16" viewBox="0 0 511 511.99899" xmlns="http://www.w3.org/2000/svg"><path d="m499.226562 13.261719c-19.519531-19.527344-122.300781 51.597656-212.113281 141.410156-52.699219 52.695313-113.722656 124.609375-137.8125 165.597656l42.917969 42.917969c40.988281-24.089844 112.902344-85.113281 165.597656-137.8125 89.8125-89.8125 160.9375-192.59375 141.410156-212.113281zm0 0" fill="currentColor"/></svg>`,
      lasso: `<svg width="16" height="16" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M508.517,132.993c-10.806-40.332-45.494-71.333-97.674-87.291c-50.598-15.474-112.04-15.003-172.994,1.329 c-60.956,16.333-114.4,46.643-150.483,85.347c-37.211,39.91-51.75,84.101-40.942,124.433 c10.806,40.332,45.494,71.333,97.674,87.291c24.586,7.519,51.722,11.273,80.127,11.273c11.348,0,22.898-0.604,34.568-1.802 c-17.458,34.138-47.436,32.647-81.223,30.918c-33.163-1.688-70.762-3.611-90.449,35.762 c-11.362,22.726-24.247,35.438-38.295,37.785c-17.517,2.916-32.374-11.452-32.493-11.567c-3.733-3.735-9.797-3.735-13.53,0 c-3.737,3.737-3.737,9.794,0,13.532c0.79,0.79,17.865,17.57,41.215,17.568c2.511,0,5.097-0.194,7.741-0.624 c20.516-3.329,38.171-19.524,52.479-48.135c13.408-26.818,36.221-27.055,72.355-25.209c37.319,1.903,82.906,4.224,104.38-53.018 c12.002-1.988,24.071-4.584,36.119-7.812c60.956-16.333,114.4-46.643,150.483-85.347 C504.787,217.516,519.326,173.325,508.517,132.993z" fill="currentColor"/></svg>`,
      wand: `<svg width="16" height="16" viewBox="0 0 467.374 467.374" xmlns="http://www.w3.org/2000/svg"><path d="M459.657,82.222c0-5.136-1.704-9.419-5.133-12.843l-56.531-56.531c-3.425-3.427-7.706-5.14-12.847-5.14 c-5.144,0-9.421,1.713-12.847,5.14L5.14,380.005C1.709,383.434,0,387.719,0,392.858c0,5.141,1.709,9.418,5.14,12.847 l56.529,56.527c3.431,3.429,7.708,5.141,12.85,5.141c5.137,0,9.419-1.704,12.847-5.141l367.162-367.16 C457.953,91.642,459.657,87.364,459.657,82.222z M332.038,165.877l-30.546-30.55l83.651-83.654l30.546,30.549L332.038,165.877z" fill="currentColor"/><polygon points="65.384,73.087 73.948,45.109 101.925,36.545 73.948,27.979 65.384,0.001 56.818,27.979 28.84,36.545 56.818,45.109" fill="currentColor"/><polygon points="139.61,108.494 156.743,164.455 173.876,108.494 229.835,91.361 173.876,74.23 156.743,18.269 139.61,74.23 83.651,91.361" fill="currentColor"/></svg>`
    };

    if (toolSelectorBtn && toolSelectorDropdown) {
      toolSelectorBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toolSelectorDropdown.classList.toggle('open');
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.tool-selector')) {
          toolSelectorDropdown.classList.remove('open');
        }
      });

      toolSelectorOptions.forEach(option => {
        option.addEventListener('click', () => {
          const tool = option.dataset.tool;
          const areaToolEl = document.getElementById('areaTool');

          // Update hidden input
          if (areaToolEl) areaToolEl.value = tool;

          // Update button icon
          toolSelectorBtn.innerHTML = toolIcons[tool];

          // Update selected state
          toolSelectorOptions.forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');

          // Close dropdown
          toolSelectorDropdown.classList.remove('open');

          // Update tool
          finalizeOpenPath();
          selectionTool = tool;
          if (areaToggle) areaToggle.checked = true;
          updateActiveToolButtons();
        });
      });
    }

    if (areaToolEl) { selectionTool = areaToolEl.value || 'rect'; }
    if (areaUndoBtn) { areaUndoBtn.addEventListener('click', () => { if (openPath && openPath.points && openPath.points.length > 0) { openPath.points.pop(); drawSelectionOverlay(); } }); }

    // Delete last contour or cancel open path
    function deleteLastPathOrOpen() {
      if (openPath) { openPath = null; drawSelectionOverlay(); scheduleLivePreview(); }
      else if (shapes && shapes.length > 0) { shapes.pop(); drawSelectionOverlay(); scheduleLivePreview(); }
    }
    if (areaDeleteBtn) { areaDeleteBtn.addEventListener('click', deleteLastPathOrOpen); }
    if (typeof fsDeletePath !== 'undefined' && fsDeletePath && !fsDeletePath.__w) { fsDeletePath.__w = true; fsDeletePath.addEventListener('click', deleteLastPathOrOpen); }

    const fsClearSelection = document.getElementById('fsClearSelection');
    if (fsClearSelection && !fsClearSelection.__w) { fsClearSelection.__w = true; fsClearSelection.addEventListener('click', clearSelection); }

    function ensureSelectionCanvas() {
      if (!selectionCanvas) {
        selectionCanvas = document.createElement('canvas');
        selectionCanvas.className = 'result-overlay selection-overlay';
        selectionCanvas.width = Math.max(1, previewW || (imgEl ? imgEl.naturalWidth : 0));
        selectionCanvas.height = Math.max(1, previewH || (imgEl ? imgEl.naturalHeight : 0));
        selectionCanvas.style.pointerEvents = 'none';
        selectionCanvas.style.opacity = '1';
        preview.appendChild(selectionCanvas);
        // enable hit-testing for anchor dragging
        selectionCanvas.addEventListener('mousedown', onSelectionCanvasDown);
        // allow closing pen path via double-click on overlay too
        selectionCanvas.addEventListener('dblclick', (e) => {
          if (!areaToggle || !areaToggle.checked) return;
          if (!openPath || openPath.mode !== 'pen') return;
          if (openPath.points.length >= 3) {
            openPath.closed = true; shapes.push(openPath); openPath = null; drawSelectionOverlay(); scheduleLivePreview();
          }
          e.preventDefault(); e.stopPropagation();
        });
        applyZoom();
      }
    }
    // Coalesced selection overlay redraw
    function scheduleDrawSelectionOverlay() {
      if (selectionRafId) return;
      selectionRafId = requestAnimationFrame(() => {
        selectionRafId = null;
        drawSelectionOverlay();
      });
    }
    function drawSelectionOverlay() {
      if (!previewW || !previewH || !imgEl) return;
      ensureSelectionCanvas();
      const dpr = window.devicePixelRatio || 1;
      const needW = Math.max(1, Math.round(previewW * dpr));
      const needH = Math.max(1, Math.round(previewH * dpr));
      if (selectionCanvas.width !== needW) selectionCanvas.width = needW;
      if (selectionCanvas.height !== needH) selectionCanvas.height = needH;
      if (selectionCanvas.style.width !== (previewW + 'px')) selectionCanvas.style.width = previewW + 'px';
      if (selectionCanvas.style.height !== (previewH + 'px')) selectionCanvas.style.height = previewH + 'px';
      const ctx = selectionCanvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, previewW, previewH);
      // Rect now shown only by DOM overlay (selectionRectEl) to avoid visual duplication
      // draw paths
      const drawPath = (path, emphasizeLast) => {
        if (!path || !path.points || path.points.length < 1) return;
        ctx.lineWidth = 1; ctx.strokeStyle = '#3b82f6'; ctx.fillStyle = 'rgba(59,130,246,0.12)';
        ctx.beginPath();
        const p0 = path.points[0]; ctx.moveTo(p0.x, p0.y);
        for (let i = 1; i < path.points.length; i++) {
          const prev = path.points[i - 1]; const cur = path.points[i];
          if (prev.cp) { ctx.quadraticCurveTo(prev.cp.x, prev.cp.y, cur.x, cur.y); }
          else { ctx.lineTo(cur.x, cur.y); }
        }
        if (path.closed) {
          const last = path.points[path.points.length - 1];
          if (last.cp) { ctx.quadraticCurveTo(last.cp.x, last.cp.y, p0.x, p0.y); }
          ctx.closePath();
          ctx.fill();
        }
        ctx.stroke();
        // anchors
        ctx.fillStyle = '#1d4ed8';
        for (let i = 0; i < path.points.length; i++) {
          const a = path.points[i];
          ctx.beginPath(); ctx.arc(a.x, a.y, 2.5, 0, Math.PI * 2); ctx.fill();
          if (a.cp) {
            ctx.strokeStyle = '#1d4ed8'; ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(a.cp.x, a.cp.y); ctx.stroke();
            ctx.fillStyle = '#60a5fa'; ctx.beginPath(); ctx.arc(a.cp.x, a.cp.y, 2.0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#1d4ed8';
          }
        }
      };
      shapes.forEach(s => { if (s.type === 'path') drawPath(s, false); });
      shapes.forEach(s => { if (s.type === 'wand' && s.overlay) { ctx.drawImage(s.overlay, 0, 0, previewW, previewH); } });
      if (openPath) drawPath(openPath, true);
      // when there are editable points, make canvas interactive
      const hasEditable = (openPath && openPath.points && openPath.points.length) || (shapes && shapes.some(s => s.type === 'path'));
      toggleSelectionInteractive(!!hasEditable);
      applyZoom();
    }

    function toggleSelectionInteractive(on) {
      const enabled = !!on && (!!areaToggle && !!areaToggle.checked);
      selectionInteractive = enabled;
      if (!selectionCanvas) return;
      if (enabled) {
        selectionCanvas.classList.add('interactive');
        selectionCanvas.style.pointerEvents = 'auto';
      } else {
        selectionCanvas.classList.remove('interactive');
        selectionCanvas.style.pointerEvents = 'none';
      }
    }

    // ---- Dragging anchors/handles on selection canvas ----
    let draggingAnchor = null; // { path, index, kind:'anchor'|'cp' }
    function dist2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx * dx + dy * dy; }
    function pickNearestPoint(nx, ny) {
      const thr = Math.max(3, Math.round(6 / Math.max(0.1, zoom))); // ~6px –Ω–∞ —ç–∫—Ä–∞–Ω–µ, –≤ –Ω–∞—Ç.–ø–∏–∫—Å–µ–ª—è—Ö
      const thr2 = thr * thr;
      let best = null; let bestD = Infinity;
      const checkPath = (path) => {
        for (let i = 0; i < path.points.length; i++) {
          const p = path.points[i];
          const dA = dist2(nx, ny, p.x, p.y);
          if (dA < bestD && dA <= thr2) { bestD = dA; best = { path, index: i, kind: 'anchor' }; }
          if (p.cp) { const dC = dist2(nx, ny, p.cp.x, p.cp.y); if (dC < bestD && dC <= thr2) { bestD = dC; best = { path, index: i, kind: 'cp' }; } }
        }
      };
      if (openPath && openPath.points && openPath.points.length) checkPath(openPath);
      if (shapes && shapes.length) { shapes.forEach(s => { if (s.type === 'path') checkPath(s); }); }
      return best;
    }
    function onSelectionCanvasDown(e) {
      if (!areaToggle || !areaToggle.checked) return;
      e.preventDefault();
      e.stopPropagation();
      // compute nat coords
      const rect = preview.getBoundingClientRect();
      const imgRect = imgEl.getBoundingClientRect();
      const offX = imgRect.left - rect.left, offY = imgRect.top - rect.top;
      const scaleX = imgRect.width / previewW, scaleY = imgRect.height / previewH;
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      const natX = Math.max(0, Math.min(previewW - 1, Math.round((x - offX) / scaleX)));
      const natY = Math.max(0, Math.min(previewH - 1, Math.round((y - offY) / scaleY)));
      const tool = (areaToolEl && areaToolEl.value) || selectionTool;
      const hit = pickNearestPoint(natX, natY);
      // Close pen by clicking the first point
      if (tool === 'pen' && openPath && openPath.mode === 'pen' && hit && hit.kind === 'anchor' && hit.index === 0 && openPath.points.length >= 3) {
        openPath.closed = true; shapes.push(openPath); openPath = null; drawSelectionOverlay(); scheduleLivePreview(); return;
      }
      // Pen: by default ADD points; hold Shift to move existing anchors/handles
      if (tool === 'pen' && !e.shiftKey) {
        if (!openPath) openPath = { type: 'path', points: [], closed: false, mode: 'pen' };
        const pt = { x: natX, y: natY, cp: null };
        openPath.points.push(pt);
        const onMove = (ev) => {
          const rx = ev.clientX - rect.left, ry = ev.clientY - rect.top;
          const nx = Math.max(0, Math.min(previewW - 1, Math.round((rx - offX) / scaleX)));
          const ny = Math.max(0, Math.min(previewH - 1, Math.round((ry - offY) / scaleY)));
          pt.cp = { x: nx, y: ny }; scheduleDrawSelectionOverlay();
        };
        const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); };
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
        drawSelectionOverlay();
        return;
      }
      // Lasso: always allow starting a new contour on click, even over existing points
      if (tool === 'lasso' && !lassoActive) {
        openPath = { type: 'path', points: [{ x: natX, y: natY, cp: null }], closed: false, mode: 'lasso' };
        lassoActive = true; drawSelectionOverlay(); return;
      }
      if (!hit) {
        // no hit: allow adding points on canvas for pen
        if (tool === 'pen') {
          if (!openPath) openPath = { type: 'path', points: [], closed: false, mode: 'pen' };
          const pt = { x: natX, y: natY, cp: null };
          openPath.points.push(pt);
          // start handle drag immediately
          const onMove = (ev) => {
            const rx = ev.clientX - rect.left, ry = ev.clientY - rect.top;
            const nx = Math.max(0, Math.min(previewW - 1, Math.round((rx - offX) / scaleX)));
            const ny = Math.max(0, Math.min(previewH - 1, Math.round((ry - offY) / scaleY)));
            pt.cp = { x: nx, y: ny }; scheduleDrawSelectionOverlay();
          };
          const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); };
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
          drawSelectionOverlay();
          return;
        }
        return;
      }
      // Force-add a point with Ctrl+Click even if near existing point
      if (tool === 'pen' && e.ctrlKey) {
        if (!openPath) openPath = { type: 'path', points: [], closed: false, mode: 'pen' };
        openPath.points.push({ x: natX, y: natY, cp: null });
        drawSelectionOverlay();
        return;
      }
      e.preventDefault();
      draggingAnchor = hit;
      const onMove = (ev) => {
        const rx = ev.clientX - rect.left, ry = ev.clientY - rect.top;
        const nx = Math.max(0, Math.min(previewW - 1, Math.round((rx - offX) / scaleX)));
        const ny = Math.max(0, Math.min(previewH - 1, Math.round((ry - offY) / scaleY)));
        if (draggingAnchor) {
          const p = draggingAnchor.path.points[draggingAnchor.index];
          if (draggingAnchor.kind === 'anchor') { p.x = nx; p.y = ny; }
          else { p.cp = { x: nx, y: ny }; }
          scheduleDrawSelectionOverlay();
          scheduleLivePreview();
        }
      };
      const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); draggingAnchor = null; };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    }

    function renderSelectionRect() {
      if (!selectionNat) { if (selectionRectEl) { selectionRectEl.style.display = 'none'; } return; }
      ensureSelectionRect();
      const rect = preview.getBoundingClientRect();
      if (!imgEl || !previewW || !previewH) { selectionRectEl.style.display = 'none'; return; }
      const imgRect = imgEl.getBoundingClientRect();
      const scaleX = imgRect.width / previewW;
      const scaleY = imgRect.height / previewH;
      const offX = imgRect.left - rect.left;
      const offY = imgRect.top - rect.top;
      const left = offX + selectionNat.x * scaleX;
      const top = offY + selectionNat.y * scaleY;
      const width = Math.max(0, selectionNat.w) * scaleX;
      const height = Math.max(0, selectionNat.h) * scaleY;

      selectionRectEl.style.display = 'block';
      selectionRectEl.style.left = left + 'px';
      selectionRectEl.style.top = top + 'px';
      selectionRectEl.style.width = width + 'px';
      selectionRectEl.style.height = height + 'px';
      scheduleDrawSelectionOverlay();
    }

    window.onmessage = async (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      if (msg.type === 'get-language-response') {
        console.log('Received language from Figma storage:', msg.language);
        if (msg.language && translations[msg.language]) {
          if (msg.language !== state.language) {
            state.language = msg.language;
            console.log('Updated language from Figma storage to:', state.language);
            try {
              apply();
            } catch (e) {
              console.log('Error applying language from Figma storage:', e);
            }
          } else {
            console.log('Language from Figma storage matches current language:', msg.language);
          }
        } else {
          console.log('Invalid or unsupported language from Figma storage:', msg.language);
        }
        return;
      }

      if (msg.type === 'license-info-response') {
        licenseInfo = {
          usageCount: msg.usageCount || 0,
          isPro: msg.isPro || false,
          remainingUses: msg.remainingUses || 0,
          keyInfo: msg.keyInfo || null,
          expiryWarning: msg.expiryWarning || false,
          daysUntilExpiry: msg.daysUntilExpiry || 0
        };
        console.log('License info received:', licenseInfo);
        updateLicenseUI();
        return;
      }

      if (msg.type === 'usage-updated') {
        licenseInfo.usageCount = msg.usageCount;
        licenseInfo.remainingUses = msg.remainingUses;
        console.log('Usage updated:', licenseInfo);
        updateLicenseUI();
        return;
      }

      if (msg.type === 'usage-limit-reached') {
        console.log('Usage limit reached, showing modal');
        showLicenseModal();
        return;
      }

      if (msg.type === 'pro-activation-response') {
        if (msg.success) {
          licenseInfo.isPro = true;
          licenseInfo.remainingUses = -1;
          updateLicenseUI();
          hideLicenseModal();
          console.log('Pro version activated successfully');
        }
        return;
      }



      if (msg.type === 'key-activation-response') {
        const activationError = document.getElementById('activationError');
        const activationSuccess = document.getElementById('activationSuccess');
        const activationInfo = document.getElementById('activationInfo');
        const activationKey = document.getElementById('activationKey');
        const pack = translations[state.language] || translations.en;

        resetActivationButton();

        if (msg.success) {
          if (msg.action === 'reset') {
            // Reset action - show info message
            licenseInfo.isPro = false;
            licenseInfo.remainingUses = 5;
            licenseInfo.usageCount = 0;
            licenseInfo.keyInfo = null;

            updateLicenseUI();

            if (activationKey) activationKey.value = '';

            showActivationMessage(activationInfo, pack.subscription_reset || 'Subscription has been reset successfully!');

            // Close modal after 2 seconds
            setTimeout(() => {
              hideLicenseModal();
            }, 2000);
          } else {
            // Activation success - update license info and close modal
            licenseInfo.isPro = true;
            licenseInfo.remainingUses = -1; // Unlimited
            licenseInfo.keyInfo = msg.keyInfo || null;

            updateLicenseUI();

            if (activationKey) activationKey.value = '';

            let successMsg = pack.activation_success || 'Pro version activated successfully!';
            if (msg.keyInfo) {
              successMsg += ` (${msg.keyInfo.subscriptionType})`;
            }

            showActivationMessage(activationSuccess, successMsg);

            // Close modal after 2 seconds
            setTimeout(() => {
              hideLicenseModal();
            }, 2000);
          }
        } else {
          // Error - show detailed error message
          let errorMsg = pack.activation_error || 'Invalid activation key. Please try again.';

          // Provide more specific error messages
          if (msg.error === 'format') {
            errorMsg = pack.activation_error_format || 'Invalid key format. Key should start with CT-';
          } else if (msg.error === 'expired') {
            errorMsg = pack.activation_error_expired || 'This activation key has expired.';
          } else if (msg.error === 'user_mismatch') {
            errorMsg = pack.activation_error_user || 'This key belongs to a different user.';
          } else if (msg.error === 'device_mismatch') {
            errorMsg = pack.activation_error_device || 'This key is bound to a different device.';
          } else if (msg.error === 'parse') {
            errorMsg = pack.activation_error_parse || 'Unable to read activation key. Please check the key.';
          } else if (msg.error === 'validation') {
            errorMsg = pack.activation_error_validation || 'Key validation failed. Please contact support.';
          } else if (msg.error === 'network') {
            errorMsg = pack.activation_error_network || 'Network error. Please try again later.';
          } else if (msg.message) {
            errorMsg = msg.message;
          }

          showActivationMessage(activationError, errorMsg);
        }
        return;
      }

      if (msg.type === 'challenge-response') {
        // Open Telegram bot with challenge
        console.log('üì® Received challenge-response:', msg);
        if (msg.botUrl) {
          console.log('üîó Opening Telegram bot with URL:', msg.botUrl);
          console.log('üîë Challenge ID:', msg.challenge);

          // Try to open the URL
          const opened = window.open(msg.botUrl, '_blank');
          if (opened) {
            console.log('‚úÖ URL opened successfully');
          } else {
            console.log('‚ùå Failed to open URL - popup blocked?');
          }
        } else {
          console.log('‚ùå No botUrl in response');
        }
        return;
      }

      if (msg.type === 'challenge-error') {
        // Show error message for challenge generation
        const pack = translations[state.language] || translations.en;
        const errorMsg = msg.message || (pack.challenge_error || 'Failed to generate challenge. Please try again.');

        // Show error in a simple alert for now
        alert(errorMsg);
        return;
      }
      if (msg.type === 'set-preview') {
        try { paintInfo = msg.paintInfo || null; } catch (_) { paintInfo = null; }
        createBtn.disabled = false;
        const zoomMini = document.getElementById('zoomMini');
        preview.innerHTML = '';
        overlayCanvas = null;
        selectionCanvas = null;
        marker = null;
        selectionRectEl = null;
        previewSizer = null;
        const img = document.createElement('img');
        // –ï—Å–ª–∏ –ø—Ä–∏—à–ª–∏ –±–∞–π—Ç—ã ‚Äî —Å–æ–∑–¥–∞—ë–º Blob –∏ objectURL
        if (msg.bytes) {
          const bytes = new Uint8Array(msg.bytes);
          const blob = new Blob([bytes], { type: 'image/png' });
          const url = URL.createObjectURL(blob);
          img.src = url;
          lastPreviewBytes = bytes;
        } else if (msg.dataUrl) {
          img.src = msg.dataUrl;
        }
        // –í—Å–µ–≥–¥–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –æ–∂–∏–¥–∞–µ–º—ã–µ —Ä–∞–∑–º–µ—Ä—ã –ø—Ä–µ–≤—å—é, –µ—Å–ª–∏ –æ–Ω–∏ –ø–µ—Ä–µ–¥–∞–Ω—ã
        if (typeof msg.width === 'number' && msg.width > 0) previewW = msg.width;
        if (typeof msg.height === 'number' && msg.height > 0) previewH = msg.height;
        imgEl = img;
        // Fallback: if dimensions are missing, set from natural size on load
        img.onload = () => {
          if (!previewW || !previewH) {
            previewW = img.naturalWidth || img.width || previewW || 0;
            previewH = img.naturalHeight || img.height || previewH || 0;
          }
          applyZoom();
          try { ensureOverlay(); drawSelectionOverlay(); scheduleLivePreview(); } catch (_) { }
        };
        preview.appendChild(img);
        if (zoomMini) preview.appendChild(zoomMini);
        applyZoom();
      } else if (msg.type === 'no-preview') {
        createBtn.disabled = true;
        const zoomMini = document.getElementById('zoomMini');
        preview.textContent = t('preview_placeholder');
        if (zoomMini) preview.appendChild(zoomMini);
        marker = null;
        selectedCoords = null;
        lastPreviewBytes = null;
        lastFillBytes = null;
        imgEl = null;
        pendingAction = null;
      } else if (msg.type === 'provide-bytes') {
        console.log('Received provide-bytes:', { source: msg.source, bytesLength: msg.bytes?.length, paintInfo: msg.paintInfo });
        // –û—Ç–≤–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å –±–∞–π—Ç–æ–≤ ‚Äî –æ–±–Ω–æ–≤–∏–º paintInfo (–µ—Å–ª–∏ –ø—Ä–∏—à—ë–ª), —Å–æ—Ö—Ä–∞–Ω–∏–º –±–∞–π—Ç—ã –∏ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∑–∞–ø—É—Å—Ç–∏–º –æ–±—Ä–∞–±–æ—Ç–∫—É
        if (typeof msg.paintInfo !== 'undefined') { try { paintInfo = msg.paintInfo; } catch (_) { } }
        const bytes = new Uint8Array(msg.bytes);
        if (msg.source === 'fill') {
          lastFillBytes = bytes;
          console.log('Saved lastFillBytes, length:', lastFillBytes.length);
          // —Ä–∞–∑–º–µ—Ä—ã –≤—ã—á–∏—Å–ª–∏–º –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤ canvas
        } else if (msg.source === 'export') {
          // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–∞–π—Ç—ã - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö –∫–∞–∫ fill –±–∞–π—Ç—ã –Ω–æ —Å —Ä–∞–∑–º–µ—Ä–∞–º–∏ –ø—Ä–µ–≤—å—é
          lastFillBytes = bytes;
          fillW = previewW;
          fillH = previewH;
          console.log('Saved export bytes as fill, size:', fillW, 'x', fillH);
        } else {
          lastPreviewBytes = bytes;
          previewW = msg.width || 0;
          previewH = msg.height || 0;
        }
        if (pendingAction) {
          console.log('Processing pending action:', pendingAction);
          await processAndSend(pendingAction.color, pendingAction.mode);
          pendingAction = null;
        }
      }
    };

    preview.addEventListener('click', (e) => {
      if (typeof suppressClickOnce !== 'undefined' && suppressClickOnce) { suppressClickOnce = false; return; }
      const rect = preview.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–µ –ø–∏–∫—Å–µ–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      let natX = Math.round(clickX), natY = Math.round(clickY);
      if (imgEl && previewW && previewH) {
        const imgRect = imgEl.getBoundingClientRect();
        const offX = imgRect.left - rect.left + preview.scrollLeft;
        const offY = imgRect.top - rect.top + preview.scrollTop;
        const relX = (clickX + preview.scrollLeft - offX);
        const relY = (clickY + preview.scrollTop - offY);
        // object-fit: contain –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π scale –¥–ª—è –æ–±–µ–∏—Ö –æ—Å–µ–π
        const scale = imgRect.width / previewW;

        natX = Math.round(relX / scale);
        natY = Math.round(relY / scale);
        natX = Math.max(0, Math.min(previewW - 1, natX));
        natY = Math.max(0, Math.min(previewH - 1, natY));
      }
      if (pipetteMode) {
        samplePreviewPixel(natX, natY).then(rgb => {
          const hx = rgbToHex(rgb.r, rgb.g, rgb.b);
          if (pipetteMode === 'target') {
            document.getElementById('color-input').value = hx;
            pickedSwatch.style.background = hx;
            pickedHex.textContent = hx;
            // –ü—Ä–∏ –≤—ã–±–æ—Ä–µ —Ü–µ–ª–µ–≤–æ–≥–æ —Ü–≤–µ—Ç–∞ —Ç–∞–∫–∂–µ —Ñ–∏–∫—Å–∏—Ä—É–µ–º —Ç–æ—á–∫—É –¥–ª—è —Å—ç–º–ø–ª–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –≤ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–µ
            selectedCoords = { x: natX, y: natY };
            if (!marker) {
              marker = document.createElement('div');
              marker.className = 'marker';
              marker.style.background = '#ff0000';
              marker.style.border = '2px solid #fff';
              marker.style.boxShadow = '0 0 0 1px rgba(0,0,0,0.3)';
              preview.appendChild(marker);
            }
            marker.style.left = x + 'px';
            marker.style.top = y + 'px';
            marker.title = `Target: ${hx} at (${natX},${natY})`;
          } else if (pipetteMode === 'source') {
            srcColorInput.value = hx;
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–∫–∂–µ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–µ –ø–æ–ª–µ
            const fsSrcColorInput = document.getElementById('fsSrcColorInput');
            if (fsSrcColorInput) fsSrcColorInput.value = hx;
            // –ó–∞–æ–¥–Ω–æ –ø–æ—Å—Ç–∞–≤–∏–º –º–∞—Ä–∫–µ—Ä —Ç–æ—á–∫–∏-–æ–±—Ä–∞–∑—Ü–∞, —á—Ç–æ–±—ã –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–ª—Å—è –Ω–∞ –Ω–µ—ë –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ src HEX
            selectedCoords = { x: natX, y: natY };
            if (!marker) {
              marker = document.createElement('div');
              marker.className = 'marker';
              marker.style.background = '#00ff00';
              marker.style.border = '2px solid #fff';
              marker.style.boxShadow = '0 0 0 1px rgba(0,0,0,0.3)';
              preview.appendChild(marker);
            }
            marker.style.left = x + 'px';
            marker.style.top = y + 'px';
            marker.title = `Source: ${hx} at (${natX},${natY})`;
          } else if (pipetteMode === 'ignore') {
            addIgnore(hx);
          }
          pipetteMode = null;
          updatePipetteButtons();
          scheduleLivePreview();
        }).catch(() => { });
        return;
      }

      selectedCoords = { x: natX, y: natY };

      if (!marker) {
        marker = document.createElement('div');
        marker.className = 'marker';
        preview.appendChild(marker);
      }
      marker.style.left = x + 'px';
      marker.style.top = y + 'px';
      scheduleLivePreview();
    });

    // ---- Selection drag (LMB when areaToggle is checked) ----
    preview.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      if (!areaToggle || !areaToggle.checked) return;
      if (spaceHeld || pipetteMode) return;
      if (!imgEl || !previewW || !previewH) return;
      // if clicking on existing anchor/handle, let selectionCanvas handler take it
      if (selectionInteractive) return;
      const rect = preview.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const imgRect = imgEl.getBoundingClientRect();
      const offX = imgRect.left - rect.left + preview.scrollLeft;
      const offY = imgRect.top - rect.top + preview.scrollTop;
      const x = clickX + preview.scrollLeft;
      const y = clickY + preview.scrollTop;
      const scale = imgRect.width / previewW;
      const natX = Math.max(0, Math.min(previewW - 1, Math.round((x - offX) / scale)));
      const natY = Math.max(0, Math.min(previewH - 1, Math.round((y - offY) / scale)));
      if ((areaToolEl && areaToolEl.value === 'rect') || selectionTool === 'rect') {
        selectionStartDom = { x, y };
        selectionStartNat = { x: natX, y: natY };
        selectionDragging = true; suppressClickOnce = true;
        ensureSelectionRect();
        selectionNat = { x: natX, y: natY, w: 0, h: 0 };
        renderSelectionRect();
      } else if ((areaToolEl && areaToolEl.value === 'lasso') || selectionTool === 'lasso') {
        openPath = { type: 'path', points: [{ x: natX, y: natY, cp: null }], closed: false, mode: 'lasso' };
        lassoActive = true;
        drawSelectionOverlay();
      } else if ((areaToolEl && areaToolEl.value === 'wand') || selectionTool === 'wand') {
        // Use wand seed as source sample for preview/recolor if none specified
        selectedCoords = { x: natX, y: natY };
        if (!marker) { marker = document.createElement('div'); marker.className = 'marker'; preview.appendChild(marker); }
        marker.style.left = x + 'px';
        marker.style.top = y + 'px';
        suppressClickOnce = true;
        computeWandSelection(natX, natY, true).then(shape => {
          if (shape) { shapes.push(shape); drawSelectionOverlay(); scheduleLivePreview(); }
        }).catch(() => { });
      } else if ((areaToolEl && areaToolEl.value === 'pen') || selectionTool === 'pen') {
        if (!openPath) openPath = { type: 'path', points: [], closed: false, mode: 'pen' };
        const pt = { x: natX, y: natY, cp: null };
        openPath.points.push(pt);
        // start handle drag for this anchor
        let penMove;
        const onMove = (ev) => {
          const clickX2 = ev.clientX - rect.left;
          const clickY2 = ev.clientY - rect.top;
          const rx = clickX2 + preview.scrollLeft;
          const ry = clickY2 + preview.scrollTop;
          const natX2 = Math.max(0, Math.min(previewW - 1, Math.round((rx - offX) / scale)));
          const natY2 = Math.max(0, Math.min(previewH - 1, Math.round((ry - offY) / scale)));
          pt.cp = { x: natX2, y: natY2 };
          scheduleDrawSelectionOverlay();
        };
        const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); };
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
        drawSelectionOverlay();
      }
    });
    document.addEventListener('mousemove', (e) => {
      if (!selectionDragging && !lassoActive) return;
      const rect = preview.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const imgRect = imgEl.getBoundingClientRect();
      const offX = imgRect.left - rect.left + preview.scrollLeft;
      const offY = imgRect.top - rect.top + preview.scrollTop;
      const x = clickX + preview.scrollLeft;
      const y = clickY + preview.scrollTop;
      const scale = imgRect.width / previewW;
      const natX = Math.max(0, Math.min(previewW - 1, Math.round((x - offX) / scale)));
      const natY = Math.max(0, Math.min(previewH - 1, Math.round((y - offY) / scale)));
      if (selectionDragging) {
        const x0 = Math.min(selectionStartNat.x, natX); const y0 = Math.min(selectionStartNat.y, natY);
        const x1 = Math.max(selectionStartNat.x, natX); const y1 = Math.max(selectionStartNat.y, natY);
        selectionNat = { x: x0, y: y0, w: x1 - x0 + 1, h: y1 - y0 + 1 };
        renderSelectionRect();
      } else if (lassoActive && openPath) {
        const last = openPath.points[openPath.points.length - 1];
        if (!last || Math.hypot(last.x - natX, last.y - natY) >= 1) { openPath.points.push({ x: natX, y: natY, cp: null }); }
        scheduleDrawSelectionOverlay();
      }
    });
    document.addEventListener('mouseup', () => {
      if (selectionDragging) {
        selectionDragging = false;
        renderSelectionRect();
        scheduleLivePreview();
      }
      if (lassoActive && openPath) {
        lassoActive = false; openPath.closed = true; shapes.push(openPath); openPath = null; drawSelectionOverlay(); scheduleLivePreview();
      }
    });

    // Close pen path on double click or when clicking near first point
    preview.addEventListener('dblclick', (e) => {
      if (!areaToggle || !areaToggle.checked) return;
      if (!openPath || openPath.mode !== 'pen') return;
      if (openPath.points.length >= 3) { openPath.closed = true; shapes.push(openPath); openPath = null; drawSelectionOverlay(); scheduleLivePreview(); }
    });
    window.addEventListener('keydown', (e) => {
      if (!areaToggle || !areaToggle.checked) return;
      if (e.key === 'Escape') { openPath = null; drawSelectionOverlay(); }
      else if (e.key === 'Backspace') { if (openPath && openPath.points && openPath.points.length > 0) { openPath.points.pop(); drawSelectionOverlay(); e.preventDefault(); } }
      else if (e.key === 'Enter') { if (openPath && openPath.points && openPath.points.length >= 3) { openPath.closed = true; shapes.push(openPath); openPath = null; drawSelectionOverlay(); scheduleLivePreview(); } }
      else if ((e.ctrlKey || e.metaKey) && (e.code === 'KeyZ')) { // Ctrl+Z/Cmd+Z ‚Äî undo –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏ –≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –∫–æ–Ω—Ç—É—Ä–µ
        if (openPath && openPath.points && openPath.points.length > 0) {
          openPath.points.pop();
          if (openPath.points.length === 0) { openPath = null; }
          drawSelectionOverlay();
          scheduleLivePreview();
        } else if (shapes && shapes.length > 0) {
          // –Ω–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ –ø—É—Ç–∏ ‚Äî —É–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –∑–∞–º–∫–Ω—É—Ç—ã–π –∫–æ–Ω—Ç—É—Ä (–∫–∞–∫ Delete)
          shapes.pop();
          drawSelectionOverlay();
          scheduleLivePreview();
        }
        e.preventDefault();
      }
      else if (e.key === 'Delete') {
        if (openPath) { openPath = null; drawSelectionOverlay(); scheduleLivePreview(); e.preventDefault(); }
        else if (shapes && shapes.length > 0) { shapes.pop(); drawSelectionOverlay(); scheduleLivePreview(); e.preventDefault(); }
      } else if ((e.key === 'Backspace' || e.key === 'Delete') && e.ctrlKey) {
        // Ctrl+Backspace or Ctrl+Delete ‚Äî –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –∫–æ–Ω—Ç—É—Ä—ã –∏ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
        clearSelection(); e.preventDefault();
      }
    });

    document.getElementById('create-btn').addEventListener('click', async () => {
      // Check license before processing
      if (!licenseInfo.isPro && licenseInfo.remainingUses <= 0) {
        showLicenseModal();
        return;
      }

      const color = document.getElementById('color-input').value;
      const mode = document.querySelector('input[name="apply-mode"]:checked').value;
      const srcHex = (srcColorInput.value || '').trim();
      console.log('CREATE clicked:', { color, mode, srcHex, selectedCoords, lastFillBytes: !!lastFillBytes, lastPreviewBytes: !!lastPreviewBytes });
      if (!selectedCoords && !/^#([0-9A-Fa-f]{6})$/.test(srcHex)) { alert(t('alert_pick_point_or_hex')); return; }
      if (!/^#([0-9A-Fa-f]{6})$/.test(color)) {
        alert(t('alert_enter_hex'));
        return;
      }
      // –í—Å–µ–≥–¥–∞ —Ä–∞–±–æ—Ç–∞–µ–º —Å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–º–∏ –±–∞–π—Ç–∞–º–∏ –∏–∑ IMAGE-fill, —á—Ç–æ–±—ã –∏—Å–∫–ª—é—á–∏—Ç—å —Ä–∞—Å—Ç—è–≥–∏–≤–∞–Ω–∏–µ –∏ –¥–µ–≥—Ä–∞–¥–∞—Ü–∏—é
      if (!lastFillBytes) {
        console.log('Requesting original bytes from fill...');
        pendingAction = { color, mode };
        parent.postMessage({ pluginMessage: { type: 'request-bytes' } }, '*');
        return;
      }

      console.log('Processing with existing lastFillBytes');
      await processAndSend(color, mode);
    });

    async function processAndSend(color, mode) {
      console.log('processAndSend START:', { color, mode, hasLastFillBytes: !!lastFillBytes, hasLastPreviewBytes: !!lastPreviewBytes });
      try {
        const target = hexToRgb(color);
        console.log('1. Target RGB:', target);
        // 1) –°—ç–º–ø–ª–∏–º —Ü–≤–µ—Ç –∏–∑ –ø—Ä–µ–≤—å—é –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Å–¥–≤–∏–≥–æ–≤
        let sHSL;
        const srcHex = (srcColorInput.value || '').trim();
        console.log('2. Source hex:', srcHex, 'selectedCoords:', selectedCoords);
        if (/^#([0-9A-Fa-f]{6})$/.test(srcHex)) {
          const sRGB = hexToRgb(srcHex);
          sHSL = rgbToHsl(sRGB.r, sRGB.g, sRGB.b);
          console.log('3a. Using source from HEX:', sHSL);
        } else {
          console.log('3b. Sampling from preview');
          const blobPrev = new Blob([lastPreviewBytes], { type: 'image/png' });
          const urlPrev = URL.createObjectURL(blobPrev);
          const imgPrev = await loadImage(urlPrev);
          console.log('3c. Preview image loaded');
          const canvasPrev = document.createElement('canvas');
          canvasPrev.width = previewW; canvasPrev.height = previewH;
          const ctxPrev = canvasPrev.getContext('2d');
          ctxPrev.drawImage(imgPrev, 0, 0, previewW, previewH);
          const dataPrev = ctxPrev.getImageData(0, 0, previewW, previewH);
          const idxPrev = (selectedCoords.y * previewW + selectedCoords.x) * 4;
          const src = { r: dataPrev.data[idxPrev], g: dataPrev.data[idxPrev + 1], b: dataPrev.data[idxPrev + 2] };
          sHSL = rgbToHsl(src.r, src.g, src.b);
          console.log('3d. Sampled source:', src, 'HSL:', sHSL);
        }
        const tHSL = rgbToHsl(target.r, target.g, target.b);
        let dHue = tHSL.h - sHSL.h; if (dHue > 180) dHue -= 360; if (dHue < -180) dHue += 360;
        const sRatio = sHSL.s < 1e-4 ? 1 : (tHSL.s / Math.max(1e-4, sHSL.s));
        const lRatio = sHSL.l < 1e-4 ? (tHSL.l / Math.max(1e-4, sHSL.l)) : (tHSL.l / Math.max(1e-4, sHSL.l));
        // –ü–æ—Ä–æ–≥–æ–≤–∞—è –º–∞—Å–∫–∞ ¬´—Ç–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç¬ª
        const hTol = Math.max(0, Math.min(60, parseInt(hueTol.value, 10)));
        const sTol = Math.max(0, Math.min(1, Number(satTol.value) / 100));
        const lTol = Math.max(0, Math.min(1, Number(lightTol.value) / 100));
        const k = Math.max(0, Math.min(1, Number(intensity.value) / 100));
        const dsOff = tHSL.s - sHSL.s;
        const dlOff = tHSL.l - sHSL.l;

        // 2) –†–µ–∫–æ–ª–æ—Ä –∏—Å—Ö–æ–¥–Ω–æ–≥–æ IMAGE-fill (–µ—Å–ª–∏ –µ—Å—Ç—å), –∏–Ω–∞—á–µ –ø—Ä–µ–≤—å—é
        const bytesForProcess = lastFillBytes || lastPreviewBytes; // –æ–∂–∏–¥–∞–µ–º lastFillBytes –∫ —ç—Ç–æ–º—É –º–æ–º–µ–Ω—Ç—É
        const usingFillBytes = !!lastFillBytes;

        const blob = new Blob([bytesForProcess], { type: 'image/png' });
        const url = URL.createObjectURL(blob);
        const img = await loadImage(url);
        const canvas = document.createElement('canvas');
        let iw = img.naturalWidth || img.width;
        let ih = img.naturalHeight || img.height;

        // –î–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–∑–º–µ—Ä—ã –ø—Ä–µ–≤—å—é
        if (fillW === previewW && fillH === previewH) {
          iw = previewW;
          ih = previewH;
          console.log('Using preview dimensions for exported image:', { w: iw, h: ih });
        }

        canvas.width = iw; canvas.height = ih;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false; // –±–µ–∑ —Ä–µ—Å—ç–º–ø–ª–∏–Ω–≥–∞

        // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–¥ —Ä–∞–∑–º–µ—Ä—ã –∫–∞–Ω–≤–∞—Å–∞
        ctx.drawImage(img, 0, 0, iw, ih);
        const data = ctx.getImageData(0, 0, canvas.width, canvas.height);

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –∫ –∫–∞–∂–¥–æ–º—É –ø–∏–∫—Å–µ–ª—é
        const arr = data.data;
        // –ü—Ä–æ—Å—Ç–æ–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
        let selB = null;
        console.log('9. Checking selection:', {
          areaToggleChecked: areaToggle?.checked,
          hasSelectionNat: !!selectionNat,
          selectionNat: selectionNat,
          hasShapes: shapes?.length > 0,
          previewSize: { w: previewW, h: previewH },
          originalSize: { w: iw, h: ih },
          paintInfo: paintInfo
        });

        if (areaToggle && areaToggle.checked && selectionNat && selectionNat.w > 0 && selectionNat.h > 0) {
          // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—ã–¥–µ–ª–µ–Ω–∏—è –∏–∑ –ø—Ä–µ–≤—å—é –≤ —Ä–∞–∑–º–µ—Ä—ã –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
          const scaleX = iw / Math.max(1, previewW);
          const scaleY = ih / Math.max(1, previewH);
          const x0 = Math.max(0, Math.round(selectionNat.x * scaleX));
          const y0 = Math.max(0, Math.round(selectionNat.y * scaleY));
          const x1 = Math.min(iw, Math.round((selectionNat.x + selectionNat.w) * scaleX));
          const y1 = Math.min(ih, Math.round((selectionNat.y + selectionNat.h) * scaleY));
          selB = { x0, y0, x1, y1 };

          console.log('DEBUG Selection mapping:', {
            preview: { w: previewW, h: previewH },
            original: { w: iw, h: ih },
            scale: { x: scaleX, y: scaleY },
            selectionNat,
            selB,
            paintInfo
          });
        }
        console.log('10. About to build mask');
        const maskA = buildMaskAlpha(iw, ih);
        console.log('11. Mask built, starting pixel processing');
        let processedCount = 0;
        let checkedCount = 0;
        let skippedBySelection = 0;
        let skippedByMask = 0;
        let failedTolerance = 0;
        let ignoredCount = 0;
        for (let i = 0; i < arr.length; i += 4) {
          checkedCount++;
          // –ü—Ä–æ—Å—Ç–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –∏–º–µ–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–∞–¥ —Å–ª–æ–∂–Ω–æ–π –º–∞—Å–∫–æ–π
          if (selB) {
            const p = (i >> 2);
            const y = Math.floor(p / iw);
            const x = p - y * iw;
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–∏–∫—Å–µ–ª—å –≤–Ω–µ –æ–±–ª–∞—Å—Ç–∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è
            if (x < selB.x0 || x >= selB.x1 || y < selB.y0 || y >= selB.y1) {
              skippedBySelection++;
              continue;
            }
          }
          else if (maskA) {
            if (maskA[i + 3] === 0) {
              skippedByMask++;
              continue;
            }
          }
          const r = arr[i], g = arr[i + 1], b = arr[i + 2];
          const hsl = rgbToHsl(r, g, b);
          let dh = Math.abs(hsl.h - sHSL.h); if (dh > 180) dh = 360 - dh;
          const ds = Math.abs(hsl.s - sHSL.s);
          const dl = Math.abs(hsl.l - sHSL.l);

          // –õ–æ–≥–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–µ 3 –ø–∏–∫—Å–µ–ª—è –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞
          if (processedCount === 0 && checkedCount <= 100 && checkedCount % 10 === 0) {
            console.log(`Sample pixel ${checkedCount}:`, { rgb: { r, g, b }, hsl, diffs: { dh, ds, dl }, tolerances: { hTol, sTol, lTol }, passes: { h: dh <= hTol, s: ds <= sTol, l: dl <= lTol } });
          }

          if (isIgnored(hsl, hTol, sTol, lTol)) {
            ignoredCount++;
            continue;
          }

          if (!(dh <= hTol && ds <= sTol && dl <= lTol)) {
            failedTolerance++;
            continue;
          }

          // –ü–∏–∫—Å–µ–ª—å –ø–æ–¥—Ö–æ–¥–∏—Ç - –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
          processedCount++;
          // —Ç–æ—á–µ—á–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è: —Å–º–µ—â–µ–Ω–∏–µ –æ—Ç—Ç–µ–Ω–∫–∞ + –æ—Ñ—Ñ—Å–µ—Ç—ã S/L (—Å–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–ª—å–µ—Ñ)
          let h = hsl.h + dHue; if (h < 0) h += 360; if (h >= 360) h -= 360;
          let s = clamp01(hsl.s + dsOff);
          let l = clamp01(hsl.l + dlOff);
          // —Å–º–µ—à–∏–≤–∞–Ω–∏–µ –ø–æ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
          h = lerpAngle(hsl.h, h, k);
          s = lerp(hsl.s, s, k);
          l = lerp(hsl.l, l, k);
          const rgb = hslToRgb(h, s, l);
          arr[i] = rgb.r; arr[i + 1] = rgb.g; arr[i + 2] = rgb.b; // alpha —Å–æ—Ö—Ä–∞–Ω—è–µ–º
        }
        console.log('12. Processed', processedCount, 'of', checkedCount, 'pixels. Skipped:', { bySelection: skippedBySelection, byMask: skippedByMask, byTolerance: failedTolerance, ignored: ignoredCount });
        ctx.putImageData(data, 0, 0);

        console.log('13. Converting to PNG bytes...');
        const newBytes = await canvasToPngBytes(canvas);
        const b64 = bytesToBase64(newBytes);
        console.log('14. Sending to Figma, b64 length:', b64.length);
        parent.postMessage({ pluginMessage: { type: 'replace-image-b64', b64, mode } }, '*');
        console.log('15. Done!');
      } catch (e) {
        console.error('ERROR in processAndSend:', e, e.stack);
        alert(t('alert_processing_error'));
      }
    }

    // ---------- Utils (UI) ----------
    function hexToRgb(hex) {
      const v = parseInt(hex.slice(1), 16); return { r: (v >> 16) & 255, g: (v >> 8) & 255, b: v & 255 };
    }
    function loadImage(url) {
      return new Promise((res, rej) => { const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = url; });
    }
    function clamp01(v) { return Math.max(0, Math.min(1, v)); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpAngle(a, b, t) {
      let d = b - a; if (d > 180) d -= 360; else if (d < -180) d += 360;
      let res = a + d * t; if (res < 0) res += 360; else if (res >= 360) res -= 360; return res;
    }
    function rgbToHex(r, g, b) {
      const to2 = (n) => n.toString(16).padStart(2, '0');
      return '#' + to2(r) + to2(g) + to2(b);
    }
    function hsvToRgb(h, s, v) {
      h = ((h % 360) + 360) % 360; s = Math.max(0, Math.min(1, s)); v = Math.max(0, Math.min(1, v));
      const c = v * s; const x = c * (1 - Math.abs(((h / 60) % 2) - 1)); const m = v - c;
      let r1 = 0, g1 = 0, b1 = 0;
      if (0 <= h && h < 60) { r1 = c; g1 = x; }
      else if (60 <= h && h < 120) { r1 = x; g1 = c; }
      else if (120 <= h && h < 180) { g1 = c; b1 = x; }
      else if (180 <= h && h < 240) { g1 = x; b1 = c; }
      else if (240 <= h && h < 300) { r1 = x; b1 = c; }
      else { r1 = c; b1 = x; }
      return { r: Math.round((r1 + m) * 255), g: Math.round((g1 + m) * 255), b: Math.round((b1 + m) * 255) };
    }
    function rgbToHsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b); const d = max - min; const v = max;
      let h = 0, s = max === 0 ? 0 : d / max;
      if (d !== 0) {
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h *= 60;
      }
      return { h, s, v };
    }

    // ---- Advanced Color Picker (HSV: square=SxV, hue slider) ----
    const cpState = { h: 0, s: 1, v: 1 };
    function renderHue() {
      if (!cpHue) return; const dpr = window.devicePixelRatio || 1; const w = Math.round(cpHue.clientWidth * dpr); const h = Math.round(cpHue.clientHeight * dpr); if (cpHue.width !== w) cpHue.width = w; if (cpHue.height !== h) cpHue.height = h; const ctx = cpHue.getContext('2d'); const grd = ctx.createLinearGradient(0, 0, 0, h); const steps = [[0, '#FF0000'], [60, '#FFFF00'], [120, '#00FF00'], [180, '#00FFFF'], [240, '#0000FF'], [300, '#FF00FF'], [360, '#FF0000']]; steps.forEach(([deg, col]) => grd.addColorStop(deg / 360, col)); ctx.fillStyle = grd; ctx.fillRect(0, 0, w, h); // marker
      const y = (cpState.h / 360) * h; ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, y + 1); ctx.lineTo(w, y + 1); ctx.stroke();
    }
    function renderSquare() {
      if (!cpSquare) return; const dpr = window.devicePixelRatio || 1; const w = Math.round(cpSquare.clientWidth * dpr); const h = Math.round(cpSquare.clientHeight * dpr); if (cpSquare.width !== w) cpSquare.width = w; if (cpSquare.height !== h) cpSquare.height = h; const ctx = cpSquare.getContext('2d'); // base: white->hue horizontally
      const hueRgb = hsvToRgb(cpState.h, 1, 1); const hueHex = rgbToHex(hueRgb.r, hueRgb.g, hueRgb.b);
      let gradX = ctx.createLinearGradient(0, 0, w, 0); gradX.addColorStop(0, '#ffffff'); gradX.addColorStop(1, hueHex); ctx.fillStyle = gradX; ctx.fillRect(0, 0, w, h);
      // overlay vertical: transparent->black
      let gradY = ctx.createLinearGradient(0, 0, 0, h); gradY.addColorStop(0, 'rgba(0,0,0,0)'); gradY.addColorStop(1, 'rgba(0,0,0,1)'); ctx.fillStyle = gradY; ctx.fillRect(0, 0, w, h);
      // marker
      const mx = cpState.s * w; const my = (1 - cpState.v) * h; ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(mx, my, 6, 0, Math.PI * 2); ctx.stroke(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(mx, my, 5, 0, Math.PI * 2); ctx.stroke();
    }
    function setPickerFromHex(hex) { const rgb = hexToRgb(hex); const hsv = rgbToHsv(rgb.r, rgb.g, rgb.b); cpState.h = hsv.h; cpState.s = hsv.s; cpState.v = hsv.v; renderHue(); renderSquare(); if (typeof renderHueFs !== 'undefined') renderHueFs(); if (typeof renderSquareFs !== 'undefined') renderSquareFs(); pickedSwatch.style.background = hex; pickedHex.textContent = hex; const fsInput = document.getElementById('fsColorInput'); if (fsInput && fsInput.value !== hex) fsInput.value = hex; scheduleLivePreview(); }
    function commitPickerColor() { const rgb = hsvToRgb(cpState.h, cpState.s, cpState.v); const hex = rgbToHex(rgb.r, rgb.g, rgb.b).toUpperCase(); const input = document.getElementById('color-input'); if (input) { input.value = hex; } const fsInput = document.getElementById('fsColorInput'); if (fsInput) { fsInput.value = hex; } pickedSwatch.style.background = hex; pickedHex.textContent = hex; scheduleLivePreview(); }
    function initColorPicker() {
      if (!cpSquare || !cpHue) return; // start from current input or default
      const input = document.getElementById('color-input'); const start = (input && /^#([0-9A-Fa-f]{6})$/.test(input.value)) ? input.value.toUpperCase() : '#FF0000'; setPickerFromHex(start);
      const onHue = (e) => { const rect = cpHue.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1; const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top)); const H = Math.round((y / rect.height) * 360); cpState.h = Math.max(0, Math.min(359, H)); renderHue(); renderSquare(); commitPickerColor(); };
      let hueDragging = false; cpHue.addEventListener('mousedown', (e) => { hueDragging = true; onHue(e); }); document.addEventListener('mousemove', (e) => { if (hueDragging) onHue(e); }); document.addEventListener('mouseup', () => { hueDragging = false; });
      const onSq = (e) => { const rect = cpSquare.getBoundingClientRect(); const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left)); const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top)); cpState.s = rect.width ? (x / rect.width) : 0; cpState.v = rect.height ? (1 - y / rect.height) : 0; renderSquare(); commitPickerColor(); };
      let sqDragging = false; cpSquare.addEventListener('mousedown', (e) => { sqDragging = true; onSq(e); }); document.addEventListener('mousemove', (e) => { if (sqDragging) onSq(e); }); document.addEventListener('mouseup', () => { sqDragging = false; });
    }
    // FS binder mirrors the main picker
    function initColorPickerFs() {
      if (!cpSquareFs || !cpHueFs) return; const input = document.getElementById('color-input'); const start = (input && /^#([0-9A-Fa-f]{6})$/.test(input.value)) ? input.value.toUpperCase() : '#FF0000'; setPickerFromHex(start);
      const renderHueFs = () => { const dpr = window.devicePixelRatio || 1; const w = Math.round(cpHueFs.clientWidth * dpr); const h = Math.round(cpHueFs.clientHeight * dpr); if (cpHueFs.width !== w) cpHueFs.width = w; if (cpHueFs.height !== h) cpHueFs.height = h; const ctx = cpHueFs.getContext('2d'); const grd = ctx.createLinearGradient(0, 0, 0, h); const steps = [[0, '#FF0000'], [60, '#FFFF00'], [120, '#00FF00'], [180, '#00FFFF'], [240, '#0000FF'], [300, '#FF00FF'], [360, '#FF0000']]; steps.forEach(([deg, col]) => grd.addColorStop(deg / 360, col)); ctx.fillStyle = grd; ctx.fillRect(0, 0, w, h); const y = (cpState.h / 360) * h; ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, y + 1); ctx.lineTo(w, y + 1); ctx.stroke(); };
      const renderSquareFs = () => { const dpr = window.devicePixelRatio || 1; const w = Math.round(cpSquareFs.clientWidth * dpr); const h = Math.round(cpSquareFs.clientHeight * dpr); if (cpSquareFs.width !== w) cpSquareFs.width = w; if (cpSquareFs.height !== h) cpSquareFs.height = h; const ctx = cpSquareFs.getContext('2d'); const hueRgb = hsvToRgb(cpState.h, 1, 1); const hueHex = rgbToHex(hueRgb.r, hueRgb.g, hueRgb.b); const gradX = ctx.createLinearGradient(0, 0, w, 0); gradX.addColorStop(0, '#ffffff'); gradX.addColorStop(1, hueHex); ctx.fillStyle = gradX; ctx.fillRect(0, 0, w, h); const gradY = ctx.createLinearGradient(0, 0, 0, h); gradY.addColorStop(0, 'rgba(0,0,0,0)'); gradY.addColorStop(1, 'rgba(0,0,0,1)'); ctx.fillStyle = gradY; ctx.fillRect(0, 0, w, h); const mx = cpState.s * w; const my = (1 - cpState.v) * h; ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(mx, my, 6, 0, Math.PI * 2); ctx.stroke(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(mx, my, 5, 0, Math.PI * 2); ctx.stroke(); };
      const onHue = (e) => { const rect = cpHueFs.getBoundingClientRect(); const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top)); const H = Math.round((y / rect.height) * 360); cpState.h = Math.max(0, Math.min(359, H)); renderHueFs(); renderSquareFs(); commitPickerColor(); };
      let hueDragging = false; cpHueFs.addEventListener('mousedown', (e) => { hueDragging = true; onHue(e); }); document.addEventListener('mousemove', (e) => { if (hueDragging) onHue(e); }); document.addEventListener('mouseup', () => { hueDragging = false; });
      const onSq = (e) => { const rect = cpSquareFs.getBoundingClientRect(); const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left)); const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top)); cpState.s = rect.width ? (x / rect.width) : 0; cpState.v = rect.height ? (1 - y / rect.height) : 0; renderSquareFs(); commitPickerColor(); };
      let sqDragging = false; cpSquareFs.addEventListener('mousedown', (e) => { sqDragging = true; onSq(e); }); document.addEventListener('mousemove', (e) => { if (sqDragging) onSq(e); }); document.addEventListener('mouseup', () => { sqDragging = false; });
      renderHueFs(); renderSquareFs();
    }
    function samplePreviewPixel(x, y) {
      return new Promise(async (resolve, reject) => {
        try {
          if (!lastPreviewBytes || !previewW || !previewH) {
            console.log('No preview data available');
            reject(); return;
          }

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã
          if (x < 0 || x >= previewW || y < 0 || y >= previewH) {
            console.log(`Coordinates out of bounds: ${x},${y} (max: ${previewW - 1},${previewH - 1})`);
            reject(); return;
          }

          console.log(`Sampling pixel at: ${x},${y} from image ${previewW}x${previewH}`);

          const blob = new Blob([lastPreviewBytes], { type: 'image/png' });
          const url = URL.createObjectURL(blob);
          const img = await loadImage(url);
          const c = document.createElement('canvas');
          c.width = previewW;
          c.height = previewH;
          const ctx = c.getContext('2d');
          ctx.drawImage(img, 0, 0, previewW, previewH);
          const d = ctx.getImageData(0, 0, previewW, previewH).data;
          const i = (y * previewW + x) * 4;

          const r = d[i];
          const g = d[i + 1];
          const b = d[i + 2];

          console.log(`Sampled color: RGB(${r},${g},${b}) at index ${i}`);

          // –û—á–∏—â–∞–µ–º URL
          URL.revokeObjectURL(url);

          resolve({ r, g, b });
        } catch (e) {
          console.error('Error sampling pixel:', e);
          reject();
        }
      });
    }
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h = 0, s = 0, l = (max + min) / 2;
      const d = max - min;
      if (d !== 0) {
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h *= 60;
      }
      return { h, s, l };
    }
    function hslToRgb(h, s, l) {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const hp = h / 60;
      const x = c * (1 - Math.abs(hp % 2 - 1));
      let r1 = 0, g1 = 0, b1 = 0;
      if (0 <= hp && hp < 1) { r1 = c; g1 = x; }
      else if (1 <= hp && hp < 2) { r1 = x; g1 = c; }
      else if (2 <= hp && hp < 3) { g1 = c; b1 = x; }
      else if (3 <= hp && hp < 4) { g1 = x; b1 = c; }
      else if (4 <= hp && hp < 5) { r1 = x; b1 = c; }
      else if (5 <= hp && hp < 6) { r1 = c; b1 = x; }
      const m = l - c / 2;
      const r = Math.round((r1 + m) * 255), g = Math.round((g1 + m) * 255), b = Math.round((b1 + m) * 255);
      return { r, g, b };
    }
    function canvasToPngBytes(canvas) {
      return new Promise((res, rej) => {
        canvas.toBlob(async (blob) => {
          if (!blob) { rej(new Error('toBlob failed')); return; }
          const ab = await blob.arrayBuffer();
          res(new Uint8Array(ab));
        }, 'image/png');
      });
    }
    function bytesToBase64(bytes) {
      let bin = '';
      for (let i = 0; i < bytes.length; i++) { bin += String.fromCharCode(bytes[i]); }
      return btoa(bin);
    }

    // ---------- Magic Wand (flood fill by HSL tolerance) ----------
    async function computeWandSelection(seedX, seedY, contiguous) {
      try {
        if (!lastPreviewBytes || !previewW || !previewH) return null;
        const blob = new Blob([lastPreviewBytes], { type: 'image/png' });
        const url = URL.createObjectURL(blob);
        const img = await loadImage(url);
        const c = document.createElement('canvas'); c.width = previewW; c.height = previewH;
        const ctx = c.getContext('2d'); ctx.drawImage(img, 0, 0, previewW, previewH);
        const id = ctx.getImageData(0, 0, previewW, previewH);
        const data = id.data;
        const idx0 = (seedY * previewW + seedX) * 4;
        const seed = { r: data[idx0], g: data[idx0 + 1], b: data[idx0 + 2] };
        const seedH = rgbToHsl(seed.r, seed.g, seed.b);
        const hTol = Math.max(0, Math.min(60, parseInt(hueTol.value, 10)));
        const sTol = Math.max(0, Math.min(1, Number(satTol.value) / 100));
        const lTol = Math.max(0, Math.min(1, Number(lightTol.value) / 100));
        const pass = (r, g, b) => {
          const h = rgbToHsl(r, g, b);
          let dh = Math.abs(h.h - seedH.h); if (dh > 180) dh = 360 - dh;
          const ds = Math.abs(h.s - seedH.s);
          const dl = Math.abs(h.l - seedH.l);
          return (dh <= hTol && ds <= sTol && dl <= lTol);
        };
        const visited = new Uint8Array(previewW * previewH);
        const mask = new Uint8Array(previewW * previewH);
        const qx = new Int32Array(previewW * previewH);
        const qy = new Int32Array(previewW * previewH);
        let qs = 0, qe = 0;
        const push = (x, y) => { qx[qe] = x; qy[qe] = y; qe++; };
        const pop = () => { const x = qx[qs], y = qy[qs]; qs++; return [x, y]; };
        // seed
        push(seedX, seedY);
        visited[seedY * previewW + seedX] = 1;
        while (qs < qe) {
          const [x, y] = pop();
          const i = (y * previewW + x) * 4;
          if (pass(data[i], data[i + 1], data[i + 2])) {
            mask[y * previewW + x] = 1;
            if (contiguous) {
              if (x > 0 && !visited[y * previewW + (x - 1)]) { visited[y * previewW + (x - 1)] = 1; push(x - 1, y); }
              if (x < previewW - 1 && !visited[y * previewW + (x + 1)]) { visited[y * previewW + (x + 1)] = 1; push(x + 1, y); }
              if (y > 0 && !visited[(y - 1) * previewW + x]) { visited[(y - 1) * previewW + x] = 1; push(x, y - 1); }
              if (y < previewH - 1 && !visited[(y + 1) * previewW + x]) { visited[(y + 1) * previewW + x] = 1; push(x, y + 1); }
            }
          }
        }
        // build overlay canvas for drawing
        const oc = document.createElement('canvas'); oc.width = previewW; oc.height = previewH;
        const octx = oc.getContext('2d');
        const od = octx.createImageData(previewW, previewH);
        for (let p = 0; p < mask.length; p++) {
          if (mask[p]) {
            const j = p * 4; od.data[j] = 59; od.data[j + 1] = 130; od.data[j + 2] = 246; od.data[j + 3] = Math.round(0.12 * 255);
          }
        }
        octx.putImageData(od, 0, 0);
        return { type: 'wand', overlay: oc, w: previewW, h: previewH };
      } catch { return null; }
    }

    // ---------- Selection mask (rect + paths) ----------
    let paintInfo = null; // { scaleMode, imageTransform:[[a,b,tx],[c,d,ty]], nodeW, nodeH }
    function buildMaskAlpha(width, height) {
      if (!areaToggle || !areaToggle.checked) return null;
      if (!shapes || shapes.length === 0) return null; // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –≤–µ–∫—Ç–æ—Ä–Ω—ã–µ –ø—É—Ç–∏
      if (!previewW || !previewH) return null;
      const c = document.createElement('canvas'); c.width = width; c.height = height;
      const ctx = c.getContext('2d'); ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#000'; ctx.globalCompositeOperation = 'source-over';

      // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤—ã–¥–µ–ª–µ–Ω–∏—è –≤ –ø—Ä–µ–≤—å—é (preview space)
      // –ù—É–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –∏—Ö –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–ª–µ–≤–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (target image space)

      const nodeW = paintInfo?.nodeW || previewW;
      const nodeH = paintInfo?.nodeH || previewH;

      // –ï—Å–ª–∏ —Ü–µ–ª–µ–≤–æ–π —Ä–∞–∑–º–µ—Ä == —Ä–∞–∑–º–µ—Ä—É –ø—Ä–µ–≤—å—é, —Ç–æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –Ω—É–∂–Ω–∞ (1:1 –º–∞–ø–ø–∏–Ω–≥)
      const isPreviewSize = (width === previewW && height === previewH);

      if (isPreviewSize) {
        // –ú–∞—Å–∫–∞ –¥–ª—è –ø—Ä–µ–≤—å—é: –≤—ã–¥–µ–ª–µ–Ω–∏–µ —É–∂–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
        console.log('buildMaskAlpha for PREVIEW (1:1):', {
          previewSize: { w: previewW, h: previewH },
          targetSize: { w: width, h: height }
        });
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      } else if (paintInfo && paintInfo.scaleMode === 'CROP' && paintInfo.imageTransform) {
        // CROP —Ä–µ–∂–∏–º: –Ω—É–∂–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –º–∞–ø–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        // Figma imageTransform: node_pixel = transform_matrix * img_pixel
        // –í 2D: [[a, 0, tx], [0, d, ty]] –≥–¥–µ:
        //   node_x = a * img_x + tx * nodeW
        //   node_y = d * img_y + ty * nodeH
        // 
        // –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ:
        //   img_x = (preview_x - tx * nodeW) / a
        //   img_y = (preview_y - ty * nodeH) / d
        const [[a, , txRaw], [, d, tyRaw]] = paintInfo.imageTransform;

        // Canvas transform: –Ω–∞–º –Ω—É–∂–Ω–æ –º–∞–ø–∏—Ç—å preview (1645x1350) –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        // –≤ original (1024x1024) –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        // setTransform(a, b, c, d, e, f): x' = a*x + c*y + e, y' = b*x + d*y + f
        // –ù–∞–º –Ω—É–∂–Ω–æ: x' = x/a - tx*nodeW/a

        const scaleX = 1 / a;
        const scaleY = 1 / d;
        const offsetX = -txRaw * nodeW;  // Negative, don't divide by 'a'
        const offsetY = -tyRaw * nodeH;  // Negative, don't divide by 'd'

        console.log('buildMaskAlpha CROP mode:', {
          previewSize: { w: previewW, h: previewH },
          targetSize: { w: width, h: height },
          nodeSize: { w: nodeW, h: nodeH },
          transform: { a, d, tx: txRaw, ty: tyRaw },
          computed: { sx: scaleX, sy: scaleY, tx: offsetX, ty: offsetY },
          testCenter: {
            preview: { x: previewW / 2, y: previewH / 2 },
            mapsTo: { x: (previewW / 2) * scaleX + offsetX, y: (previewH / 2) * scaleY + offsetY }
          }
        });

        ctx.setTransform(scaleX, 0, 0, scaleY, offsetX, offsetY);
      } else if (fillW === previewW && fillH === previewH) {
        // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ - —Ä–∞–∑–º–µ—Ä—ã —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å –ø—Ä–µ–≤—å—é, —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –Ω–µ –Ω—É–∂–Ω—ã
        console.log('buildMaskAlpha EXPORT mode (1:1):', {
          previewSize: { w: previewW, h: previewH },
          targetSize: { w: width, h: height },
          fillSize: { w: fillW, h: fillH },
          paintInfo: paintInfo,
          note: 'Using exported image, coordinates should match 1:1'
        });

        // –î–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å 1:1
        // –ù–∏–∫–∞–∫–∏—Ö —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π –Ω–µ –ø—Ä–∏–º–µ–Ω—è–µ–º
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      } else if (paintInfo && (paintInfo.scaleMode === 'FIT' || paintInfo.scaleMode === 'FILL') && paintInfo.imageTransform) {
        // FIT/FILL —Ä–µ–∂–∏–º —Å imageTransform: –Ω—É–∂–Ω–æ —É—á–µ—Å—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é
        const [[a, b, txRaw], [c, d, tyRaw]] = paintInfo.imageTransform;
        const nodeW = paintInfo.nodeW || 1;
        const nodeH = paintInfo.nodeH || 1;

        // –í FIT —Ä–µ–∂–∏–º–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç—Å—è —á—Ç–æ–±—ã –ø–æ–º–µ—Å—Ç–∏—Ç—å—Å—è –≤ —É–∑–µ–ª
        // –ù—É–∂–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –º–∞–ø–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø—Ä–µ–≤—å—é –∫ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
        const sx = width / Math.max(1, previewW);
        const sy = height / Math.max(1, previewH);

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –º–∞–ø–ø–∏–Ω–≥–∞
        const invA = 1 / a;
        const invD = 1 / d;
        const offsetX = -txRaw * nodeW * invA;
        const offsetY = -tyRaw * nodeH * invD;

        console.log(`buildMaskAlpha ${paintInfo.scaleMode} mode with transform:`, {
          previewSize: { w: previewW, h: previewH },
          targetSize: { w: width, h: height },
          transform: { a, b, txRaw, c, d, tyRaw },
          nodeSize: { w: nodeW, h: nodeH },
          scale: { sx, sy },
          offset: { x: offsetX, y: offsetY },
          inverse: { invA, invD }
        });

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é
        ctx.setTransform(sx * invA, 0, 0, sy * invD, offsetX, offsetY);
      } else {
        // FILL —Ä–µ–∂–∏–º: –ø—Ä–æ—Å—Ç–æ–µ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
        const sx = width / Math.max(1, previewW);
        const sy = height / Math.max(1, previewH);

        console.log('buildMaskAlpha FILL mode:', {
          previewSize: { w: previewW, h: previewH },
          targetSize: { w: width, h: height },
          scale: { sx, sy },
          paintInfo
        });

        ctx.setTransform(sx, 0, 0, sy, 0, 0);
      }

      // –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è —Ç–µ–ø–µ—Ä—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ –≤ selB
      // paths in preview coordinates
      const drawPath = (path) => {
        if (!path || !path.points || path.points.length < 3 || !path.closed) return;
        ctx.beginPath(); const p0 = path.points[0]; ctx.moveTo(p0.x, p0.y);
        for (let i = 1; i < path.points.length; i++) {
          const prev = path.points[i - 1]; const cur = path.points[i];
          if (prev.cp) { ctx.quadraticCurveTo(prev.cp.x, prev.cp.y, cur.x, cur.y); }
          else { ctx.lineTo(cur.x, cur.y); }
        }
        ctx.closePath(); ctx.fill();
      };
      if (shapes && shapes.length) {
        shapes.forEach(s => { if (s.type === 'path') drawPath(s); });
        // wand overlays contribute their alpha into the mask (overlay is in preview space)
        shapes.forEach(s => { if (s.type === 'wand' && s.overlay) { ctx.drawImage(s.overlay, 0, 0, Math.max(1, previewW), Math.max(1, previewH)); } });
      }
      const alpha = ctx.getImageData(0, 0, width, height).data; // RGBA, use A only
      return alpha;
    }

    // ---------- Ignore list + zoom + pipette helpers ----------
    function addIgnore(hex) {
      if (!ignoreColors.find(c => c.hex.toLowerCase() === hex.toLowerCase())) {
        const rgb = hexToRgb(hex);
        ignoreColors.push({ hex, hsl: rgbToHsl(rgb.r, rgb.g, rgb.b) });
        renderIgnoreList();
      }
    }
    function removeIgnore(hex) {
      const i = ignoreColors.findIndex(c => c.hex.toLowerCase() === hex.toLowerCase());
      if (i >= 0) { ignoreColors.splice(i, 1); renderIgnoreList(); }
    }
    function renderIgnoreList() {
      // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Å–ø–∏—Å–æ–∫
      ignoreListEl.innerHTML = '';
      ignoreColors.forEach(c => {
        const chip = document.createElement('div');
        chip.className = 'chip';
        const sw = document.createElement('span'); sw.style.width = '14px'; sw.style.height = '14px'; sw.style.borderRadius = '3px'; sw.style.border = '1px solid #ccc'; sw.style.display = 'inline-block'; sw.style.background = c.hex;
        const tx = document.createElement('span'); tx.textContent = c.hex; tx.style.fontSize = '12px';
        const rm = document.createElement('button');
        rm.innerHTML = '<svg width="14" height="14" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m336 432c11.046 0 20-8.954 20-20v-232c0-11.046-8.954-20-20-20s-20 8.954-20 20v232c0 11.046 8.954 20 20 20zm120-352h-100v-20c0-33.084-26.916-60-60-60h-80c-33.084 0-60 26.916-60 60v20h-100c-11.046 0-20 8.954-20 20s8.954 20 20 20c11.028 0 20 8.972 20 20v312c0 33.084 26.916 60 60 60h240c33.084 0 60-26.916 60-60v-312c0-11.028 8.972-20 20-20 11.046 0 20-8.954 20-20s-8.954-20-20-20zm-260-20c0-11.028 8.972-20 20-20h80c11.028 0 20 8.972 20 20v20h-120zm200 80v312c0 11.028-8.972 20-20 20h-240c-11.028 0-20-8.972-20-20v-312c0-7.011-1.22-13.74-3.44-20h286.881c-2.221 6.26-3.441 12.989-3.441 20zm-140 292c11.046 0 20-8.954 20-20v-232c0-11.046-8.954-20-20-20s-20 8.954-20 20v232c0 11.046 8.954 20 20 20zm-80 0c11.046 0 20-8.954 20-20v-232c0-11.046-8.954-20-20-20s-20 8.954-20 20v232c0 11.046 8.954 20 20 20z" fill="currentColor"/></svg>';
        rm.className = 'button-secondary'; rm.style.padding = '2px 6px'; rm.style.height = '22px'; rm.style.display = 'inline-flex'; rm.style.alignItems = 'center'; rm.onclick = () => removeIgnore(c.hex);
        chip.appendChild(sw); chip.appendChild(tx); chip.appendChild(rm);
        ignoreListEl.appendChild(chip);
      });

      // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫
      const fsIgnoreList = document.getElementById('fsIgnoreList');
      if (fsIgnoreList) {
        fsIgnoreList.innerHTML = '';
        ignoreColors.forEach(c => {
          const chip = document.createElement('div');
          chip.style.cssText = 'display:inline-flex; align-items:center; gap:3px; background:#f1f5f9; border:1px solid #d6ddeb; border-radius:4px; padding:2px 4px; font-size:9px;';
          const sw = document.createElement('span');
          sw.style.cssText = 'width:10px; height:10px; border-radius:2px; border:1px solid #ccc; display:inline-block; background:' + c.hex;
          const tx = document.createElement('span');
          tx.textContent = c.hex;
          tx.style.fontSize = '8px';
          const rm = document.createElement('button');
          rm.innerHTML = '<svg width="10" height="10" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m336 432c11.046 0 20-8.954 20-20v-232c0-11.046-8.954-20-20-20s-20 8.954-20 20v232c0 11.046 8.954 20 20 20zm120-352h-100v-20c0-33.084-26.916-60-60-60h-80c-33.084 0-60 26.916-60 60v20h-100c-11.046 0-20 8.954-20 20s8.954 20 20 20c11.028 0 20 8.972 20 20v312c0 33.084 26.916 60 60 60h240c33.084 0 60-26.916 60-60v-312c0-11.028 8.972-20 20-20 11.046 0 20-8.954 20-20s-8.954-20-20-20zm-260-20c0-11.028 8.972-20 20-20h80c11.028 0 20 8.972 20 20v20h-120zm200 80v312c0 11.028-8.972 20-20 20h-240c-11.028 0-20-8.972-20-20v-312c0-7.011-1.22-13.74-3.44-20h286.881c-2.221 6.26-3.441 12.989-3.441 20zm-140 292c11.046 0 20-8.954 20-20v-232c0-11.046-8.954-20-20-20s-20 8.954-20 20v232c0 11.046 8.954 20 20 20zm-80 0c11.046 0 20-8.954 20-20v-232c0-11.046-8.954-20-20-20s-20 8.954-20 20v232c0 11.046 8.954 20 20 20z" fill="currentColor"/></svg>';
          rm.style.cssText = 'background:none; border:none; color:#666; cursor:pointer; padding:0; width:12px; height:12px; display:inline-flex; align-items:center; justify-content:center;';
          rm.onclick = () => removeIgnore(c.hex);
          chip.appendChild(sw); chip.appendChild(tx); chip.appendChild(rm);
          fsIgnoreList.appendChild(chip);
        });
      }
    }
    function isIgnored(hsl, hTol, sTol, lTol) {
      for (const c of ignoreColors) {
        const ih = c.hsl.h, is = c.hsl.s, il = c.hsl.l;
        let dh = Math.abs(hsl.h - ih); if (dh > 180) dh = 360 - dh;
        const ds = Math.abs(hsl.s - is);
        const dl = Math.abs(hsl.l - il);
        if (dh <= hTol && ds <= sTol && dl <= lTol) return true;
      }
      return false;
    }
    function applyZoom() { if (imgEl) imgEl.style.transform = 'scale(' + zoom + ')'; if (overlayCanvas) overlayCanvas.style.transform = 'scale(' + zoom + ')'; if (selectionCanvas) selectionCanvas.style.transform = 'scale(' + zoom + ')'; try { renderSelectionRect(); } catch (_) { } }
    function updatePipetteButtons() {
      pipetteBtn.style.background = pipetteMode === 'target' ? '#0284c7' : '#0ea5e9';
      pipetteSrcBtn.style.background = pipetteMode === 'source' ? '#059669' : '#10b981';
      pipetteIgnoreBtn.style.background = pipetteMode === 'ignore' ? '#d97706' : '#f59e0b';

      // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–µ –ø–∏–ø–µ—Ç–∫–∏
      const fsPipetteTarget = document.getElementById('fsPipetteTarget');
      const fsPipetteSource = document.getElementById('fsPipetteSource');
      const fsPipetteIgnore = document.getElementById('fsPipetteIgnore');

      if (fsPipetteTarget) {
        fsPipetteTarget.style.background = pipetteMode === 'target' ? '#0284c7' : '#0ea5e9';
        fsPipetteTarget.style.transform = pipetteMode === 'target' ? 'scale(1.1)' : 'scale(1)';
        fsPipetteTarget.style.boxShadow = pipetteMode === 'target' ? '0 2px 8px rgba(2, 132, 199, 0.4)' : 'none';
      }
      if (fsPipetteSource) {
        fsPipetteSource.style.background = pipetteMode === 'source' ? '#059669' : '#10b981';
        fsPipetteSource.style.transform = pipetteMode === 'source' ? 'scale(1.1)' : 'scale(1)';
        fsPipetteSource.style.boxShadow = pipetteMode === 'source' ? '0 2px 8px rgba(5, 150, 105, 0.4)' : 'none';
      }
      if (fsPipetteIgnore) {
        fsPipetteIgnore.style.background = pipetteMode === 'ignore' ? '#d97706' : '#f59e0b';
        fsPipetteIgnore.style.transform = pipetteMode === 'ignore' ? 'scale(1.1)' : 'scale(1)';
        fsPipetteIgnore.style.boxShadow = pipetteMode === 'ignore' ? '0 2px 8px rgba(217, 119, 6, 0.4)' : 'none';
      }
    }

    // ---------- Live preview overlay ----------
    function ensureOverlay() {
      if (!overlayCanvas) {
        overlayCanvas = document.createElement('canvas');
        overlayCanvas.className = 'result-overlay';
        overlayCanvas.width = Math.max(1, previewW || (imgEl ? imgEl.naturalWidth : 0));
        overlayCanvas.height = Math.max(1, previewH || (imgEl ? imgEl.naturalHeight : 0));
        overlayCanvas.style.opacity = '1';
        preview.appendChild(overlayCanvas);
        applyZoom();
      }
    }
    function updateOverlayOpacity() { if (overlayCanvas) { overlayCanvas.style.opacity = '1'; } }
    function scheduleLivePreview() {
      if ((!lastPreviewBytes && !imgEl) || !previewW || !previewH) return;
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const elapsed = now - lastPreviewAt;
      const schedule = () => {
        if (previewRafId) return;
        previewRafId = requestAnimationFrame(async () => {
          previewRafId = null;
          lastPreviewAt = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
          await renderLivePreview();
        });
      };
      if (elapsed >= PREVIEW_MIN_DELAY) {
        if (previewTimeoutId) { clearTimeout(previewTimeoutId); previewTimeoutId = null; }
        schedule();
      } else {
        if (previewTimeoutId) clearTimeout(previewTimeoutId);
        previewTimeoutId = setTimeout(() => { previewTimeoutId = null; schedule(); }, PREVIEW_MIN_DELAY - elapsed);
      }
    }
    async function renderLivePreview() {
      try {
        ensureOverlay();
        const color = (document.getElementById('color-input').value || '').trim();
        if (!/^#([0-9A-Fa-f]{6})$/.test(color)) return;
        // Prepare base image for preview ops
        let baseImg = null;
        if (lastPreviewBytes) {
          const blobPrev = new Blob([lastPreviewBytes], { type: 'image/png' });
          const urlPrev = URL.createObjectURL(blobPrev);
          baseImg = await loadImage(urlPrev);
        } else if (imgEl) {
          baseImg = imgEl;
        } else { return; }
        // Determine source HSL
        let sHSL;
        const srcHex = (srcColorInput.value || '').trim();
        if (/^#([0-9A-Fa-f]{6})$/.test(srcHex)) {
          const sRGB = hexToRgb(srcHex); sHSL = rgbToHsl(sRGB.r, sRGB.g, sRGB.b);
        } else {
          // sample from selected point or center as fallback
          const cPrev = document.createElement('canvas'); cPrev.width = previewW; cPrev.height = previewH;
          const ctxPrev = cPrev.getContext('2d'); ctxPrev.drawImage(baseImg, 0, 0, previewW, previewH);
          const dPrev = ctxPrev.getImageData(0, 0, previewW, previewH).data;
          const sx = (selectedCoords ? selectedCoords.x : Math.floor(previewW / 2));
          const sy = (selectedCoords ? selectedCoords.y : Math.floor(previewH / 2));
          const iPrev = (sy * previewW + sx) * 4;
          sHSL = rgbToHsl(dPrev[iPrev], dPrev[iPrev + 1], dPrev[iPrev + 2]);
        }

        const target = hexToRgb(color);
        const tHSL = rgbToHsl(target.r, target.g, target.b);
        let dHue = tHSL.h - sHSL.h; if (dHue > 180) dHue -= 360; if (dHue < -180) dHue += 360;
        const dsOff = tHSL.s - sHSL.s;
        const dlOff = tHSL.l - sHSL.l;
        const hTol = Math.max(0, Math.min(60, parseInt(hueTol.value, 10)));
        const sTol = Math.max(0, Math.min(1, Number(satTol.value) / 100));
        const lTol = Math.max(0, Math.min(1, Number(lightTol.value) / 100));
        const k = Math.max(0, Math.min(1, Number(intensity.value) / 100));

        overlayCanvas.width = previewW; overlayCanvas.height = previewH;
        const ctx = overlayCanvas.getContext('2d');
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        ctx.drawImage(baseImg, 0, 0, previewW, previewH);
        const dt = ctx.getImageData(0, 0, previewW, previewH);
        const a = dt.data;
        // –ü—Ä–æ—Å—Ç–æ–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –≤ –ø—Ä–µ–≤—å—é
        let selB = null;
        if (areaToggle && areaToggle.checked && selectionNat && selectionNat.w > 0 && selectionNat.h > 0) {
          // –í—ã–¥–µ–ª–µ–Ω–∏–µ —É–∂–µ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –ø—Ä–µ–≤—å—é (previewW x previewH)
          const x0 = Math.max(0, Math.min(previewW, Math.round(selectionNat.x)));
          const y0 = Math.max(0, Math.min(previewH, Math.round(selectionNat.y)));
          const x1 = Math.max(x0, Math.min(previewW, Math.round(selectionNat.x + selectionNat.w)));
          const y1 = Math.max(y0, Math.min(previewH, Math.round(selectionNat.y + selectionNat.h)));
          selB = { x0, y0, x1, y1 };
        }

        const maskA = buildMaskAlpha(previewW, previewH);
        let previewProcessed = 0;
        for (let i = 0; i < a.length; i += 4) {
          if (selB) { const p = (i >> 2); const y = Math.floor(p / previewW); const x = p - y * previewW; if (x < selB.x0 || x >= selB.x1 || y < selB.y0 || y >= selB.y1) continue; }
          else if (maskA) { if (maskA[i + 3] === 0) continue; }
          const r = a[i], g = a[i + 1], b = a[i + 2];
          const hsl = rgbToHsl(r, g, b);
          let dh = Math.abs(hsl.h - sHSL.h); if (dh > 180) dh = 360 - dh;
          const ds = Math.abs(hsl.s - sHSL.s);
          const dl = Math.abs(hsl.l - sHSL.l);
          if (!isIgnored(hsl, hTol, sTol, lTol) && (dh <= hTol && ds <= sTol && dl <= lTol)) {
            previewProcessed++;
            let h = hsl.h + dHue; if (h < 0) h += 360; if (h >= 360) h -= 360;
            let s = clamp01(hsl.s + dsOff);
            let l = clamp01(hsl.l + dlOff);
            h = lerpAngle(hsl.h, h, k);
            s = lerp(hsl.s, s, k);
            l = lerp(hsl.l, l, k);
            const rgb = hslToRgb(h, s, l);
            a[i] = rgb.r; a[i + 1] = rgb.g; a[i + 2] = rgb.b;
          }
        }


        ctx.putImageData(dt, 0, 0);
        overlayCanvas.style.display = '';
        applyZoom();
      } catch (e) { /* silently ignore preview errors */ }
    }

    // Toggle + opacity
    // Preview is always on
    ensureOverlay();
    scheduleLivePreview();
    initColorPicker();
    initColorPickerFs();

    // Mini zoom controls and Ctrl+Wheel zoom
    function zoomAtPoint(factor, clientX, clientY) {
      const old = zoom;
      const rect = preview.getBoundingClientRect();
      const cx = (typeof clientX === 'number') ? clientX : (rect.left + rect.width / 2);
      const cy = (typeof clientY === 'number') ? clientY : (rect.top + rect.height / 2);
      const dx = cx - rect.left; const dy = cy - rect.top;
      const beforeX = preview.scrollLeft + dx;
      const beforeY = preview.scrollTop + dy;
      setZoomAndUi(zoom * factor);
      const scale = zoom / old;
      const afterX = beforeX * scale;
      const afterY = beforeY * scale;
      preview.scrollLeft = Math.max(0, afterX - dx);
      preview.scrollTop = Math.max(0, afterY - dy);
      // after scroll changes, re-render selection mapping to avoid drift
      try { renderSelectionRect(); scheduleDrawSelectionOverlay(); } catch (_) { }
    }
    if (zoomInBtn && !zoomInBtn.__w) { zoomInBtn.__w = true; zoomInBtn.addEventListener('click', () => zoomAtPoint(1.1)); }
    if (zoomOutBtn && !zoomOutBtn.__w) { zoomOutBtn.__w = true; zoomOutBtn.addEventListener('click', () => zoomAtPoint(1 / 1.1)); }
    preview.addEventListener('wheel', (e) => { if (e.ctrlKey) { e.preventDefault(); const f = e.deltaY < 0 ? 1.1 : 1 / 1.1; zoomAtPoint(f, e.clientX, e.clientY); } }, { passive: false });

    // Palette: 10 swatches, click=select, Alt+click=copy
    const defaultPalette = ['#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#00C7BE', '#007AFF', '#5856D6', '#AF52DE', '#FF2D55', '#8E8E93'];
    function renderPalette() {
      if (!fsPalette) return;
      fsPalette.innerHTML = '';
      defaultPalette.forEach(hex => {
        const btn = document.createElement('button');
        btn.type = 'button'; btn.className = 'icon-btn';
        btn.style.width = '28px'; btn.style.height = '28px'; btn.style.borderRadius = '6px';
        btn.title = hex + ' ‚Äî –õ–ö–ú: –≤—ã–±—Ä–∞—Ç—å, Alt: –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å';
        const sw = document.createElement('span');
        sw.style.width = '16px'; sw.style.height = '16px'; sw.style.borderRadius = '4px'; sw.style.border = '1px solid #0002'; sw.style.background = hex; sw.style.display = 'inline-block';
        btn.appendChild(sw);
        btn.addEventListener('click', async (e) => {
          if (e.altKey) { try { await navigator.clipboard.writeText(hex); } catch (_) { } return; }
          const ci = document.getElementById('color-input'); if (ci) { ci.value = hex; pickedSwatch.style.background = hex; pickedHex.textContent = hex; scheduleLivePreview(); }
        });
        fsPalette.appendChild(btn);
      });
    }
    renderPalette();

    // ---------- Panning (RMB/MMB or hold Space + LMB) ----------
    let isPanning = false, panStartX = 0, panStartY = 0, panScrollLeft = 0, panScrollTop = 0, spaceHeld = false;
    window.addEventListener('keydown', (e) => { if (e.code === 'Space') spaceHeld = true; });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') spaceHeld = false; });
    preview.addEventListener('mousedown', (e) => {
      const allow = (e.button === 1 || e.button === 2 || (e.button === 0 && spaceHeld));
      if (!allow) return;
      e.preventDefault();
      isPanning = true; preview.classList.add('panning');
      panStartX = e.clientX; panStartY = e.clientY; panScrollLeft = preview.scrollLeft; panScrollTop = preview.scrollTop;
    });
    document.addEventListener('mousemove', (e) => {
      if (!isPanning) return;
      const dx = e.clientX - panStartX; const dy = e.clientY - panStartY;
      preview.scrollLeft = panScrollLeft - dx;
      preview.scrollTop = panScrollTop - dy;
    });
    document.addEventListener('mouseup', () => { if (isPanning) { isPanning = false; preview.classList.remove('panning'); } });
    preview.addEventListener('contextmenu', (e) => { if (isPanning) { e.preventDefault(); } });

    // License management
    let licenseInfo = { usageCount: 0, isPro: false, remainingUses: 5 };

    function updateLicenseUI() {
      const licenseInfo_el = document.getElementById('licenseInfo');
      const licenseStatusText = document.getElementById('licenseStatusText');
      const licenseDetailsText = document.getElementById('licenseDetailsText');
      const upgradeBtn = document.getElementById('upgradeBtn');
      const upgradeBtnText = document.getElementById('upgradeBtnText');

      // Update status badge
      updateStatusBadge();

      if (!licenseInfo_el || !licenseStatusText || !licenseDetailsText) return;

      const pack = translations[state.language] || translations.en;

      if (licenseInfo.isPro) {
        // Check for expiry warning - only show warning/danger states
        if (licenseInfo.expiryWarning && licenseInfo.daysUntilExpiry !== undefined) {
          licenseInfo_el.className = 'card warning';
          licenseStatusText.textContent = pack.license_pro_active || 'Pro Active';

          let warningMsg = pack.license_unlimited || 'Unlimited access';
          if (licenseInfo.daysUntilExpiry <= 1) {
            warningMsg += ` - ${pack.license_expires_soon || 'Expires soon!'}`;
          } else {
            warningMsg += ` - ${licenseInfo.daysUntilExpiry} ${pack.license_days_remaining || 'days remaining'}`;
          }

          licenseDetailsText.textContent = warningMsg;

          if (upgradeBtn) {
            upgradeBtn.style.display = 'block';
            upgradeBtnText.textContent = pack.license_renew || 'Renew';
          }

          licenseInfo_el.style.display = 'block';
        } else {
          // Hide the license info block for active Pro users (no warnings)
          licenseInfo_el.style.display = 'none';
        }
      } else {
        licenseInfo_el.style.display = 'block';
        if (licenseInfo.remainingUses <= 0) {
          licenseInfo_el.className = 'card danger';
          licenseStatusText.textContent = pack.license_limit_reached || 'Limit reached';
          licenseDetailsText.textContent = pack.license_limit_message || 'Get Pro for unlimited access';
          if (upgradeBtn) {
            upgradeBtn.style.display = 'block';
            upgradeBtnText.textContent = pack.license_get_pro || 'Get Pro';
          }
        } else if (licenseInfo.remainingUses <= 2) {
          licenseInfo_el.className = 'card warning';
          licenseStatusText.textContent = `${licenseInfo.remainingUses} ${pack.license_remaining || 'remaining'}`;
          licenseDetailsText.textContent = `${pack.license_free_uses || 'Free uses'} (${5 - licenseInfo.remainingUses}/5)`;
          if (upgradeBtn) {
            upgradeBtn.style.display = 'block';
            upgradeBtnText.textContent = pack.license_get_pro || 'Get Pro';
          }
        } else {
          licenseInfo_el.className = 'card';
          licenseStatusText.textContent = `${licenseInfo.remainingUses} ${pack.license_remaining || 'remaining'}`;
          licenseDetailsText.textContent = `${pack.license_free_uses || 'Free uses'} (${5 - licenseInfo.remainingUses}/5)`;
          if (upgradeBtn) upgradeBtn.style.display = 'none';
        }
      }
    }

    function showLicenseModal() {
      const modal = document.getElementById('licenseModal');
      if (modal) {
        modal.classList.remove('hidden');
        updateModalTexts();
      }
    }

    function hideLicenseModal() {
      const modal = document.getElementById('licenseModal');
      if (modal) {
        modal.classList.add('hidden');
      }
    }

    function updateModalTexts() {
      const pack = translations[state.language] || translations.en;

      const modalTitle = document.getElementById('modalTitle');
      const modalMessage = document.getElementById('modalMessage');
      const modalFeature = document.getElementById('modalFeature');
      const buyProBtn = document.getElementById('buyProBtn');
      const getCodeBtnText = document.getElementById('getCodeBtnText');
      const modalCancel = document.getElementById('modalCancel');
      const activationLabel = document.getElementById('activationLabel');
      const activationKey = document.getElementById('activationKey');
      const activateBtnText = document.getElementById('activateBtnText');

      if (modalTitle) modalTitle.textContent = pack.license_limit_reached || 'Usage limit reached';
      if (modalMessage) modalMessage.textContent = pack.license_limit_message || 'You have used all 5 free attempts. Get Pro version for unlimited access.';
      if (modalFeature) modalFeature.textContent = '‚ú® ' + (pack.license_feature_unlimited || 'Unlimited processing');
      if (buyProBtn) buyProBtn.textContent = pack.license_buy_telegram || 'Buy via Telegram';

      // Update pricing
      const modalPrice = document.getElementById('modalPrice');
      const modalPriceNote = document.getElementById('modalPriceNote');
      if (modalPrice) modalPrice.textContent = pack.price_monthly || '$4.99 / month';
      if (modalPriceNote) modalPriceNote.textContent = pack.price_yearly_note || 'or $39.99 / year (33% savings)';
      if (getCodeBtnText) getCodeBtnText.textContent = pack.get_code_button || 'Get Code (Have Subscription)';
      if (modalCancel) modalCancel.textContent = 'Cancel';
      if (activationLabel) activationLabel.textContent = pack.activation_label || 'Already have an activation key?';
      if (activationKey) activationKey.placeholder = pack.activation_placeholder || 'Enter activation key';
      if (activateBtnText) activateBtnText.textContent = pack.activation_button || 'Activate';
    }

    // Status Badge Functions
    function updateStatusBadge() {
      const statusBadge = document.getElementById('statusBadge');
      const statusText = document.getElementById('statusText');
      const pack = translations[state.language] || translations.en;

      if (!statusBadge || !statusText) return;

      // Remove all status classes
      statusBadge.classList.remove('pro', 'free', 'warning');

      if (licenseInfo.isPro) {
        // Check for expiry warning
        if (licenseInfo.expiryWarning && licenseInfo.daysUntilExpiry !== undefined) {
          statusBadge.classList.add('warning');
          statusText.textContent = 'PRO';
          statusBadge.title = `Pro subscription expires in ${licenseInfo.daysUntilExpiry} days. Click to manage.`;
        } else {
          statusBadge.classList.add('pro');
          statusText.textContent = 'PRO';
          statusBadge.title = pack.status_pro_tooltip || 'Pro subscription active. Click for details.';
        }
      } else {
        statusBadge.classList.add('free');
        statusText.textContent = 'FREE';
        const remaining = licenseInfo.remainingUses || 0;
        statusBadge.title = `${remaining} free uses remaining. Click to upgrade.`;
      }
    }

    function showSubscriptionModal() {
      const modal = document.getElementById('subscriptionModal');
      if (modal) {
        modal.classList.remove('hidden');
        updateSubscriptionModalContent();
      }
    }

    function hideSubscriptionModal() {
      const modal = document.getElementById('subscriptionModal');
      if (modal) {
        modal.classList.add('hidden');
      }
    }

    function updateSubscriptionModalContent() {
      const pack = translations[state.language] || translations.en;

      // Update modal title
      const subModalTitle = document.getElementById('subModalTitle');
      if (subModalTitle) {
        subModalTitle.textContent = pack.subscription_info_title || 'Subscription Information';
      }

      // Update field labels
      const subTypeLabel = document.getElementById('subTypeLabel');
      const subPurchaseDateLabel = document.getElementById('subPurchaseDateLabel');
      const subExpiryDateLabel = document.getElementById('subExpiryDateLabel');
      const subDaysLeftLabel = document.getElementById('subDaysLeftLabel');
      const subModalCancel = document.getElementById('subModalCancel');

      if (subTypeLabel) subTypeLabel.textContent = pack.subscription_type_label || 'Subscription Type';
      if (subPurchaseDateLabel) subPurchaseDateLabel.textContent = pack.subscription_purchase_date_label || 'Purchase Date';
      if (subExpiryDateLabel) subExpiryDateLabel.textContent = pack.subscription_expires_label || 'Expires';
      if (subDaysLeftLabel) subDaysLeftLabel.textContent = pack.subscription_days_left_label || 'Days Left';
      if (subModalCancel) subModalCancel.textContent = pack.modal_close || 'Close';

      // Update status badge in modal
      const subStatusBadge = document.getElementById('subStatusBadge');
      const subStatusText = document.getElementById('subStatusText');
      const subStatusDescription = document.getElementById('subStatusDescription');
      const subStatusDetails = document.getElementById('subStatusDetails');

      if (subStatusBadge && subStatusText) {
        subStatusBadge.classList.remove('pro', 'free', 'warning');

        if (licenseInfo.isPro) {
          if (licenseInfo.expiryWarning) {
            subStatusBadge.classList.add('warning');
            subStatusText.textContent = 'PRO';
            subStatusDescription.textContent = pack.subscription_expiring || 'Subscription Expiring';
            subStatusDetails.textContent = pack.subscription_expiring_desc || 'Your subscription will expire soon';
          } else {
            subStatusBadge.classList.add('pro');
            subStatusText.textContent = 'PRO';
            subStatusDescription.textContent = pack.subscription_active || 'Active Subscription';
            subStatusDetails.textContent = pack.subscription_unlimited || 'Unlimited access to all features';
          }
        } else {
          subStatusBadge.classList.add('free');
          subStatusText.textContent = 'FREE';
          subStatusDescription.textContent = pack.subscription_free || 'Free Version';
          subStatusDetails.textContent = pack.subscription_limited || 'Limited to 5 uses';
        }
      }

      // Update subscription details
      updateSubscriptionDetails();

      // Update usage section for free users
      updateUsageSection();

      // Update warning section
      updateWarningSection();

      // Update action buttons
      updateActionButtons();
    }

    function updateSubscriptionDetails() {
      const pack = translations[state.language] || translations.en;

      const subDetailsSection = document.getElementById('subDetailsSection');
      const subType = document.getElementById('subType');
      const subPurchaseDate = document.getElementById('subPurchaseDate');
      const subExpiryDate = document.getElementById('subExpiryDate');
      const subDaysLeft = document.getElementById('subDaysLeft');

      console.log('updateSubscriptionDetails - licenseInfo:', licenseInfo);

      if (licenseInfo.isPro && licenseInfo.keyInfo) {
        const keyInfo = licenseInfo.keyInfo;
        console.log('updateSubscriptionDetails - keyInfo:', keyInfo);

        if (subDetailsSection) subDetailsSection.style.display = 'block';

        if (subType) {
          const typeMap = {
            'monthly': pack.subscription_monthly || 'Monthly',
            'yearly': pack.subscription_yearly || 'Yearly',
            'lifetime': pack.subscription_lifetime || 'Lifetime',
            'promo': pack.subscription_promo || 'Promotional'
          };
          subType.textContent = typeMap[keyInfo.subscriptionType] || keyInfo.subscriptionType;
        }

        if (subPurchaseDate) {
          if (keyInfo.purchaseDate) {
            try {
              const date = new Date(keyInfo.purchaseDate);
              subPurchaseDate.textContent = date.toLocaleDateString();
            } catch (e) {
              subPurchaseDate.textContent = keyInfo.purchaseDate;
            }
          } else {
            subPurchaseDate.textContent = pack.unknown || 'Unknown';
          }
        }

        if (subExpiryDate) {
          if (keyInfo.expirationDate) {
            try {
              const date = new Date(keyInfo.expirationDate);
              subExpiryDate.textContent = date.toLocaleDateString();
            } catch (e) {
              subExpiryDate.textContent = keyInfo.expirationDate;
            }
          } else {
            subExpiryDate.textContent = pack.never || 'Never';
          }
        }

        if (subDaysLeft) {
          if (keyInfo.daysRemaining === Infinity) {
            subDaysLeft.textContent = '‚àû';
          } else {
            subDaysLeft.textContent = keyInfo.daysRemaining || '0';
          }
        }
      } else {
        if (subDetailsSection) subDetailsSection.style.display = 'none';
      }
    }

    function updateUsageSection() {
      const pack = translations[state.language] || translations.en;
      const subUsageSection = document.getElementById('subUsageSection');
      const subUsageCount = document.getElementById('subUsageCount');
      const subUsageBar = document.getElementById('subUsageBar');
      const subFreeVersionTitle = document.getElementById('subFreeVersionTitle');
      const subUsageText = document.getElementById('subUsageText');

      if (!licenseInfo.isPro) {
        if (subUsageSection) subUsageSection.classList.remove('hidden');

        // Update free version title
        if (subFreeVersionTitle) {
          subFreeVersionTitle.textContent = pack.subscription_free || 'Free Version';
        }

        // Update usage text
        if (subUsageText) {
          const usageText = (pack.subscription_usage_text || 'Used: {used} of 5 free attempts').replace('{used}', licenseInfo.usageCount || 0);
          subUsageText.innerHTML = usageText;
        }

        if (subUsageCount) {
          subUsageCount.textContent = licenseInfo.usageCount || 0;
        }

        if (subUsageBar) {
          const usagePercent = ((licenseInfo.usageCount || 0) / 5) * 100;
          subUsageBar.style.width = `${Math.min(usagePercent, 100)}%`;
        }
      } else {
        if (subUsageSection) subUsageSection.classList.add('hidden');
      }
    }

    function updateWarningSection() {
      const pack = translations[state.language] || translations.en;
      const subWarningSection = document.getElementById('subWarningSection');
      const subWarningText = document.getElementById('subWarningText');
      const subWarningTitle = document.getElementById('subWarningTitle');

      if (licenseInfo.isPro && licenseInfo.expiryWarning && licenseInfo.daysUntilExpiry !== undefined) {
        if (subWarningSection) subWarningSection.classList.remove('hidden');

        // Update warning title
        if (subWarningTitle) {
          subWarningTitle.textContent = pack.subscription_expires_warning || 'Subscription expires soon!';
        }

        if (subWarningText) {
          const days = licenseInfo.daysUntilExpiry;
          let warningText;

          if (days <= 1) {
            warningText = pack.subscription_expires_today || 'Your subscription expires today!';
          } else {
            warningText = (pack.subscription_expires_warning_desc || 'Your subscription expires in {days} days. Renew it to keep access to Pro features.').replace('{days}', days);
          }

          subWarningText.textContent = warningText;
        }
      } else {
        if (subWarningSection) subWarningSection.classList.add('hidden');
      }
    }

    function updateActionButtons() {
      const pack = translations[state.language] || translations.en;

      const subProActions = document.getElementById('subProActions');
      const subFreeActions = document.getElementById('subFreeActions');

      // Update button texts
      const subRenewBtnText = document.getElementById('subRenewBtnText');
      const subManageBtnText = document.getElementById('subManageBtnText');
      const subUpgradeBtnText = document.getElementById('subUpgradeBtnText');
      const subRecoverBtnText = document.getElementById('subRecoverBtnText');

      if (subRenewBtnText) subRenewBtnText.textContent = pack.subscription_renew || 'Renew Subscription';
      if (subManageBtnText) subManageBtnText.textContent = pack.subscription_manage || 'Manage Subscription';
      if (subUpgradeBtnText) subUpgradeBtnText.textContent = pack.subscription_upgrade || 'Get PRO';
      if (subRecoverBtnText) subRecoverBtnText.textContent = pack.subscription_recover || 'Recover Subscription';

      // Show appropriate action buttons
      if (licenseInfo.isPro) {
        if (subProActions) subProActions.classList.remove('hidden');
        if (subFreeActions) subFreeActions.classList.add('hidden');
      } else {
        if (subProActions) subProActions.classList.add('hidden');
        if (subFreeActions) subFreeActions.classList.remove('hidden');
      }
    }

    function requestLicenseInfo() {
      if (typeof parent !== 'undefined' && parent.postMessage) {
        parent.postMessage({ pluginMessage: { type: 'get-license-info' } }, '*');
      }
    }

    function activateProWithKey() {
      const activationKey = document.getElementById('activationKey');
      const activateBtn = document.getElementById('activateBtn');
      const activationError = document.getElementById('activationError');
      const activationSuccess = document.getElementById('activationSuccess');
      const activationInfo = document.getElementById('activationInfo');
      const pack = translations[state.language] || translations.en;

      if (!activationKey || !activateBtn) return;

      const key = activationKey.value.trim();
      if (!key) {
        showActivationMessage(activationError, pack.activation_error || 'Please enter an activation key.');
        return;
      }

      // Basic format validation
      if (!key.startsWith('CT-')) {
        showActivationMessage(activationError, pack.activation_error_format || 'Invalid key format. Key should start with CT-');
        return;
      }

      // Disable button and show loading state
      activateBtn.disabled = true;
      activateBtn.textContent = pack.activation_processing || 'Processing...';

      // Hide previous messages
      if (activationError) activationError.style.display = 'none';
      if (activationSuccess) activationSuccess.style.display = 'none';
      if (activationInfo) activationInfo.style.display = 'none';

      // Send activation request to plugin backend
      if (typeof parent !== 'undefined' && parent.postMessage) {
        parent.postMessage({
          pluginMessage: {
            type: 'activate-with-key',
            key: key,
            testOtherDevice: false
          }
        }, '*');
      } else {
        // Fallback if parent is not available
        showActivationMessage(activationError, pack.activation_error_network || 'Unable to connect to plugin. Please try again.');
        resetActivationButton();
      }
    }

    function showActivationMessage(element, message) {
      // Hide all activation messages first
      const activationError = document.getElementById('activationError');
      const activationSuccess = document.getElementById('activationSuccess');
      const activationInfo = document.getElementById('activationInfo');

      if (activationError) activationError.style.display = 'none';
      if (activationSuccess) activationSuccess.style.display = 'none';
      if (activationInfo) activationInfo.style.display = 'none';

      // Show the specific message
      if (element) {
        element.textContent = message;
        element.style.display = 'block';
        setTimeout(() => {
          element.style.display = 'none';
        }, 5000);
      }
    }

    function resetActivationButton() {
      const activateBtn = document.getElementById('activateBtn');
      const activateBtnText = document.getElementById('activateBtnText');
      const pack = translations[state.language] || translations.en;

      if (activateBtn) {
        activateBtn.disabled = false;
        if (activateBtnText) {
          activateBtnText.textContent = pack.activation_button || 'Activate';
        } else {
          activateBtn.textContent = pack.activation_button || 'Activate';
        }
      }
    }

    // Modal event handlers
    document.addEventListener('DOMContentLoaded', () => {
      const modalClose = document.getElementById('modalClose');
      const modalCancel = document.getElementById('modalCancel');
      const buyProBtn = document.getElementById('buyProBtn');
      const getCodeBtn = document.getElementById('getCodeBtn');
      const upgradeBtn = document.getElementById('upgradeBtn');

      if (modalClose) modalClose.addEventListener('click', hideLicenseModal);
      if (modalCancel) modalCancel.addEventListener('click', hideLicenseModal);

      if (buyProBtn) {
        buyProBtn.addEventListener('click', () => {
          // Generate challenge and open bot with it
          if (typeof parent !== 'undefined' && parent.postMessage) {
            parent.postMessage({ pluginMessage: { type: 'generate-challenge' } }, '*');
          }
        });
      }

      if (getCodeBtn) {
        getCodeBtn.addEventListener('click', () => {
          // Generate challenge for subscription recovery
          if (typeof parent !== 'undefined' && parent.postMessage) {
            parent.postMessage({ pluginMessage: { type: 'generate-recovery-challenge' } }, '*');
          }
        });
      }

      if (upgradeBtn) {
        upgradeBtn.addEventListener('click', () => {
          showLicenseModal();
        });
      }

      // Activation key handler
      const activateBtn = document.getElementById('activateBtn');
      if (activateBtn) {
        activateBtn.addEventListener('click', () => {
          activateProWithKey();
        });
      }

      // Allow Enter key in activation input
      const activationKey = document.getElementById('activationKey');
      if (activationKey) {
        activationKey.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            activateProWithKey();
          }
        });
      }



      // Status badge click handler
      const statusBadge = document.getElementById('statusBadge');
      if (statusBadge) {
        statusBadge.addEventListener('click', () => {
          showSubscriptionModal();
        });
      }

      // Subscription modal handlers
      const subModalClose = document.getElementById('subModalClose');
      const subModalCancel = document.getElementById('subModalCancel');

      if (subModalClose) subModalClose.addEventListener('click', hideSubscriptionModal);
      if (subModalCancel) subModalCancel.addEventListener('click', hideSubscriptionModal);

      // Subscription action handlers
      const subRenewBtn = document.getElementById('subRenewBtn');
      const subManageBtn = document.getElementById('subManageBtn');
      const subUpgradeBtn = document.getElementById('subUpgradeBtn');
      const subRecoverBtn = document.getElementById('subRecoverBtn');

      if (subRenewBtn) {
        subRenewBtn.addEventListener('click', () => {
          // Generate challenge for renewal
          if (typeof parent !== 'undefined' && parent.postMessage) {
            parent.postMessage({ pluginMessage: { type: 'generate-challenge' } }, '*');
          }
          hideSubscriptionModal();
        });
      }

      if (subManageBtn) {
        subManageBtn.addEventListener('click', () => {
          // Open subscription management (could be a separate modal or external link)
          showLicenseModal();
          hideSubscriptionModal();
        });
      }

      if (subUpgradeBtn) {
        subUpgradeBtn.addEventListener('click', () => {
          // Show license modal for upgrade
          showLicenseModal();
          hideSubscriptionModal();
        });
      }

      if (subRecoverBtn) {
        subRecoverBtn.addEventListener('click', () => {
          // Generate recovery challenge
          if (typeof parent !== 'undefined' && parent.postMessage) {
            parent.postMessage({ pluginMessage: { type: 'generate-recovery-challenge' } }, '*');
          }
          hideSubscriptionModal();
        });
      }
    });

    // Initialize language after all DOM elements and variables are defined
    console.log('Starting language initialization...');
    try {
      initLanguage();
      apply();
      console.log('Language initialization completed successfully');

      // Request license info after initialization
      setTimeout(() => {
        requestLicenseInfo();
      }, 100);
    } catch (e) {
      console.log('Error applying language:', e);
      try { renderLanguageSwitcher(); } catch (_) { }
    }

    // Handle window resize to fix toolbar layout issues
    window.addEventListener('resize', () => {
      try {
        updateExpandBtnLabel();
      } catch (e) {
        console.log('Error updating expand button on resize:', e);
      }
    });

    // Request language from Figma storage on startup
    if (typeof parent !== 'undefined' && parent.postMessage) {
      parent.postMessage({ pluginMessage: { type: 'get-language' } }, '*');
      console.log('Requested language from Figma storage');

      // Also request after a small delay to ensure Figma is ready
      setTimeout(() => {
        parent.postMessage({ pluginMessage: { type: 'get-language' } }, '*');
        console.log('Requested language from Figma storage (delayed)');
      }, 100);
    }
  </script>
</body>

</html>